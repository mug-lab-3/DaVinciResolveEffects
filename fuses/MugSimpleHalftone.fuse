--[[--
Mug Halftone
--]] --

--******************************************************************************************************
FuRegisterClass("MugSimpleHalftone", CT_Tool, {
    REGS_Category          = "Fuses\\Mug",
    REGS_OpIconString      = "MSH",
    REGS_OpDescription     = "Mug Simple Halftone",
    REGS_HelpTopic         = "https://x.com/MugLab3",
    REGS_URL               = "https://www.youtube.com/@MugLabVideoEditing",
    REGS_IconID            = "Icons.Tools.Icons.SimpleHalftone",
    REG_Source_GlobalCtrls = true,
    REG_Source_SizeCtrls   = true,
    REG_Version            = 1.00,
})

-- セル情報計算用パラメータ構造体
CellInfoParams = [[
  int srcSize[2];         // ソース画像のサイズ // TEX_NORMALIZED_COORDS_FALSE
  int dstSize[2];         // 出力サイズ(cell数)
  int cellPitch[2];       // セルの間隔
  float contrast;         // コントラスト調整
  float dotGain;          // ドットゲイン効果
  float brightnessCutoff; // 明るさの閾値
  float minDotRadius;     // 最小ドット半径
  int useOriginalColor;   // 元の色を使用するかどうか
  float maxCellRadius;    // 最大セル半径
]]

-- セル情報計算カーネル
-- 中間バッファのフォーマット:
-- float4 cellInfo1:
--   x: セルIDX - グリッド座標系でのX位置 (整数値: 0 - dstSize[0]-1)
--   y: セルIDY - グリッド座標系でのY位置 (整数値: 0 - dstSize[1]-1)
--   z: セル中心位置X - ピクセル座標系でのX位置 (整数値: 0 - srcSize[0]-1)
--   w: セル中心位置Y - ピクセル座標系でのY位置 (整数値: 0 - srcSize[1]-1)
--
-- float4 cellInfo2:
--   x: セル輝度値 (0.0-1.0)
--   y: ドット半径 - 半径ドット数 (整数値: 0 - maxCellRadius)
--   z: 行オフセットフラグ - このセルの行はオフセットするか (整数値: 0=通常行, 1=オフセット行)
--   w: 予約済み - 将来拡張用 (常に1.0)
--
-- float4 cellInfo3:
--   x: 元の色R成分 - オリジナルカラーモード用 (0.0 - 1.0)
--   y: 元の色G成分 - オリジナルカラーモード用 (0.0 - 1.0)
--   z: 元の色B成分 - オリジナルカラーモード用 (0.0 - 1.0)
--   w: 元の色Aチャンネル - 透明度 (0.0 - 1.0)
--
--
-- ※レンダリングカーネルでは、各ピクセルが属するセルとその周辺セルの情報を参照して描画
CellInfoKernel = [[
#define LUMA_R 0.3f
#define LUMA_G 0.59f
#define LUMA_B 0.11f
#define SAMPLING_STEP_THRESHOLD 12.0f  // この値以上の半径でステップを増やす
#define SAMPLING_STEP_LARGE 2          // 大きな半径での間引き率

__KERNEL__ void CellInfoKernel(
    __CONSTANTREF__ CellInfoParams *params,
    __TEXTURE2D__ src,
    __TEXTURE2D_WRITE__ dst_info1,
    __TEXTURE2D_WRITE__ dst_info2,
    __TEXTURE2D_WRITE__ dst_info3)
{
    DEFINE_KERNEL_ITERATORS_XY(x, y);

    // 画像範囲外なら処理しない
    if (x >= params->dstSize[0] || y >= params->dstSize[1])
        return;

    // セルの間隔と行間隔をベクトルとして定義
    const float cellPitchX = (float)(params->cellPitch[0]);
    const float cellPitchY = (float)(params->cellPitch[1]);
    const float2 cellPitch = to_float2(cellPitchX, cellPitchY);
    const float halfPitchX = cellPitchX * 0.5f;

    // 半セル分Y位置をオフセット（固定値として半セル分）
    const float yOffset = cellPitchY * 0.5f;

    // 行オフセットの計算（奇数行は横にオフセット）
    const int isOddRow = (y % 2 != 0) ? 1 : 0;
    const float rowOffset = (isOddRow != 0) ? -halfPitchX : 0.0f;

    // セルの中心位置をピクセル座標で計算
    const float cellCenterX = ((float)x * cellPitchX) + halfPitchX + rowOffset;
    const float cellCenterY = ((float)y * cellPitchY) + (cellPitchY * 0.5f) - yOffset;

    // dst_info1: セル位置情報を格納
    const float4 cellInfo1 = {
        (float)x,      // セルIDX
        (float)y,      // セルIDY
        cellCenterX,   // セル中心X位置
        cellCenterY    // セル中心Y位置
    };

    // セルの周辺範囲を定義して平均輝度を計算
    const int samplingRadius = (int)(halfPitchX);
    const float radiusSquared = (float)(samplingRadius * samplingRadius);

    // サンプリングステップの動的調整
    int sampleStep = 1;
    if ((float)samplingRadius > SAMPLING_STEP_THRESHOLD) {
        sampleStep = SAMPLING_STEP_LARGE;
    }
    const float sampleStepSquared = (float)(sampleStep * sampleStep); // 事前計算

    float totalLuma = 0.0f;
    int sampleCount = 0;
    float4 avgColor = to_float4(0.0f, 0.0f, 0.0f, 0.0f);

    // ループ範囲の計算（境界チェック）
    const int minX = max(0, (int)(cellCenterX - (float)samplingRadius));
    const int maxX = min(params->srcSize[0] - 1, (int)(cellCenterX + (float)samplingRadius));
    const int minY = max(0, (int)(cellCenterY - (float)samplingRadius));
    const int maxY = min(params->srcSize[1] - 1, (int)(cellCenterY + (float)samplingRadius));

    // セル範囲内のピクセルをサンプリング - 円形サンプリング（サンプリングステップあり）
    for (int pixelY = minY; pixelY <= maxY; pixelY += sampleStep) {
        const float dy = (float)pixelY - cellCenterY;
        const float dySquared = dy * dy;

        for (int pixelX = minX; pixelX <= maxX; pixelX += sampleStep) {
            const float dx = (float)pixelX - cellCenterX;
            const float distSq = dx*dx + dySquared;

            // 円形範囲内のみをサンプリング
            if (distSq <= radiusSquared) {
                // ピクセル値を取得
                const float4 color = _tex2DVecN(src, pixelX, pixelY, 15);

                // 輝度計算
                const float luma = color.x * LUMA_R + color.y * LUMA_G + color.z * LUMA_B;

                // サンプリングステップの補正（事前計算した値を使用）
                totalLuma += luma * sampleStepSquared;
                sampleCount += sampleStep * sampleStep;

                // 色成分の累積
                avgColor.x += color.x * sampleStepSquared;
                avgColor.y += color.y * sampleStepSquared;
                avgColor.z += color.z * sampleStepSquared;
                avgColor.w += color.w * sampleStepSquared;
            }
        }
    }

    // サンプル数が0の場合の高速パス
    if (sampleCount == 0) {
        _tex2DVec4Write(dst_info1, x, y, cellInfo1);
        _tex2DVec4Write(dst_info2, x, y, to_float4(0.5f, 0.0f, (float)isOddRow, 1.0f));
        _tex2DVec4Write(dst_info3, x, y, to_float4(0.0f, 0.0f, 0.0f, 1.0f));
        return;
    }

    // 平均輝度と色の計算
    const float invSampleCount = (sampleCount > 0) ? (1.0f / (float)sampleCount) : 0.0f;
    float avgLuma = totalLuma * invSampleCount;

    // 色成分の平均値計算
    avgColor.x *= invSampleCount;
    avgColor.y *= invSampleCount;
    avgColor.z *= invSampleCount;
    avgColor.w *= invSampleCount;

    // コントラスト調整
    avgLuma = 0.5f + (avgLuma - 0.5f) * params->contrast;
    avgLuma = _saturatef(avgLuma);  // 0.0-1.0に制限

    // 輝度を反転（暗い部分ほど大きなドットに）
    float inverseLuma = 1.0f - avgLuma;

    // ドットゲイン適用
    inverseLuma = _saturatef(inverseLuma + params->dotGain);

    // 明るさのカットオフと最小ドット半径を一括処理
    float dotRadius = 0.0f;
    if (avgLuma <= params->brightnessCutoff && inverseLuma >= params->minDotRadius) {
        dotRadius = inverseLuma * params->maxCellRadius;
    }

    // dst_info2: ドット情報を格納
    const float4 cellInfo2 = {
        avgLuma,        // セル輝度値
        dotRadius,      // ドット半径
        (float)isOddRow, // 行オフセットフラグ
        1.0f            // 予約済み
    };

    // 結果を書き込み
    _tex2DVec4Write(dst_info1, x, y, cellInfo1);
    _tex2DVec4Write(dst_info2, x, y, cellInfo2);
    _tex2DVec4Write(dst_info3, x, y, avgColor);
}
]]

-- レンダリングパラメータ構造体
RenderParams = [[
  int srcSize[2];         // 入力画像のサイズ
  int cellGridNum[2];    // セルグリッド数 [X, Y]
  float paperColor[4];    // 紙の色（背景色）[R,G,B,A]
  float dotColor[4];      // ドットの色（前景色）[R,G,B,A]
  int useOriginalColor;   // 元の色を使用するかどうか
  float cellPitch[2];     // セルの間隔
]]

RenderDotsKernel = [[
// 定数定義
#define DOT_RADIUS_THRESHOLD 0.1f
#define BOUNDING_BOX_MARGIN 1.0f
#define HIGH_DENSITY_THRESHOLD 100.0f  // この値以上の密度は高密度と判断
#define MIN_CHECK_RADIUS 1.5f  // 最小チェック半径

// セルのドットチェック
__DEVICE__ bool checkCellDot(
    const float2 cellPos,
    const float2 pixelPos,
    const float2 cellGridNum,
    __TEXTURE2D__ cell_info1,
    __TEXTURE2D__ cell_info2,
    __TEXTURE2D__ cell_info3,
    const float4 dotColor,
    const int useOriginalColor,
    float4 *outputColor)
{
    // セルグリッド範囲内かチェック
    if (cellPos.x >= 0.0f && cellPos.x < cellGridNum.x &&
        cellPos.y >= 0.0f && cellPos.y < cellGridNum.y) {

        // セルのテクスチャ座標を計算
        const float2 cellUV = (cellPos + to_float2(0.5f, 0.5f)) / cellGridNum;

        // まずドット半径を取得（高速チェック用）
        const float4 cellInfo2Data = _tex2DVecN(cell_info2, cellUV.x, cellUV.y, 15);
        const float dotRadius = cellInfo2Data.y;

        // ドット半径が有効かつある程度大きい場合のみ計算（早期リターン最適化）
        if (dotRadius <= DOT_RADIUS_THRESHOLD) {
            return false;
        }

        // セルの中心座標を取得
        const float4 cellInfo1Data = _tex2DVecN(cell_info1, cellUV.x, cellUV.y, 15);
        const float2 cellCenter = to_float2(cellInfo1Data.z, cellInfo1Data.w);

        // バウンディングボックスチェック
        const float bbSize = dotRadius + BOUNDING_BOX_MARGIN;
        const float2 diff = pixelPos - cellCenter;
        const float2 absDiff = to_float2(_fabs(diff.x), _fabs(diff.y));

        if (absDiff.x > bbSize || absDiff.y > bbSize) {
            return false; // バウンディングボックス外ならすぐに失敗判定
        }

        // より正確な円形の距離計算 - 既に計算したdiffを再利用
        const float distSq = diff.x * diff.x + diff.y * diff.y;
        const float radiusSq = dotRadius * dotRadius;

        // ドット内に入っているかチェック
        if (distSq <= radiusSq) {
            // オリジナルカラーモードかチェック
            if (useOriginalColor > 0) {
                // 元の色を使用
                *outputColor = _tex2DVecN(cell_info3, cellUV.x, cellUV.y, 15);
            } else {
                // 指定されたドット色を使用
                *outputColor = dotColor;
            }
            return true; // ドット内に入っている
        }
    }
    return false; // ドット内に入っていない
}

// 隣接セルのオフセット定義
__DEVICE__ void getNeighborOffsets(const int isOddRow, float2 neighborOffsets[6])
{
    if (isOddRow != 0) {
        // 奇数行の隣接6セル
        neighborOffsets[0] = to_float2(-1.0f, -1.0f); // 上左
        neighborOffsets[1] = to_float2( 0.0f, -1.0f); // 上右
        neighborOffsets[2] = to_float2( 1.0f,  0.0f); // 右
        neighborOffsets[3] = to_float2( 0.0f,  1.0f); // 下右
        neighborOffsets[4] = to_float2(-1.0f,  1.0f); // 下左
        neighborOffsets[5] = to_float2(-1.0f,  0.0f); // 左
    } else {
        // 偶数行の隣接6セル
        neighborOffsets[0] = to_float2( 0.0f, -1.0f); // 上左
        neighborOffsets[1] = to_float2( 1.0f, -1.0f); // 上右
        neighborOffsets[2] = to_float2( 1.0f,  0.0f); // 右
        neighborOffsets[3] = to_float2( 1.0f,  1.0f); // 下右
        neighborOffsets[4] = to_float2( 0.0f,  1.0f); // 下左
        neighborOffsets[5] = to_float2(-1.0f,  0.0f); // 左
    }
}

// 高密度モード用の処理関数
__DEVICE__ bool processHighDensityCells(
    const float2 mainCellPos,
    const float2 pixelPos,
    const float2 relPos,
    const float2 cellPitch,
    const int isOddRow,
    const float2 cellGridNum,
    __TEXTURE2D__ cell_info1,
    __TEXTURE2D__ cell_info2,
    __TEXTURE2D__ cell_info3,
    const float4 dotColor,
    const int useOriginalColor,
    float4 *outputColor)
{
    // 隣接するセルのオフセット定義
    float2 neighborOffsets[6];
    getNeighborOffsets(isOddRow, neighborOffsets);

    // 最も近い隣接セルのみをチェック（最大2個）
    int checkIndices[2] = {-1, -1};
    int checkCount = 0;

    // 閾値を定義
    const float2 cellThreshold = cellPitch * 0.25f;

    // 相対位置の絶対値を計算
    const float2 absRelPos = to_float2(_fabs(relPos.x), _fabs(relPos.y));

    // X軸の相対位置で左右のセルを判断
    if (absRelPos.x > cellThreshold.x) {
        if (relPos.x > 0.0f) {
            checkIndices[checkCount++] = 2; // 右
        } else {
            checkIndices[checkCount++] = 5; // 左
        }
    }

    // Y軸の相対位置で上下のセルを判断
    if (absRelPos.y > cellThreshold.y) {
        if (relPos.y > 0.0f) {
            checkIndices[checkCount++] = isOddRow ? 3 : 4; // 下方向
        } else {
            checkIndices[checkCount++] = isOddRow ? 0 : 1; // 上方向
        }

        // 制限: 最大2セルまでしかチェックしない
        if (checkCount > 2) checkCount = 2;
    }

    // 選択した隣接セルのみをチェック
    for (int i = 0; i < checkCount; i++) {
        const int index = checkIndices[i];
        if (index < 0) continue;

        // 隣接セルの位置を計算
        const float2 cellPos = mainCellPos + neighborOffsets[index];

        if (checkCellDot(cellPos, pixelPos, cellGridNum, cell_info1, cell_info2, cell_info3,
                         dotColor, useOriginalColor, outputColor)) {
            return true; // ドットが見つかった
        }
    }

    return false; // どのドットにも該当しなかった
}

// 通常密度モード用の処理関数
__DEVICE__ bool processNormalDensityCells(
    const float2 mainCellPos,
    const int isOddRow,
    const float2 pixelPos,
    const float2 cellGridNum,
    __TEXTURE2D__ cell_info1,
    __TEXTURE2D__ cell_info2,
    __TEXTURE2D__ cell_info3,
    const float4 dotColor,
    const int useOriginalColor,
    float4 *outputColor)
{
    // 隣接するセルのオフセット定義
    float2 neighborOffsets[6];
    getNeighborOffsets(isOddRow, neighborOffsets);

    // 全隣接セルをチェック
    for (int i = 0; i < 6; i++) {
        const float2 cellPos = mainCellPos + neighborOffsets[i];

        if (checkCellDot(cellPos, pixelPos, cellGridNum, cell_info1, cell_info2, cell_info3,
                         dotColor, useOriginalColor, outputColor)) {
            return true; // ドットが見つかった
        }
    }

    return false; // どのドットにも該当しなかった
}

__KERNEL__ void RenderDotsKernel(
    __CONSTANTREF__ RenderParams *params,
    __TEXTURE2D__ cell_info1,
    __TEXTURE2D__ cell_info2,
    __TEXTURE2D__ cell_info3,
    __TEXTURE2D_WRITE__ dst)
{
    DEFINE_KERNEL_ITERATORS_XY(x, y);

    // 画像範囲外なら処理しない
    if (x >= params->srcSize[0] || y >= params->srcSize[1])
        return;

    // 背景色（紙の色）
    const float4 paperColor = {
        params->paperColor[0],
        params->paperColor[1],
        params->paperColor[2],
        params->paperColor[3]
    };

    // ドットの色
    const float4 dotColor = {
        params->dotColor[0],
        params->dotColor[1],
        params->dotColor[2],
        params->dotColor[3]
    };

    float4 outputColor = paperColor;

    // 現在のピクセル位置をベクトルとして定義
    const float2 pixelPos = to_float2((float)x, (float)y);

    // セルの間隔
    const float2 cellPitch = to_float2(params->cellPitch[0], params->cellPitch[1]);

    // 半セル分Y位置をオフセット（固定値として半セル分）
    const float yOffset = cellPitch.y * 0.5f;

    // 高密度チェック
    const float avgCellSize = (cellPitch.x + cellPitch.y) * 0.5f;
    const int isHighDensity = avgCellSize < MIN_CHECK_RADIUS ? 1 : 0;

    // このピクセルが属する行の情報
    const int baseRowY = (int)((pixelPos.y + yOffset) / cellPitch.y);
    const int isOddRow = (baseRowY % 2 != 0) ? 1 : 0;

    // メインセルの計算
    float adjustedX = pixelPos.x;
    if (isOddRow != 0) {
        adjustedX += cellPitch.x * 0.5f; // オフセット行の調整
    }
    const int mainCellX = (int)_floorf(adjustedX / cellPitch.x);
    const int mainCellY = baseRowY;
    const float2 mainCellPos = to_float2((float)mainCellX, (float)mainCellY);

    // グリッド情報
    const float2 cellGridNum = to_float2(
        (float)params->cellGridNum[0],
        (float)params->cellGridNum[1]
    );

    // まず中央のセルだけをチェック（最も可能性が高い）
    if (checkCellDot(mainCellPos, pixelPos, cellGridNum, cell_info1, cell_info2, cell_info3,
                     dotColor, params->useOriginalColor, &outputColor)) {
        _tex2DVec4Write(dst, x, y, outputColor);
        return;
    }

    // セルの中心位置をfloat2演算で計算
    const float2 cellCenter = to_float2(
        mainCellX * cellPitch.x + (isOddRow != 0 ? cellPitch.x * 0.5f : 0.0f) + cellPitch.x * 0.5f,
        mainCellY * cellPitch.y + cellPitch.y * 0.5f
    );

    // ピクセルのセル内相対位置
    const float2 relPos = pixelPos - cellCenter;

    // 密度に応じた処理関数を呼び出し
    int foundDot = 0;

    if (isHighDensity != 0) {
        // 高密度モード - 最適化された隣接セルチェック
        foundDot = processHighDensityCells(
            mainCellPos, pixelPos, relPos, cellPitch, isOddRow, cellGridNum,
            cell_info1, cell_info2, cell_info3, dotColor, params->useOriginalColor, &outputColor
        ) ? 1 : 0;
    } else {
        // 通常密度モード - すべての隣接セルをチェック
        foundDot = processNormalDensityCells(
            mainCellPos, isOddRow, pixelPos, cellGridNum,
            cell_info1, cell_info2, cell_info3, dotColor, params->useOriginalColor, &outputColor
        ) ? 1 : 0;
    }

    if (foundDot != 0) {
        _tex2DVec4Write(dst, x, y, outputColor);
        return;
    }

    // どのドットにも入っていない場合は背景色を出力
    _tex2DVec4Write(dst, x, y, paperColor);
}
]]

function Create()
    local groupID = 0

    InScreenDensity = self:AddInput("Screen Density", "ScreenDensity", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 150.0,
        INP_MinAllowed = 1,
        INP_MaxAllowed = 600.0,
        INPID_PreviewControl = "RangeControl",
        INP_Integer = false,
        INPS_StatusText = "Controls the density of the halftone pattern in CMYK mode",
    })

    InContrast = self:AddInput("Contrast", "Contrast", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 1.0,
        INP_MinAllowed = 0.1,
        INP_MaxAllowed = 15.0,
        INPS_StatusText = "Adjusts the contrast of the halftone pattern",
    })

    self:BeginControlNest("Dot", "Dot", true);
    InDotGain = self:AddInput("Dot Gain", "DotGain", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.00,
        INP_MinAllowed = -0.5,
        INP_MaxAllowed = 0.5,
        INPS_StatusText = "Simulates ink spread on paper",
    })

    InBrightnessCutoff = self:AddInput("Brightness Cutoff", "BrightnessCutoff", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.75,
        INP_MinAllowed = 0.0,
        INP_MaxAllowed = 1.0,
        INPS_StatusText = "Brightness threshold above which dots are not drawn",
    })

    InMinDotRadius = self:AddInput("Minimum Dot Radius", "MinDotRadius", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.05,
        INP_MinAllowed = 0.0,
        INP_MaxAllowed = 1.0,
        INPS_StatusText = "Dots smaller than this radius are not drawn",
    })

    InRegError = self:AddInput("Registration Error", "RegError", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.5,
        INP_MinAllowed = 0.0,
        INP_MaxAllowed = 1.0,
        INPS_StatusText = "Simulates misalignment between color plates",
    })

    InUcrAmount = self:AddInput("UCR Amount", "UcrAmount", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.0,
        INP_MinAllowed = 0.0,
        INP_MaxAllowed = 1.0,
        INPS_StatusText = "Controls Under Color Removal in CMYK mode",
    })

    InUseOriginalColor = self:AddInput("Use Original Color", "UseOriginalColor", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Default = 0.0,
        INPS_StatusText = "Preserves original colors instead of black and white",
    })

    groupID = groupID + 1
    InDotColorRed = self:AddInput("Dot Color Red", "DotColorRed", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 0.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupID,
        IC_ControlID       = 0, -- Red ID
        INPS_StatusText    = "Sets the dot color (foreground)",
    })

    InDotColorGreen = self:AddInput("Dot Color Green", "DotColorGreen", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 0.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupID,
        IC_ControlID       = 1, -- Green ID
        INPS_StatusText    = "Sets the dot color (foreground)",
    })

    InDotColorBlue = self:AddInput("Dot Color Blue", "DotColorBlue", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 0.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupID,
        IC_ControlID       = 2, -- Blue ID
        INPS_StatusText    = "Sets the dot color (foreground)",
    })

    InDotColorAlpha = self:AddInput("Dot Color Alpha", "DotColorAlpha", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupID,
        IC_ControlID       = 3, -- Alpha ID
        INPS_StatusText    = "Sets the dot color (foreground)",
    })
    self:EndControlNest()

    self:BeginControlNest("Paper", "Paper", true);
    InPaperColorPreset = self:AddInput("Paper Color Preset", "PaperColorPreset", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ComboControl",
        INP_Default = 0,
        INP_Integer = true,
        INP_DoNotifyChanged = true,
        { CCS_AddString = "Custom" },
        { CCS_AddString = "Pure White" },
        { CCS_AddString = "Warm White" },
        { CCS_AddString = "Cool White" },
        { CCS_AddString = "Natural White" },
        { CCS_AddString = "Cream" },
        { CCS_AddString = "Ivory" },
        { CCS_AddString = "Light Gray" },
        { CCS_AddString = "Newspaper" },
        { CCS_AddString = "Vintage" },
        { CCS_AddString = "Kraft" },
        { CCS_AddString = "Recycled" },
        { CCS_AddString = "Light Blue" },
        { CCS_AddString = "Light Green" },
        { CCS_AddString = "Light Pink" },
        { CCS_AddString = "Light Yellow" },
        INPS_StatusText = "Select from common paper color presets",
    })

    groupID = groupID + 1
    InPaperColorRed = self:AddInput("Paper Color Red", "PaperColorRed", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupID,
        IC_ControlID       = 0, -- Red ID
        INPS_StatusText    = "Sets the paper color (background)",
    })

    InPaperColorGreen = self:AddInput("Paper Color Green", "PaperColorGreen", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupID,
        IC_ControlID       = 1, -- Green ID
        INPS_StatusText    = "Sets the paper color (background)",
    })

    InPaperColorBlue = self:AddInput("Paper Color Blue", "PaperColorBlue", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupID,
        IC_ControlID       = 2, -- Blue ID
        INPS_StatusText    = "Sets the paper color (background)",
    })

    InPaperColorAlpha = self:AddInput("Paper Color Alpha", "PaperColorAlpha", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupID,
        IC_ControlID       = 3, -- Alpha ID
        INPS_StatusText    = "Sets the paper color (background)",
    })
    self:EndControlNest()

    InImage = self:AddInput("Input Image", "Image", {
        LINKID_DataType = "Image",
        LINK_Main = 1,
        INPS_StatusText = "Input image to be processed",
    })

    OutImage = self:AddOutput("Output", "Output", {
        LINKID_DataType = "Image",
        LINK_Main = 1,
    })
end

function Process(req)
    -- 入力画像が無い場合は何もしない
    local img = InImage:GetValue(req)
    if img == nil then
        OutImage:Set(req, nil)
        return
    end

    -- 入力パラメータの取得
    local contrast = InContrast:GetValue(req).Value
    local screenDensity = InScreenDensity:GetValue(req).Value
    local dotGain = InDotGain:GetValue(req).Value
    local useOriginalColor = InUseOriginalColor:GetValue(req).Value
    local brightnessCutoff = InBrightnessCutoff:GetValue(req).Value
    local minDotRadius = InMinDotRadius:GetValue(req).Value
    local paperColor = {
        InPaperColorRed:GetValue(req).Value,
        InPaperColorGreen:GetValue(req).Value,
        InPaperColorBlue:GetValue(req).Value,
        InPaperColorAlpha:GetValue(req).Value,
    }
    local dotColor = {
        InDotColorRed:GetValue(req).Value,
        InDotColorGreen:GetValue(req).Value,
        InDotColorBlue:GetValue(req).Value,
        InDotColorAlpha:GetValue(req).Value,
    }

    local width = img.DataWindow:Width()
    local height = img.DataWindow:Height()

    -- セル情報バッファサイズの計算
    -- 定数の修正
    local SIN60 = 0.866025 -- √3/2
    local cellBasePitch = math.floor(math.max(3.0, width / screenDensity))
    local cellPitchX = cellBasePitch
    local cellPitchY = math.floor(math.max(3.0, cellBasePitch * SIN60))
    local MAX_CELL_RADIUS = (cellBasePitch * 0.5) * 1.5

    -- セルの配列サイズを計算
    local cellGridNumX = math.ceil(width / cellPitchX) + 3
    local cellGridNumY = math.ceil(height / cellPitchY) + 2

    -- セル情報用の中間バッファを作成
    local cellInfo1 = Image({
        IMG_Width = cellGridNumX,
        IMG_Height = cellGridNumY,
        IMG_Depth = 8,
    })

    local cellInfo2 = Image({
        IMG_Width = cellGridNumX,
        IMG_Height = cellGridNumY,
        IMG_Depth = 8,
    })

    local cellInfo3 = Image({
        IMG_Width = cellGridNumX,
        IMG_Height = cellGridNumY,
        IMG_Depth = 8,
    })

    local out = Image({ IMG_Like = img })

    -- ステップ1: セル情報計算カーネル実行
    local cellInfoNode = DVIPComputeNode(req, "CellInfoKernel", CellInfoKernel, "CellInfoParams", CellInfoParams)

    if cellInfoNode then
        -- パラメータをカーネルに設定
        local params = cellInfoNode:GetParamBlock(CellInfoParams)
        params.srcSize[0] = width
        params.srcSize[1] = height
        params.dstSize[0] = cellGridNumX
        params.dstSize[1] = cellGridNumY
        params.cellPitch[0] = cellPitchX
        params.cellPitch[1] = cellPitchY
        params.contrast = contrast
        params.dotGain = dotGain
        params.brightnessCutoff = brightnessCutoff
        params.minDotRadius = minDotRadius
        params.useOriginalColor = useOriginalColor > 0.5 and 1 or 0

        params.maxCellRadius = MAX_CELL_RADIUS

        cellInfoNode:SetParamBlock(params)
        cellInfoNode:AddSampler("RowSampler", TEX_FILTER_MODE_POINT, TEX_ADDRESS_MODE_CLAMP,
            TEX_NORMALIZED_COORDS_FALSE)
        cellInfoNode:AddInput("src", img)
        cellInfoNode:AddOutput("dst_info1", cellInfo1)
        cellInfoNode:AddOutput("dst_info2", cellInfo2)
        cellInfoNode:AddOutput("dst_info3", cellInfo3)

        local success = cellInfoNode:RunSession(req)
        if not success then
            -- エラーがあれば元の画像を返却
            OutImage:Set(req, img)
            return
        end
    end

    -- ステップ2: ドット描画カーネル実行
    local renderNode = DVIPComputeNode(req, "RenderDotsKernel", RenderDotsKernel, "RenderParams", RenderParams)

    if renderNode then
        -- パラメータをカーネルに設定
        local params = renderNode:GetParamBlock(RenderParams)
        params.srcSize[0] = width
        params.srcSize[1] = height
        params.paperColor[0] = paperColor[1]
        params.paperColor[1] = paperColor[2]
        params.paperColor[2] = paperColor[3]
        params.paperColor[3] = paperColor[4]
        params.cellGridNum[0] = cellGridNumX
        params.cellGridNum[1] = cellGridNumY
        params.dotColor[0] = dotColor[1]
        params.dotColor[1] = dotColor[2]
        params.dotColor[2] = dotColor[3]
        params.dotColor[3] = dotColor[4]
        params.useOriginalColor = useOriginalColor > 0.5 and 1 or 0
        params.cellPitch[0] = cellPitchX
        params.cellPitch[1] = cellPitchY

        renderNode:SetParamBlock(params)
        renderNode:AddSampler("RowSampler", TEX_FILTER_MODE_POINT, TEX_ADDRESS_MODE_CLAMP,
            TEX_NORMALIZED_COORDS_TRUE)
        --  renderNode:AddSampler("CellCenterSampler", TEX_FILTER_MODE_POINT, TEX_ADDRESS_MODE_CLAMP,
        --      TEX_NORMALIZED_COORDS_FALSE)
        renderNode:AddInput("cell_info1", cellInfo1)
        renderNode:AddInput("cell_info2", cellInfo2)
        renderNode:AddInput("cell_info3", cellInfo3)
        renderNode:AddOutput("dst", out)

        local success = renderNode:RunSession(req)
        if not success then
            -- エラーがあれば元の画像を返却
            OutImage:Set(req, img)
            return
        end
    else
        out = img
    end

    -- 最終出力
    -- OutImage:Set(req, cellInfo1)
    -- OutImage:Set(req, cellInfo2)
    -- OutImage:Set(req, cellInfo3)
    -- OutImage:Set(req, cellInfo4)
    OutImage:Set(req, out)
end

function NotifyChanged(inp, param, time)
    if inp == InPaperColorPreset then
        -- 紙の色プリセットが選択された場合
        local presetIndex = math.floor(param.Value + 0.5)

        -- プリセット値の設定
        local r, g, b = 1.0, 1.0, 1.0 -- デフォルト値（白）

        if presetIndex == 1 then      -- Pure White
            r, g, b = 1.00, 1.00, 1.00
        elseif presetIndex == 2 then  -- Warm White
            r, g, b = 1.00, 0.98, 0.94
        elseif presetIndex == 3 then  -- Cool White
            r, g, b = 0.97, 0.97, 1.00
        elseif presetIndex == 4 then  -- Natural White
            r, g, b = 0.98, 0.98, 0.96
        elseif presetIndex == 5 then  -- Cream
            r, g, b = 0.97, 0.95, 0.86
        elseif presetIndex == 6 then  -- Ivory
            r, g, b = 1.00, 0.97, 0.90
        elseif presetIndex == 7 then  -- Light Gray
            r, g, b = 0.90, 0.90, 0.90
        elseif presetIndex == 8 then  -- Newspaper
            r, g, b = 0.93, 0.91, 0.83
        elseif presetIndex == 9 then  -- Vintage
            r, g, b = 0.96, 0.92, 0.80
        elseif presetIndex == 10 then -- Kraft
            r, g, b = 0.85, 0.75, 0.58
        elseif presetIndex == 11 then -- Recycled
            r, g, b = 0.87, 0.87, 0.82
        elseif presetIndex == 12 then -- Light Blue
            r, g, b = 0.90, 0.95, 1.00
        elseif presetIndex == 13 then -- Light Green
            r, g, b = 0.90, 0.98, 0.90
        elseif presetIndex == 14 then -- Light Pink
            r, g, b = 1.00, 0.90, 0.93
        elseif presetIndex == 15 then -- Light Yellow
            r, g, b = 1.00, 1.00, 0.88
        end

        -- カラーコントロールに値をセット
        if presetIndex > 0 then
            InPaperColorRed:SetSource(Number(r), time)
            InPaperColorGreen:SetSource(Number(g), time)
            InPaperColorBlue:SetSource(Number(b), time)
        end
    end

    return true
end
