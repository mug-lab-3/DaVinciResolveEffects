local ffi = require("ffi")

FuRegisterClass("MugKeyFrames", CT_Modifier, {
   REGS_Name           = "MugKeyFrames",
   REGS_Category       = "Mug",
   REGS_OpIconString   = "MKF",
   REGS_OpDescription  = "MugKeyFrames",
   REGS_HelpTopic      = "https://x.com/MugLab3", --This can be a URL
   REGS_URL            = "https://www.youtube.com/@MugLabVideoEditing",
   REGID_DataType      = "Number",
   REGID_InputDataType = "Number",
   REG_TimeVariant     = true,
})

local InKeyFrameInfo = {
   New = function(memo,
                  keyOrder,
                  autoLinkValues,
                  startValue,
                  endValue,
                  offsetFrame,
                  durationFrame,
                  easing,
                  easingParamsP1,
                  easingParamsP2,
                  jumpTo,
                  labelKey,
                  labelValue,
                  labelTime)
      return {
         Memo = memo,
         KeyOrder = keyOrder,
         AutoLinkValues = autoLinkValues,
         StartValue = startValue,
         EndValue = endValue,
         OffsetFrame = offsetFrame,
         DurationFrame = durationFrame,
         Easing = easing,
         EasingParamsP1 = easingParamsP1,
         EasingParamsP2 = easingParamsP2,
         JumpTo = jumpTo,
         LabelKey = labelKey,
         LabelValue = labelValue,
         LabelTime = labelTime,
      }
   end
}

local KEY_FRAMES_NUM = 15
function Create()
   self:BeginControlNest("Common", "Common", true);

   self:AddInput("Memo", "MemoGlobal", {
      LINKID_DataType    = "Text",
      INPID_InputControl = "TextEditControl",
      TEC_Lines          = 1,
      INP_External       = false,
   })

   InKeyFramesNum = self:AddInput("Key Frames Num", "KeyFramesNum", {
      LINKID_DataType     = "Number",
      INPID_InputControl  = "SliderControl",
      INP_Integer         = true,
      INP_Default         = 1,
      INP_MinScale        = 1,
      INP_MaxScale        = KEY_FRAMES_NUM,
      INP_MinAllowed      = 1,
      INP_MaxAllowed      = KEY_FRAMES_NUM,
      INP_InitialNotify   = true,
      INP_DoNotifyChanged = true,
      INP_External        = false,
   })

   InTimeUnit = self:AddInput("Time Unit", "TimeUnit", {
      LINKID_DataType    = "Number",
      INPID_InputControl = "MultiButtonControl",
      { MBTNC_AddButton = "Frames",  MBTNCD_ButtonWidth = 1 / 2, },
      { MBTNC_AddButton = "Seconds", MBTNCD_ButtonWidth = 1 / 2, },
      INP_Default         = 0,
      INP_Integer         = true,
      --INP_InitialNotify   = false,
      INP_DoNotifyChanged = true,
      INP_External        = false,
      -- INP_Disabled = true,
   })

   InRepeatMode = self:AddInput("Repeat Mode", "RepeatMode", {
      LINKID_DataType    = "Number",
      INPID_InputControl = "MultiButtonControl",
      INP_Default        = 0,
      { MBTNC_AddButton = "None",          MBTNCD_ButtonWidth = 1 / 3, },
      { MBTNC_AddButton = "Normal Repeat", MBTNCD_ButtonWidth = 1 / 3, },
      { MBTNC_AddButton = "Mirror Repeat", MBTNCD_ButtonWidth = 1 / 3, },
      INP_DoNotifyChanged = true,
      INP_Integer         = true,
      INP_External        = false,
   })

   InPreRollTime = self:AddInput("Pre-Roll Time", "PreRollTime", {
      LINKID_DataType    = "Number",
      INPID_InputControl = "ScrewControl",
      --INP_Integer        = true,
      INP_Default        = 0,
      INP_MinScale       = -100,
      INP_MaxScale       = 100,
      -- INP_External       = false,
   })
   self:EndControlNest()

   self:BeginControlNest("Debug", "Debug", false);
   InDebugText = self:AddInput("Key Information", "KeyInformationText", {
      LINKID_DataType    = "Text",
      INPID_InputControl = "TextEditControl",
      TEC_Lines          = 10,
      TEC_ReadOnly       = true,
      INP_Passive        = true,
      INP_External       = false,
   })

   InDebugButton = self:AddInput("Display Key Information", "KeyInformationButton", {
      LINKID_DataType     = "Number",
      INPID_InputControl  = "ButtonControl",
      INP_DoNotifyChanged = true,
      INP_Passive         = true,
      INP_External        = false,
   })
   self:EndControlNest()

   InKeyFrameInfos = {}
   for i = 1, KEY_FRAMES_NUM do
      local inLabelKey = self:BeginControlNest("Key " .. i, "Key" .. i, true);


      local inMemo = self:AddInput("Memo", "Memo" .. i, {
         LINKID_DataType    = "Text",
         INPID_InputControl = "TextEditControl",
         TEC_Lines          = 1,
         INP_External       = false,
      })

      local inKeyOrder = self:AddInput("Key Swap", "KeySwap" .. i, {
         LINKID_DataType    = "Number",
         INPID_InputControl = "MultiButtonControl",
         MBTNC_Type         = "Normal",
         INP_Default        = 0,
         { MBTNC_AddButton = "▲", MBTNCD_ButtonWidth = 1 / 3, },
         { MBTNC_AddButton = "▼", MBTNCD_ButtonWidth = 1 / 3, },
         INP_InitialNotify   = false,
         INP_DoNotifyChanged = true,
         INP_Integer         = true,
         INP_External        = false,
      })

      local inJumpTo = self:AddInput("Seek To Keyframe", "JumpTo" .. i, {
         LINKID_DataType    = "Number",
         INPID_InputControl = "MultiButtonControl",
         MBTNC_Type         = "Normal",
         INP_Default        = 0,
         { MBTNC_AddButton = "Start", MBTNCD_ButtonWidth = 1 / 3, },
         { MBTNC_AddButton = "End",   MBTNCD_ButtonWidth = 1 / 3, },
         INP_InitialNotify   = false,
         INP_DoNotifyChanged = true,
         INP_Integer         = true,
         INP_External        = false,
      })

      local inLabelValue = self:BeginControlNest("Value", "Value" .. i, true);

      local autoLinkedValuesVisible = true
      if i == 1 then
         autoLinkedValuesVisible = false
      end
      local inAutoLinkValues = self:AddInput("Auto-Link Values", "AutoLinkValues" .. i, {
         LINKID_DataType     = "Number",
         INPID_InputControl  = "CheckboxControl",
         CBC_TriState        = true,
         INP_Integer         = true,
         INP_Default         = 0,
         --INP_MinAllowed      = 0,
         --INP_MaxAllowed      = 2,
         -- INP_InitialNotify      = true,
         INP_DoNotifyChanged = true,
         INP_External        = false,
         IC_Visible          = autoLinkedValuesVisible,
      })

      local inStart = self:AddInput("Start", "Start" .. i, {
         LINKID_DataType    = "Number",
         INPID_InputControl = "ScrewControl",
         INP_Default        = 0,
         INP_Disabled       = false,
         -- INP_External       = false,
         IC_Visible         = false,
      })

      local inEnd = self:AddInput("End", "End" .. i, {
         LINKID_DataType    = "Number",
         INPID_InputControl = "ScrewControl",
         INP_Default        = 0,
         -- INP_External       = false,
      })

      local inEasing = self:AddInput("Ease", "Ease" .. i, {
         LINKID_DataType    = "Number",
         INPID_InputControl = "ComboControl",
         INP_Integer        = true,
         INP_MinAllowed     = 0,
         INP_MinScale       = 0,
         INP_Default        = 0,
         { CCS_AddString = "Linear", },
         { CCS_AddString = "InStep", },
         { CCS_AddString = "OutStep", },
         { CCS_AddString = "InSine", },
         { CCS_AddString = "OutSine", },
         { CCS_AddString = "InOutSine", },
         { CCS_AddString = "InQuad", },
         { CCS_AddString = "OutQuad", },
         { CCS_AddString = "InOutQuad", },
         { CCS_AddString = "InCubic", },
         { CCS_AddString = "OutCubic", },
         { CCS_AddString = "InOutCubic", },
         { CCS_AddString = "InQuart", },
         { CCS_AddString = "OutQuart", },
         { CCS_AddString = "InOutQuart", },
         { CCS_AddString = "InQuint", },
         { CCS_AddString = "OutQuint", },
         { CCS_AddString = "InOutQuint", },
         { CCS_AddString = "InExpo", },
         { CCS_AddString = "OutExpo", },
         { CCS_AddString = "InOutExpo", },
         { CCS_AddString = "InCirc", },
         { CCS_AddString = "OutCirc", },
         { CCS_AddString = "InOutCirc", },
         { CCS_AddString = "InElastic", },
         { CCS_AddString = "OutElastic", },
         { CCS_AddString = "InOutElastic", },
         { CCS_AddString = "InBounce", },
         { CCS_AddString = "OutBounce", },
         { CCS_AddString = "InOutBounce", },
         { CCS_AddString = "InSpiralDecay", },
         { CCS_AddString = "OutSpiralDecay", },
         { CCS_AddString = "InOutSpiralDecay", },
         { CCS_AddString = "BounceGravity", },
         CC_LabelPosition = "Horizontal",
         -- INP_External     = false,
         INP_DoNotifyChanged = true,
      })
      self:EndControlNest()

      local inEasingParamsP1 = self:AddInput("Ease Params P1", "EaseParamsP1" .. i, {
         LINKID_DataType    = "Number",
         INPID_InputControl = "SliderControl",
         --INP_Integer        = true,
         INP_Default        = 1,
         INP_MinScale       = -5,
         INP_MaxScale       = 5,
         -- INP_External       = false,
      })

      local inEasingParamsP2 = self:AddInput("Ease Params P2", "EaseParamsP2" .. i, {
         LINKID_DataType    = "Number",
         INPID_InputControl = "SliderControl",
         --INP_Integer        = true,
         INP_Default        = 1,
         INP_MinScale       = -5,
         INP_MaxScale       = 5,
         -- INP_External       = false,
      })

      local inLabelTime = self:BeginControlNest("Time", "Time" .. i, true);
      local inOffset = self:AddInput("Delay", "Delay" .. i, {
         LINKID_DataType    = "Number",
         INPID_InputControl = "ScrewControl",
         INP_MinAllowed     = 0,
         INP_MinScale       = 0,
         INP_MaxScale       = 100,
         INP_Default        = 0,
         -- INP_Integer        = true,
         IC_Steps           = 1,
         -- INP_External       = false,
      })

      local inDuration = self:AddInput("Duration", "Duration" .. i, {
         LINKID_DataType    = "Number",
         INPID_InputControl = "ScrewControl",
         INP_MinAllowed     = 0,
         INP_MinScale       = 1,
         INP_MaxScale       = 100,
         INP_Default        = 10,
         -- INP_Integer        = true,
         IC_Steps           = 1,
         -- INP_External       = false,
      })
      self:EndControlNest()
      self:EndControlNest()

      table.insert(InKeyFrameInfos,
         InKeyFrameInfo.New(
            inMemo,
            inKeyOrder,
            inAutoLinkValues,
            inStart,
            inEnd,
            inOffset,
            inDuration,
            inEasing,
            inEasingParamsP1,
            inEasingParamsP2,
            inJumpTo,
            inLabelKey,
            inLabelValue,
            inLabelTime
         )
      )
   end

   -- self:AddControlPage("Restore")

   -- InMagicSpell = self:AddInput("Magic Spell", "MagicSpell", {
   --    LINKID_DataType    = "Text",
   --    INPID_InputControl = "TextEditControl",
   --    TEC_Lines          = 30,
   -- })

   -- InSaveRestore = self:AddInput("SaveRestore", "SaveRestore", {
   --    LINKID_DataType    = "Number",
   --    INPID_InputControl = "MultiButtonControl",
   --    MBTNC_Type         = "Normal",
   --    MBTNC_ShowLabel    = false,
   --    INP_Default        = 0,
   --    { MBTNC_AddButton = "Show",    MBTNCD_ButtonWidth = 1 / 3, },
   --    { MBTNC_AddButton = "Restore", MBTNCD_ButtonWidth = 1 / 3, },
   --    INP_InitialNotify   = false,
   --    INP_DoNotifyChanged = true,
   --    INP_Integer         = true,
   --    INP_External        = false,
   -- })

   OutValue = self:AddOutput("Output", "Output", {
      LINKID_DataType = "Number",
      LINK_Main = 1,
   })
end

local function easeLinear(t, params)
   return t
end

local function easeInStep(t, params)
   return 1
end

local function easeOutStep(t, params)
   if t == 1 then
      return 1
   else
      return 0
   end
end

local function easeInSine(t, params)
   return 1 - math.cos((t * math.pi) / 2)
end

local function easeOutSine(t, params)
   return math.sin((t * math.pi) / 2)
end

local function easeInOutSine(t, params)
   return -(math.cos(math.pi * t) - 1) / 2
end

local function easeInQuad(t, params)
   return t ^ 2
end

local function easeOutQuad(t, params)
   return 1 - (1 - t) * (1 - t)
end

local function easeInOutQuad(t, params)
   if t < 0.5 then
      return 2 * t * t
   else
      return 1 - ((-2 * t + 2) ^ 2) / 2
   end
end

local function easeInCubic(t, params)
   return t ^ 3
end

local function easeOutCubic(t, params)
   return 1 - (1 - t) ^ 3
end

local function easeInOutCubic(t, params)
   if t < 0.5 then
      return 4 * t ^ 3
   else
      return 1 - ((-2 * t + 2) ^ 3) / 2
   end
end

local function easeInQuart(t, params)
   return t ^ 4
end

local function easeOutQuart(t, params)
   return 1 - (1 - t) ^ 4
end

local function easeInOutQuart(t, params)
   if t < 0.5 then
      return 8 * t ^ 4
   else
      return 1 - ((-2 * t + 2) ^ 4) / 2
   end
end

local function easeInQuint(t, params)
   return t ^ 5
end

local function easeOutQuint(t, params)
   return 1 - (1 - t) ^ 5
end

local function easeInOutQuint(t, params)
   if t < 0.5 then
      return 16 * t ^ 5
   else
      return 1 - ((-2 * t + 2) ^ 5) / 2
   end
end

local function easeInExpo(t, params)
   if t == 0 then
      return 0
   else
      return 2 ^ (10 * t - 10)
   end
end

local function easeOutExpo(t, params)
   if t == 1 then
      return 1
   else
      return 1 - 2 ^ (-10 * t)
   end
end

local function easeInOutExpo(t, params)
   if t == 0 then
      return 0
   elseif t == 1 then
      return 1
   elseif t < 0.5 then
      return (2 ^ (20 * t - 10)) / 2
   else
      return (2 - 2 ^ (-20 * t + 10)) / 2
   end
end

local function easeInCirc(t, params)
   return 1 - math.sqrt(1 - t ^ 2)
end

local function easeOutCirc(t, params)
   return math.sqrt(1 - (t - 1) ^ 2)
end

local function easeInOutCirc(t, params)
   if t < 0.5 then
      return (1 - math.sqrt(1 - (2 * t) ^ 2)) / 2
   else
      return (math.sqrt(1 - (-2 * t + 2) ^ 2) + 1) / 2
   end
end

local function easeInElastic(t, params)
   local p = 0.3
   local s = p / 4

   if t == 0 then
      return 0
   elseif t == 1 then
      return 1
   else
      return -2 ^ (10 * (t - 1)) * math.sin((t - 1 - s) * (2 * math.pi) / p)
   end
end

local function easeOutElastic(t, params)
   local p = 0.3
   local s = p / 4

   if t == 0 then
      return 0
   elseif t == 1 then
      return 1
   else
      return 2 ^ (-10 * t) * math.sin((t - s) * (2 * math.pi) / p) + 1
   end
end

local function easeInOutElastic(t, params)
   local c5 = (2 * math.pi) / 4.5

   if t == 0 then
      return 0
   elseif t == 1 then
      return 1
   elseif t < 0.5 then
      return -((2 ^ (20 * t - 10)) * math.sin((20 * t - 11.125) * c5)) / 2
   else
      return ((2 ^ (-20 * t + 10)) * math.sin((20 * t - 11.125) * c5)) / 2 + 1
   end
end

local function easeOutBounce(t, params)
   local n1 = 7.5625
   local d1 = 2.75
   if t < 1 / d1 then
      return n1 * t * t
   elseif (t < 2 / d1) then
      local new_t = t - (1.5 / d1)
      return n1 * new_t * new_t + 0.75
   elseif (t < 2.5 / d1) then
      local new_t = t - (2.25 / d1)
      return n1 * new_t * new_t + 0.9375
   else
      local new_t = t - (2.625 / d1)
      return n1 * new_t * new_t + 0.984375
   end
end

local function easeInBounce(t, params)
   return 1 - easeOutBounce(1 - t, params)
end

local function easeInOutBounce(t, params)
   if t < 0.5 then
      return (1 - easeOutBounce(1 - 2 * t, params)) / 2
   else
      return (1 + easeOutBounce(2 * t - 1, params)) / 2
   end
end

local function easeInSpiralDecay(t, params)
   return t * (1 + 0.8 * math.exp(-5 * t) * math.sin(12 * t))
end

local function easeOutSpiralDecay(t, params)
   return t * (1 + 0.8 * math.exp(5 * (t - 1)) * math.sin(12 * t))
end

local function easeInOutSpiralDecay(t, params)
   return t * (1 + 0.8 * math.exp(-10 * (t - 0.5) ^ 2) * math.sin(12 * t))
end

local function easeBounceGravity(t, params)
   local restitution = math.max(0.001, math.min(0.999, params.P1))
   local gravity = 9.8 * math.max(0.001, math.min(30.0, params.P2))

   local velocity = 0.0
   local position = 1.0
   local dt = 1.0 / 200.0

   local currentTime = 0
   while currentTime < t do
      velocity = velocity + gravity * dt
      position = position - velocity * dt

      if position <= 0 then
         position = 0
         velocity = -velocity * restitution
      end

      currentTime = currentTime + dt
   end

   return 1.0 - position
end

local easingFunctions = {
   easeLinear,
   easeInStep,
   easeOutStep,
   easeInSine,
   easeOutSine,
   easeInOutSine,
   easeInQuad,
   easeOutQuad,
   easeInOutQuad,
   easeInCubic,
   easeOutCubic,
   easeInOutCubic,
   easeInQuart,
   easeOutQuart,
   easeInOutQuart,
   easeInQuint,
   easeOutQuint,
   easeInOutQuint,
   easeInExpo,
   easeOutExpo,
   easeInOutExpo,
   easeInCirc,
   easeOutCirc,
   easeInOutCirc,
   easeInElastic,
   easeOutElastic,
   easeInOutElastic,
   easeInBounce,
   easeOutBounce,
   easeInOutBounce,
   easeInSpiralDecay,
   easeOutSpiralDecay,
   easeInOutSpiralDecay,
   easeBounceGravity,
}

local KeyFrameSettings = {
   New = function(autoLinkValues,
                  startValue,
                  endValue,
                  offsetTime,
                  durationTime,
                  easing,
                  timeUnit)
      return {
         AutoLinkValues = autoLinkValues,
         StartValue = startValue,
         EndValue = endValue,
         OffsetTime = offsetTime,
         DurationTime = durationTime,
         Easing = easing,
         TimeUnit = timeUnit, -- 0: Frames, 1: Seconds
      }
   end
}

local KeyFrameInfo = {
   New = function(startValue, endValue, startFrame, endFrame, easingFunction, delayParam)
      return {
         StartValue = startValue,
         EndValue = endValue,
         StartFrame = startFrame,
         EndFrame = endFrame,
         EasingFunction = easingFunction,
         DelayParam = delayParam,
      }
   end
}

local createKeyFrameInfos = function(keyFrameSettings, repeatMode)
   local keyFrameInfos = {}

   local frameRate = self.Comp:GetPrefs("Comp.FrameFormat.Rate")
   local nextStartFrame = 0
   for i = 1, #keyFrameSettings do
      local linked = keyFrameSettings[i].AutoLinkValues
      local startValue = keyFrameSettings[i].StartValue
      if linked ~= 0 then
         if i == 1 then
            if (repeatMode == 1) and (linked == 1) then
               startValue = keyFrameSettings[#keyFrameSettings].EndValue
            end
         else
            startValue = keyFrameSettings[i - 1].EndValue
         end
      end

      local endValue = keyFrameSettings[i].EndValue
      if linked ~= 0 then
         if i == #keyFrameSettings then
            if (repeatMode == 1) and (linked == 1) then
               endValue = keyFrameSettings[1].StartValue
            end
         end
      end

      local delayFrames = 0
      local durationFrames = 0
      if keyFrameSettings[i].TimeUnit == 0 then -- Frames
         delayFrames = keyFrameSettings[i].OffsetTime
         durationFrames = keyFrameSettings[i].DurationTime
      else -- Seconds
         delayFrames = math.ceil(keyFrameSettings[i].OffsetTime * frameRate)
         durationFrames = math.ceil(keyFrameSettings[i].DurationTime * frameRate)
      end

      local startFrame = (nextStartFrame + delayFrames)
      local endFrame = startFrame + durationFrames - 1

      local easingValue = keyFrameSettings[i].Easing
      local easing = easingFunctions[easingValue + 1] or easeLinear

      table.insert(keyFrameInfos,
         KeyFrameInfo.New(
            startValue,
            endValue,
            startFrame,
            endFrame,
            easing,
            delayFrames
         )
      )

      nextStartFrame = endFrame
   end

   if repeatMode == 2 then
      local refSize = #keyFrameInfos
      for i = 1, refSize do
         local refIndex = refSize - i + 1
         local refDelayIndex = refIndex

         local startValue = keyFrameInfos[refIndex].EndValue
         local endValue = keyFrameInfos[refIndex].StartValue

         local delayFrames = keyFrameInfos[refDelayIndex].DelayParam
         local durationFrames = keyFrameInfos[refIndex].EndFrame - keyFrameInfos[refIndex].StartFrame + 1
         local startFrame = (nextStartFrame + delayFrames)
         local endFrame = startFrame + durationFrames - 1

         table.insert(keyFrameInfos,
            KeyFrameInfo.New(
               startValue,
               endValue,
               startFrame,
               endFrame,
               keyFrameInfos[refIndex].EasingFunction,
               delayFrames
            )
         )

         nextStartFrame = endFrame
      end
   end

   return keyFrameInfos
end


function Process(req)
   local keyFramesNum = InKeyFramesNum:GetValue(req).Value

   local keyFrameSettings = {}
   for i = 1, keyFramesNum do
      local autoLinkValues = InKeyFrameInfos[i].AutoLinkValues:GetValue(req).Value
      local startValue = InKeyFrameInfos[i].StartValue:GetValue(req).Value
      local endValue = InKeyFrameInfos[i].EndValue:GetValue(req).Value
      local offsetTime = InKeyFrameInfos[i].OffsetFrame:GetValue(req).Value
      local durationTime = InKeyFrameInfos[i].DurationFrame:GetValue(req).Value
      local easing = InKeyFrameInfos[i].Easing:GetValue(req).Value

      local timeUnit = InTimeUnit:GetValue(req).Value

      table.insert(keyFrameSettings,
         KeyFrameSettings.New(
            autoLinkValues,
            startValue,
            endValue,
            offsetTime,
            durationTime,
            easing,
            timeUnit
         )
      )
   end

   local repeatMode = InRepeatMode:GetValue(req).Value
   local keyFrameInfos = createKeyFrameInfos(keyFrameSettings, repeatMode)
   local firstStartFrame = keyFrameInfos[1].StartFrame
   local lastEndFrame = keyFrameInfos[#keyFrameInfos].EndFrame
   local preRollTime = InPreRollTime:GetValue(req).Value
   if InTimeUnit:GetValue(req).Value == 1 then -- Seconds
      preRollTime = math.ceil(preRollTime * self.Comp:GetPrefs("Comp.FrameFormat.Rate"))
   end
   local animStartTime = self.Comp.RenderStart + preRollTime
   local animLength = lastEndFrame
   local time = req.Time - animStartTime

   -- Keep the first keyframe value if the time is before the animation start time
   if time < 0 then
      OutValue:Set(req, keyFrameInfos[1].StartValue)
      return
   end

   -- Loop the time if the repeat mode is "Normal Repeat" or "Mirror Repeat"
   if repeatMode == 1 or repeatMode == 2 then
      time = time % animLength
   end

   local result = 0
   if time < firstStartFrame then
      result = keyFrameInfos[1].StartValue
   elseif time > lastEndFrame then
      result = keyFrameInfos[#keyFrameInfos].EndValue
   else
      local found = false
      for i = 1, #keyFrameInfos do
         if time >= keyFrameInfos[i].StartFrame and time <= keyFrameInfos[i].EndFrame then
            local t = (time - keyFrameInfos[i].StartFrame) /
                (keyFrameInfos[i].EndFrame - keyFrameInfos[i].StartFrame)
            local params = {
               P1 = InKeyFrameInfos[i].EasingParamsP1:GetValue(req).Value,
               P2 = InKeyFrameInfos[i].EasingParamsP2:GetValue(req).Value
            }
            result = keyFrameInfos[i].EasingFunction(t, params) *
                (keyFrameInfos[i].EndValue - keyFrameInfos[i].StartValue) +
                keyFrameInfos[i].StartValue
            found = true
            break
         end
      end
      if not found then
         for i = 1, #keyFrameInfos do
            if time >= keyFrameInfos[i].EndFrame then
               result = keyFrameInfos[i].EndValue
            end
         end
      end
   end

   OutValue:Set(req, Number(result))
end

local changeTimeUnitUi = function(timeUnit, time)
   local keyNum = InKeyFramesNum:GetSource(time).Value
   local frameRate = self.Comp:GetPrefs("Comp.FrameFormat.Rate")

   local initialize = false
   local prevTimeUnit = self:GetData("TimeUnit: pervious value")
   if prevTimeUnit == nil then
      initialize = true
      prevTimeUnit = timeUnit
   end
   self:SetData("TimeUnit: pervious value", timeUnit)

   if prevTimeUnit == timeUnit then
      if timeUnit == 0 then -- Frames
         if not initialize then
            InPreRollTime:SetAttrs({ INP_Integer = true, INP_Steps = 1 })
         end
      else -- Seconds
         InPreRollTime:SetAttrs({ INP_Integer = false, INP_Steps = 0.01 })
      end
   end
   for i = 1, keyNum do
      if prevTimeUnit == timeUnit then
         if timeUnit == 0 then -- To frames
            if not initialize then
               InKeyFrameInfos[i].OffsetFrame:SetAttrs({ INP_Integer = true, INP_Steps = 1 })
               InKeyFrameInfos[i].DurationFrame:SetAttrs({ INP_Integer = true, INP_Steps = 1 })
            end
         elseif timeUnit == 1 then -- To seconds
            InKeyFrameInfos[i].OffsetFrame:SetAttrs({ INP_Integer = false, INP_Steps = 0.001 })
            InKeyFrameInfos[i].DurationFrame:SetAttrs({ INP_Integer = false, INP_Steps = 0.001 })
         end
      end
   end

   if not initialize then
      if prevTimeUnit == 1 and timeUnit == 0 then -- To frames
         InPreRollTime:SetSource(Number(InPreRollTime:GetSource(time).Value * frameRate), time)
         InPreRollTime:SetAttrs({ INP_Integer = true, INP_Steps = 1 })
      elseif prevTimeUnit == 0 and timeUnit == 1 then -- To seconds
         InPreRollTime:SetAttrs({ INP_Integer = false, INP_Steps = 0.01 })
         InPreRollTime:SetSource(Number(InPreRollTime:GetSource(time).Value / frameRate), time)
      end
      for i = 1, keyNum do
         local currentDelayTime = InKeyFrameInfos[i].OffsetFrame:GetSource(time).Value
         local currentDurationTime = InKeyFrameInfos[i].DurationFrame:GetSource(time).Value
         if prevTimeUnit == 1 and timeUnit == 0 then -- To frames
            InKeyFrameInfos[i].OffsetFrame:SetSource(Number(currentDelayTime * frameRate), time)
            InKeyFrameInfos[i].DurationFrame:SetSource(Number(currentDurationTime * frameRate), time)
            InKeyFrameInfos[i].OffsetFrame:SetAttrs({ INP_Integer = true, INP_Steps = 1 })
            InKeyFrameInfos[i].DurationFrame:SetAttrs({ INP_Integer = true, INP_Steps = 1 })
         elseif prevTimeUnit == 0 and timeUnit == 1 then -- To seconds
            InKeyFrameInfos[i].OffsetFrame:SetAttrs({ INP_Integer = false, INP_Steps = 0.001 })
            InKeyFrameInfos[i].DurationFrame:SetAttrs({ INP_Integer = false, INP_Steps = 0.001 })
            InKeyFrameInfos[i].OffsetFrame:SetSource(Number(currentDelayTime / frameRate), time)
            InKeyFrameInfos[i].DurationFrame:SetSource(Number(currentDurationTime / frameRate), time)
         end
      end
   end
end

local createKeyFrameInfosFromNotifyChange = function(time)
   local keyNum = InKeyFramesNum:GetSource(time).Value

   local keyFrameSettings = {}
   for i = 1, keyNum do
      local autoLinkValues = InKeyFrameInfos[i].AutoLinkValues:GetSource(time).Value
      local startValue = InKeyFrameInfos[i].StartValue:GetSource(time).Value
      local endValue = InKeyFrameInfos[i].EndValue:GetSource(time).Value
      local offsetTime = InKeyFrameInfos[i].OffsetFrame:GetSource(time).Value
      local durationTime = InKeyFrameInfos[i].DurationFrame:GetSource(time).Value
      local easing = InKeyFrameInfos[i].Easing:GetSource(time).Value
      local timeUnit = InTimeUnit:GetSource(time).Value

      table.insert(keyFrameSettings,
         KeyFrameSettings.New(
            autoLinkValues,
            startValue,
            endValue,
            offsetTime,
            durationTime,
            easing,
            timeUnit
         )
      )
   end

   return createKeyFrameInfos(keyFrameSettings, InRepeatMode:GetSource(time).Value)
end

local newCdata = function(pointer)
   if ffi.istype("struct Number*", pointer) then
      return Number(pointer.Value)
   elseif ffi.istype("struct Text*", pointer) then
      return Text(pointer.Value)
   else
      return nil
   end
end

local copySourceTable = function(source, time)
   local dest = {}
   for key, value in pairs(source) do
      dest[key] = value:GetSource(time)
   end
   return dest
end

local serialize = function(tbl)
   local buffer = {}

   local function serializeValue(v)
      local t = type(v)
      if t == "string" then
         table.insert(buffer, string.format("s(%d):%s", #v, v))
      elseif t == "number" then
         table.insert(buffer, string.format("n:%s", tostring(v)))
      elseif t == "boolean" then
         table.insert(buffer, string.format("b:%s", v and "1" or "0"))
      elseif t == "table" then
         local tbuffer = {}
         for k, val in pairs(v) do
            if type(k) == "string" then
               table.insert(tbuffer, string.format("s(%d):%s=%s", #k, k, serializeValue(val)))
            elseif type(k) == "number" then
               table.insert(tbuffer, string.format("n:%s=%s", tostring(k), serializeValue(val)))
            end
         end
         return string.format("t(%d):{%s}", #tbuffer, table.concat(tbuffer, ";"))
      end
      return buffer[#buffer]
   end

   serializeValue(tbl)
   local result = buffer[1]
   local checksum = #result
   return "c:" .. checksum .. ":" .. result
end

local deserialize = function(str)
   if not str:match("^c:%d+:") then
      return nil, "Invalid format: checksum not found"
   end

   local _, checksumEnd = str:find("^c:%d+:")
   local checksum = tonumber(str:match("^c:(%d+):"))
   local dataStr = str:sub(checksumEnd + 1)

   if #dataStr ~= checksum then
      return nil, "Checksum validation failed"
   end

   local pos = 1
   local function getValue()
      if pos > #dataStr then
         return nil, "Unexpected end of data"
      end

      local typeChar = dataStr:sub(pos, pos)
      pos = pos + 1

      if typeChar == "s" then
         pos = pos + 1
         local endPos = dataStr:find(")", pos)
         if not endPos then return nil, "Malformed string: missing closing parenthesis" end

         local len = tonumber(dataStr:sub(pos, endPos - 1))
         if not len then return nil, "Malformed string: invalid length" end

         pos = endPos + 2
         if pos + len - 1 > #dataStr then return nil, "String exceeds data length" end

         local val = dataStr:sub(pos, pos + len - 1)
         pos = pos + len
         return val
      elseif typeChar == "n" then
         pos = pos + 1
         local endPos = dataStr:find("[;=}]", pos) or (#dataStr + 1)
         local numStr = dataStr:sub(pos, endPos - 1)
         local val = tonumber(numStr)
         if not val then return nil, "Invalid number: " .. numStr end

         pos = endPos
         return val
      elseif typeChar == "b" then
         pos = pos + 1
         if pos > #dataStr then return nil, "Unexpected end of data" end

         local valChar = dataStr:sub(pos, pos)
         if valChar ~= "0" and valChar ~= "1" then
            return nil, "Invalid boolean: " .. valChar
         end

         local val = (valChar == "1")
         pos = pos + 1
         return val
      elseif typeChar == "t" then
         pos = pos + 1
         local endPos = dataStr:find(")", pos)
         if not endPos then return nil, "Malformed table: missing closing parenthesis" end

         local count = tonumber(dataStr:sub(pos, endPos - 1))
         if not count then return nil, "Malformed table: invalid count" end

         pos = endPos + 2
         if pos > #dataStr then return nil, "Unexpected end of data" end

         if dataStr:sub(pos, pos) == "{" then
            pos = pos + 1
            local tbl = {}

            for i = 1, count do
               if pos > #dataStr then return nil, "Unexpected end of data in table" end

               local keyTypeChar = dataStr:sub(pos, pos)
               pos = pos + 1

               local key
               if keyTypeChar == "s" then
                  pos = pos + 1
                  local keyEndPos = dataStr:find(")", pos)
                  if not keyEndPos then return nil, "Malformed key: missing closing parenthesis" end

                  local keyLen = tonumber(dataStr:sub(pos, keyEndPos - 1))
                  if not keyLen then return nil, "Malformed key: invalid length" end

                  pos = keyEndPos + 2
                  if pos + keyLen - 1 > #dataStr then return nil, "Key exceeds data length" end

                  key = dataStr:sub(pos, pos + keyLen - 1)
                  pos = pos + keyLen
               elseif keyTypeChar == "n" then
                  pos = pos + 1
                  local keyEndPos = dataStr:find("=", pos)
                  if not keyEndPos then return nil, "Malformed key: missing '='" end

                  local keyStr = dataStr:sub(pos, keyEndPos - 1)
                  key = tonumber(keyStr)
                  if not key then return nil, "Invalid numeric key: " .. keyStr end

                  pos = keyEndPos
               else
                  return nil, "Invalid key type: " .. keyTypeChar
               end

               pos = pos + 1
               local val, err = getValue()
               if err then return nil, err end

               tbl[key] = val

               if i < count then
                  if pos > #dataStr then return nil, "Unexpected end of data" end
                  if dataStr:sub(pos, pos) ~= ";" then return nil, "Missing separator ';'" end
                  pos = pos + 1
               end
            end

            if pos > #dataStr then return nil, "Unexpected end of data" end
            if dataStr:sub(pos, pos) ~= "}" then return nil, "Missing closing '}'" end
            pos = pos + 1
            return tbl
         else
            return nil, "Malformed table: missing opening '{'"
         end
      else
         return nil, "Unknown type: " .. typeChar
      end
   end

   local result, err = getValue()
   if err then
      return nil, err
   end

   if pos <= #dataStr then
      return nil, "Extra data after parsed value"
   end

   return result
end

local serializeInputs = function(time)
   local keyNum = InKeyFramesNum:GetSource(time).Value
   local keyFrameSettings = {}
   for i = 1, keyNum do
      local autoLinkValues = InKeyFrameInfos[i].AutoLinkValues:GetSource(time).Value
      local startValue = InKeyFrameInfos[i].StartValue:GetSource(time).Value
      local endValue = InKeyFrameInfos[i].EndValue:GetSource(time).Value
      local offsetTime = InKeyFrameInfos[i].OffsetFrame:GetSource(time).Value
      local durationTime = InKeyFrameInfos[i].DurationFrame:GetSource(time).Value
      local easing = InKeyFrameInfos[i].Easing:GetSource(time).Value
      local timeUnit = InTimeUnit:GetSource(time).Value

      table.insert(keyFrameSettings,
         KeyFrameSettings.New(
            autoLinkValues,
            startValue,
            endValue,
            offsetTime,
            durationTime,
            easing,
            timeUnit
         )
      )
   end

   local repeatMode = InRepeatMode:GetSource(time).Value
   local keyFrameInfos = createKeyFrameInfos(keyFrameSettings, repeatMode)

   local inputs = {
      KeyFramesNum = keyNum,
      KeyFrameInfos = keyFrameInfos,
      RepeatMode = repeatMode,
      TimeUnit = InTimeUnit:GetSource(time).Value,
      PreRollTime = InPreRollTime:GetSource(time).Value,
   }

   dump(inputs)

   return serialize(inputs)
end

function NotifyChanged(inp, param, time)
   if inp == InKeyFramesNum then
      for i = 1, param.Value do
         for key, input in pairs(InKeyFrameInfos[i]) do
            input:SetAttrs({ IC_Visible = true })
         end
         if i == 1 then
            InKeyFrameInfos[i].AutoLinkValues:SetAttrs({ IC_Visible = false })
         end
         -- update
         local currentAutoLink = InKeyFrameInfos[i].AutoLinkValues:GetSource(time)
         InKeyFrameInfos[i].AutoLinkValues:SetSource(currentAutoLink, time)
         local easing = InKeyFrameInfos[i].Easing:GetSource(time)
         InKeyFrameInfos[i].Easing:SetSource(easing, time)
      end
      for i = param.Value + 1, KEY_FRAMES_NUM do
         for key, input in pairs(InKeyFrameInfos[i]) do
            input:SetAttrs({ IC_Visible = false })
         end
      end
   elseif inp == InDebugButton and param.Value == 1 then
      local keyNum = InKeyFramesNum:GetSource(time).Value

      local keyFrameSettings = {}
      for i = 1, keyNum do
         local autoLinkValues = InKeyFrameInfos[i].AutoLinkValues:GetSource(time).Value
         local startValue = InKeyFrameInfos[i].StartValue:GetSource(time).Value
         local endValue = InKeyFrameInfos[i].EndValue:GetSource(time).Value
         local offsetTime = InKeyFrameInfos[i].OffsetFrame:GetSource(time).Value
         local durationTime = InKeyFrameInfos[i].DurationFrame:GetSource(time).Value
         local easing = InKeyFrameInfos[i].Easing:GetSource(time).Value
         local timeUnit = InTimeUnit:GetSource(time).Value

         table.insert(keyFrameSettings,
            KeyFrameSettings.New(
               autoLinkValues,
               startValue,
               endValue,
               offsetTime,
               durationTime,
               easing,
               timeUnit
            )
         )
      end

      local keyFrameInfos = createKeyFrameInfos(keyFrameSettings, InRepeatMode:GetSource(time).Value)

      local preRollTime = InPreRollTime:GetSource(time).Value
      local keyFrameInfoText = ""
      for i = 1, #keyFrameInfos do
         local correctedStartFrame = keyFrameInfos[i].StartFrame + preRollTime + self.Comp.RenderStart
         local correctedEndFrame = keyFrameInfos[i].EndFrame + preRollTime + self.Comp.RenderStart
         keyFrameInfoText = keyFrameInfoText ..
             string.format("key%d (%5d : %5d):  %8.5f -> %8.5f\n",
                i,
                correctedStartFrame,
                correctedEndFrame,
                keyFrameInfos[i].StartValue,
                keyFrameInfos[i].EndValue)
      end
      local animLength = (keyFrameInfos[#keyFrameInfos].EndFrame + 1)
      keyFrameInfoText = string.format("Total: %d frames\n", animLength) .. keyFrameInfoText
      InDebugText:SetSource(Text(keyFrameInfoText), time)
   elseif inp == InTimeUnit then
      changeTimeUnitUi(param.Value, time)
   elseif inp == InRepeatMode then
      local keyNum = InKeyFramesNum:GetSource(time).Value
      local repeatMode = param.Value
      for i = 1, keyNum do
         local autoLinkValues = InKeyFrameInfos[i].AutoLinkValues:GetSource(time).Value
         if autoLinkValues == 0 then -- No checked
            InKeyFrameInfos[i].StartValue:SetAttrs({ IC_Visible = true })
            InKeyFrameInfos[i].EndValue:SetAttrs({ IC_Visible = true })
         elseif autoLinkValues == -1 then -- Half checked
            InKeyFrameInfos[i].StartValue:SetAttrs({ IC_Visible = false })
            InKeyFrameInfos[i].EndValue:SetAttrs({ IC_Visible = true })
         elseif autoLinkValues == 1 then -- Full checked
            InKeyFrameInfos[i].StartValue:SetAttrs({ IC_Visible = false })
            if i == keyNum and (repeatMode == 1) then
               InKeyFrameInfos[i].EndValue:SetAttrs({ IC_Visible = false })
            else
               InKeyFrameInfos[i].EndValue:SetAttrs({ IC_Visible = true })
            end
         end
      end
      -- elseif inp == InSaveRestore then
      --    if param.Value == 1 then -- Save
      --       dump(serializeInputs(time))
      --       --InSaveRestore:SetSource(, time)
      --    end
   else
      for i = 1, #InKeyFrameInfos do
         if inp == InKeyFrameInfos[i].KeyOrder then
            local targetIndex = 0
            local valid = false;
            if param.Value == 1 then -- Up button
               if 1 < i then
                  targetIndex = i - 1
                  valid = true
               end
            elseif param.Value == 2 then -- Down button
               if i < #InKeyFrameInfos then
                  targetIndex = i + 1
                  valid = true
               end
            end
            if valid then
               local currentInputs = copySourceTable(InKeyFrameInfos[i], time)
               local targetInputs = copySourceTable(InKeyFrameInfos[targetIndex], time)
               for key, input in pairs(InKeyFrameInfos[i]) do
                  if key ~= "KeyOrder" and key ~= "AutoLinkValues" then
                     input:SetSource(newCdata(targetInputs[key]), time)
                  end
               end
               for key, input in pairs(InKeyFrameInfos[targetIndex]) do
                  if key ~= "KeyOrder" then
                     input:SetSource(newCdata(currentInputs[key]), time)
                  end
               end
            end
            break
         elseif inp == InKeyFrameInfos[i].AutoLinkValues then
            local repeatMode = InRepeatMode:GetSource(time).Value
            local keyNum = InKeyFramesNum:GetSource(time).Value
            if i <= keyNum then
               if param.Value == 0 then -- No checked
                  InKeyFrameInfos[i].StartValue:SetAttrs({ IC_Visible = true })
                  InKeyFrameInfos[i].EndValue:SetAttrs({ IC_Visible = true })
               elseif param.Value == -1 then -- Half checked
                  InKeyFrameInfos[i].StartValue:SetAttrs({ IC_Visible = false })
                  InKeyFrameInfos[i].EndValue:SetAttrs({ IC_Visible = true })
               elseif param.Value == 1 then -- Full checked
                  InKeyFrameInfos[i].StartValue:SetAttrs({ IC_Visible = false })
                  if i == keyNum and (repeatMode == 1) then
                     InKeyFrameInfos[i].EndValue:SetAttrs({ IC_Visible = false })
                  else
                     InKeyFrameInfos[i].EndValue:SetAttrs({ IC_Visible = true })
                  end
               end
            end
            break
         elseif inp == InKeyFrameInfos[i].JumpTo and param.Value ~= 0 then
            local timeUnit = InTimeUnit:GetSource(time).Value
            local preRollTime = InPreRollTime:GetSource(time).Value
            if timeUnit == 1 then -- Seconds
               preRollTime = math.ceil(preRollTime * self.Comp:GetPrefs("Comp.FrameFormat.Rate"))
            end
            local keyFrameInfos = createKeyFrameInfosFromNotifyChange(time)
            local offset = preRollTime + self.Comp.RenderStart
            local jumpFrame = 0
            if param.Value == 1 then
               jumpFrame = keyFrameInfos[i].StartFrame + offset
               print("Start Frame: " .. keyFrameInfos[i].StartFrame)
            elseif param.Value == 2 then
               jumpFrame = keyFrameInfos[i].EndFrame + offset
               print("End Frame: " .. keyFrameInfos[i].EndFrame)
            end
            local exe_str = string.format("comp:_SetCurrentTime(%d)", jumpFrame)
            self.Comp:Execute(exe_str)
            break
         elseif inp == InKeyFrameInfos[i].Easing then
            if param.Value == 33 then -- BounceGravity
               InKeyFrameInfos[i].EasingParamsP1:SetAttrs({ IC_Visible = true, LINKS_Name = "Restitution(0.001-0.999)" })
               InKeyFrameInfos[i].EasingParamsP2:SetAttrs({ IC_Visible = true, LINKS_Name = "Gravity(0.001-30.0)" })
            else
               InKeyFrameInfos[i].EasingParamsP1:SetAttrs({ IC_Visible = false })
               InKeyFrameInfos[i].EasingParamsP2:SetAttrs({ IC_Visible = false })
            end
            break
         end
      end
   end
end
