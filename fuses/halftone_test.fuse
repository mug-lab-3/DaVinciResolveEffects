--------------------------------
-- Registry declaration

FuRegisterClass("GPUSampleFuse", CT_SourceTool, {
	REGS_Category = "Fuses\\Examples",
	REGS_OpIconString = "GFu",
	REGS_OpDescription = "GPU Sample Fuse",

	REG_NoObjMatCtrls = true,
	REG_NoMotionBlurCtrls = true,

	REG_Source_GlobalCtrls = true,
	REG_Source_SizeCtrls = true,
	REG_Source_AspectCtrls = true,
	REG_Source_DepthCtrls = true,
})


--------------------------------
-- source of kernel

HalftoneParams = [[
  int srcSize[2];        // ソース画像のサイズ
  float dotSize;         // ドットのサイズ調整（大きいほど細かいパターン）
  float contrast;        // コントラスト調整（1.0がデフォルト）
  int useOriginalColor;  // 元の色を使用するかどうか（0=白黒、1=カラー）
  int useOriginalBackground; // 背景も元の色にするかどうか（0=白、1=元の色）
  int useCMYKMode;       // CMYKモードを使用するかどうか（0=標準ハーフトーン、1=CMYKスタイル）
  float dotAngle;        // ドットの角度（CMYK モードでのみ使用）
]]

HalftoneKernel = [[
__KERNEL__ void HalftoneKernel(__CONSTANTREF__ HalftoneParams *params, __TEXTURE2D__ src, __TEXTURE2D_WRITE__ dst)
{
    DEFINE_KERNEL_ITERATORS_XY(x, y);

    if (x < params->srcSize[0] && y < params->srcSize[1])
    {
        // 基本ドットサイズ - 単純なグリッドサイズとして使用
        float cellSize = _fmaxf(1.0f, params->dotSize);

        // 現在のピクセルの正規化座標（一度だけ計算）
        float xNorm = (float)x / (float)params->srcSize[0];
        float yNorm = (float)y / (float)params->srcSize[1];
        float2 pixelUV = to_float2(xNorm, yNorm);

        // 現在のピクセルの色を取得
        float4 pixelColor = _tex2DVecN(src, pixelUV.x, pixelUV.y, 15);
        float4 result;

        if (params->useCMYKMode == 1) {
            // CMYK風のハーフトーン処理
            float4 cmykResult = to_float4(1.0f, 1.0f, 1.0f, 1.0f); // 初期値は白

            // 事前計算
            float xf = (float)x;
            float yf = (float)y;

            // 各チャンネル（CMY）ごとに処理
            float angles[4] = {15.0f, 75.0f, 0.0f, 45.0f}; // C、M、Y、Kの角度（標準的な印刷角度）
            float3 colors[3] = {
                to_float3(0.0f, 1.0f, 1.0f), // シアン
                to_float3(1.0f, 0.0f, 1.0f), // マゼンタ
                to_float3(1.0f, 1.0f, 0.0f)  // イエロー
            };

            // 効率化: サイズ係数とオフセットを事前に計算
            float cellSizes[4] = {
                cellSize,             // シアン
                cellSize * 1.05f,     // マゼンタ
                cellSize * 0.95f,     // イエロー
                cellSize              // ブラック
            };

            float2 offsets[4] = {
                to_float2(0.0f, 0.0f),
                to_float2(cellSizes[1] * 0.25f, 0.0f),
                to_float2(0.0f, cellSizes[2] * 0.25f),
                to_float2(cellSizes[3] * 0.125f, cellSizes[3] * 0.125f)
            };

            // CMYチャンネルループ
            for (int channel = 0; channel < 3; channel++) {
                float angle = angles[channel] * 0.01745329f; // ラジアンに変換 (3.14159/180)
                float cosAngle = _cosf(angle);
                float sinAngle = _sinf(angle);

                // 回転とオフセットを一度に適用
                float rotX = xf * cosAngle - yf * sinAngle + offsets[channel].x;
                float rotY = xf * sinAngle + yf * cosAngle + offsets[channel].y;

                // セルID計算を簡略化
                float invCellSize = 1.0f / cellSizes[channel];
                float cellIdXf = floor(rotX * invCellSize);
                float cellIdYf = floor(rotY * invCellSize);

                // セル内相対位置 - 高速化
                float cellPosX = rotX * invCellSize - cellIdXf;
                float cellPosY = rotY * invCellSize - cellIdYf;

                // セル中心座標計算を簡略化
                float centerX = (cellIdXf + 0.5f) * cellSizes[channel];
                float centerY = (cellIdYf + 0.5f) * cellSizes[channel];

                // 逆回転 - 効率化
                float invX = centerX * cosAngle + centerY * sinAngle - offsets[channel].x;
                float invY = -centerX * sinAngle + centerY * cosAngle - offsets[channel].y;

                // 正規化座標
                float centerUVx = invX * (1.0f / (float)params->srcSize[0]);
                float centerUVy = invY * (1.0f / (float)params->srcSize[1]);

                // テクスチャ範囲チェックを簡略化
                if (centerUVx >= 0.0f && centerUVx <= 1.0f && centerUVy >= 0.0f && centerUVy <= 1.0f) {
                    // セル中心の色
                    float4 cellColor = _tex2DVecN(src, centerUVx, centerUVy, 15);

                    // チャンネル値計算
                    float channelValue;
                    if (channel == 0) channelValue = 1.0f - cellColor.x;
                    else if (channel == 1) channelValue = 1.0f - cellColor.y;
                    else channelValue = 1.0f - cellColor.z;

                    // コントラスト調整
                    channelValue = _clampf((channelValue - 0.5f) * params->contrast + 0.5f, 0.0f, 1.0f);

                    // セル中心からの距離を計算
                    float dx = cellPosX - 0.5f;
                    float dy = cellPosY - 0.5f;
                    float dist = _sqrtf(dx * dx + dy * dy);

                    // 半径計算 - 条件分岐を減らして効率化
                    float radius = 0.0f;
                    if (channelValue > 0.05f) {  // ドットが必要な場合のみ計算
                        radius = 0.45f * channelValue;
                        if (channelValue > 0.8f) {
                            radius += (channelValue - 0.8f) * 0.5f;
                            if (radius > 0.65f) radius = 0.65f;
                        }
                    }

                    // ドット内にあるかチェック
                    if (dist < radius) {
                        if (params->useOriginalColor == 1) {
                            // カラーモードではオリジナル色を保持
                            float3 channelOrigColor;
                            if (channel == 0) channelOrigColor = to_float3(0.0f, cellColor.y, cellColor.z);
                            else if (channel == 1) channelOrigColor = to_float3(cellColor.x, 0.0f, cellColor.z);
                            else channelOrigColor = to_float3(cellColor.x, cellColor.y, 0.0f);

                            cmykResult.x = _fminf(cmykResult.x, channelOrigColor.x);
                            cmykResult.y = _fminf(cmykResult.y, channelOrigColor.y);
                            cmykResult.z = _fminf(cmykResult.z, channelOrigColor.z);
                        } else {
                            // CMY色モード
                            cmykResult.x = _fminf(cmykResult.x, colors[channel].x);
                            cmykResult.y = _fminf(cmykResult.y, colors[channel].y);
                            cmykResult.z = _fminf(cmykResult.z, colors[channel].z);
                        }
                    }
                }
            }

            // Kチャンネル（黒）を効率的に処理
            {
                int channel = 3;
                float angle = angles[channel] * 0.01745329f;
                float cosAngle = _cosf(angle);
                float sinAngle = _sinf(angle);

                float rotX = xf * cosAngle - yf * sinAngle + offsets[channel].x;
                float rotY = xf * sinAngle + yf * cosAngle + offsets[channel].y;

                float invCellSize = 1.0f / cellSizes[channel];
                float cellIdXf = floor(rotX * invCellSize);
                float cellIdYf = floor(rotY * invCellSize);

                float cellPosX = rotX * invCellSize - cellIdXf;
                float cellPosY = rotY * invCellSize - cellIdYf;

                float centerX = (cellIdXf + 0.5f) * cellSizes[channel];
                float centerY = (cellIdYf + 0.5f) * cellSizes[channel];

                float invX = centerX * cosAngle + centerY * sinAngle - offsets[channel].x;
                float invY = -centerX * sinAngle + centerY * cosAngle - offsets[channel].y;

                float centerUVx = invX * (1.0f / (float)params->srcSize[0]);
                float centerUVy = invY * (1.0f / (float)params->srcSize[1]);

                if (centerUVx >= 0.0f && centerUVx <= 1.0f && centerUVy >= 0.0f && centerUVy <= 1.0f) {
                    float4 cellColor = _tex2DVecN(src, centerUVx, centerUVy, 15);

                    // Kチャンネル値を効率的に計算
                    float r = cellColor.x;
                    float g = cellColor.y;
                    float b = cellColor.z;
                    float kValue = 1.0f - (r > g ? (r > b ? r : b) : (g > b ? g : b));

                    kValue = _clampf((kValue - 0.5f) * params->contrast + 0.5f, 0.0f, 1.0f);

                    float dx = cellPosX - 0.5f;
                    float dy = cellPosY - 0.5f;
                    float dist = _sqrtf(dx * dx + dy * dy);

                    float radius = 0.0f;
                    if (kValue > 0.05f) {
                        radius = 0.45f * kValue;
                        if (kValue > 0.8f) {
                            radius += (kValue - 0.8f) * 0.5f;
                            if (radius > 0.65f) radius = 0.65f;
                        }
                    }

                    if (dist < radius) {
                        cmykResult.x *= 0.3f;
                        cmykResult.y *= 0.3f;
                        cmykResult.z *= 0.3f;
                    }
                }
            }

            result = to_float4(cmykResult.x, cmykResult.y, cmykResult.z, 1.0f);
        } else {
            // 標準ハーフトーン処理 - 大幅に効率化

            // スケール計算を簡略化
            float invCellSize = 1.0f / cellSize;
            float scaledX = xNorm * params->srcSize[0] * invCellSize;
            float scaledY = yNorm * params->srcSize[1] * invCellSize;

            // セル計算
            float cellIdX = floor(scaledX);
            float cellIdY = floor(scaledY);
            float cellPosX = scaledX - cellIdX;
            float cellPosY = scaledY - cellIdY;

            // セル中心の色を取得
            float2 cellCenterUV = to_float2(
                (cellIdX + 0.5f) * cellSize / (float)params->srcSize[0],
                (cellIdY + 0.5f) * cellSize / (float)params->srcSize[1]
            );

            float4 cellColor = _tex2DVecN(src, cellCenterUV.x, cellCenterUV.y, 15);

            // 輝度計算を効率化
            float cellLuma = cellColor.x * 0.3f + cellColor.y * 0.59f + cellColor.z * 0.11f;
            cellLuma = _clampf((cellLuma - 0.5f) * params->contrast + 0.5f, 0.0f, 1.0f);

            // 距離計算を効率化
            float dx = cellPosX - 0.5f;
            float dy = cellPosY - 0.5f;
            float dist = _sqrtf(dx * dx + dy * dy);

            // 半径計算を効率化
            float radius;
            if (cellLuma < 0.05f) {
                radius = 0.67f;
            } else {
                radius = 0.45f * (1.0f - cellLuma);
                if (cellLuma < 0.2f) {
                    radius += (0.2f - cellLuma) * 0.5f;
                    if (radius > 0.65f) radius = 0.65f;
                }
            }

            // 最終的なピクセル色の決定を効率化
            if (dist < radius) {
                result = params->useOriginalColor == 1 ? cellColor : to_float4(0.0f, 0.0f, 0.0f, 1.0f);
            } else {
                result = params->useOriginalBackground == 1 ? pixelColor : to_float4(1.0f, 1.0f, 1.0f, 1.0f);
            }
        }

        _tex2DVec4Write(dst, x, y, result);
    }
}
]]

function Create()
	InDotSize = self:AddInput("Dot Size", "DotSize", {
		LINKID_DataType = "Number",
		INPID_InputControl = "SliderControl",
		INP_Default = 15.0,
		INP_MinAllowed = 1.0,
		INP_MaxAllowed = 10000.0,
	})

	InContrast = self:AddInput("Contrast", "Contrast", {
		LINKID_DataType = "Number",
		INPID_InputControl = "SliderControl",
		INP_Default = 1.0,
		INP_MinAllowed = 0.1,
		INP_MaxAllowed = 5.0,
	})

	InUseOriginalColor = self:AddInput("Use Original Color", "UseOriginalColor", {
		LINKID_DataType = "Number",
		INPID_InputControl = "CheckboxControl",
		INP_Default = 0.0, -- デフォルトはオフ
	})

	InUseOriginalBackground = self:AddInput("Color Background", "UseOriginalBackground", {
		LINKID_DataType = "Number",
		INPID_InputControl = "CheckboxControl",
		INP_Default = 0.0, -- デフォルトはオフ
	})

	InUseCMYKMode = self:AddInput("CMYK Mode", "UseCMYKMode", {
		LINKID_DataType = "Number",
		INPID_InputControl = "CheckboxControl",
		INP_Default = 0.0, -- デフォルトはオフ
	})

	InImage = self:AddInput("Input Image", "Image", {
		LINKID_DataType = "Image",
		LINK_Main = 1, -- これはメインの入力として設定
	})

	-- OutImage is automatically created for us, as we're a CT_SourceTool
end

function Process(req)
	local dotSize = InDotSize:GetValue(req).Value
	local contrast = InContrast:GetValue(req).Value
	local useOriginalColor = InUseOriginalColor:GetValue(req).Value
	local useOriginalBackground = InUseOriginalBackground:GetValue(req).Value
	local useCMYKMode = InUseCMYKMode:GetValue(req).Value

	local img = InImage:GetValue(req)
	local out

	if img then
		out = Image({ IMG_Like = img })

		local node = DVIPComputeNode(req, "HalftoneKernel", HalftoneKernel, "HalftoneParams", HalftoneParams)

		if node then
			-- create image
			local params = node:GetParamBlock(HalftoneParams)

			params.contrast = contrast
			params.dotSize = dotSize
			params.srcSize[0] = out.DataWindow:Width()
			params.srcSize[1] = out.DataWindow:Height()
			params.useOriginalColor = useOriginalColor > 0.5 and 1 or 0 -- チェックボックスの値を整数に変換
			params.useOriginalBackground = useOriginalBackground > 0.5 and 1 or 0
			params.useCMYKMode = useCMYKMode > 0.5 and 1 or 0
			params.dotAngle = 0.0 -- 現在は使用されていない

			node:SetParamBlock(params)

			node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR, TEX_ADDRESS_MODE_CLAMP, TEX_NORMALIZED_COORDS_TRUE)
			node:AddInput("src", img)
			node:AddOutput("dst", out)

			success = node:RunSession(req)
		else
			out = nil
		end
	end

	OutImage:Set(req, out)
	--OutImage:Set(req, img)
end
