--[[--
Auto Outline Color Text
--]] --

--******************************************************************************************************
FuRegisterClass("AutoOutlineColorText", CT_Tool, {
    REGS_Name             = "Auto Outline Color Text",
    REGS_Category         = "Fuses\\Mug",
    REGS_OpIconString     = "AOCT",
    REGS_OpDescription    = "Auto Outline Color Text",
    REGS_HelpTopic        = "https://x.com/MugLab3",     --This can be a URL
    REGS_URL              = "https://www.youtube.com/@MugLabVideoEditing",
    REGS_IconID           = "Icons.Tools.Icons.Example", -- This can be Inline as an array of Values
    REG_OpNoMask          = false,
    REG_NoBlendCtrls      = false,
    REG_NoObjMatCtrls     = true,
    REG_NoMotionBlurCtrls = true,
    REG_Fuse_NoEdit       = false,
    REG_Fuse_NoReload     = false,
    REG_SupportsDoD       = true,
    REG_NoPreCalcProcess  = false,
    REG_Version           = 1,
})

function Create()
    local groupId = 0;

    self:BeginControlNest("Text", "TextLabel", true);

    InText = self:AddInput("Text", "Text", {
        LINKID_DataType     = "Text",
        INPID_InputControl  = "TextEditControl",
        TEC_Lines           = 5,
        INP_DoNotifyChanged = false,
    })

    -- Font group
    groupId = groupId + 1;

    InFont = self:AddInput("Font", "Font", {
        LINKID_DataType     = "Text",
        INPID_InputControl  = "FontFileControl",
        IC_ControlGroup     = groupId,
        IC_ControlID        = 0,
        INP_Level           = 1,
        INP_DoNotifyChanged = true,
    })

    InFontStyle = self:AddInput("Font Style", "FontStyle", {
        LINKID_DataType     = "Text",
        INPID_InputControl  = "FontFileControl",
        IC_ControlGroup     = groupId,
        IC_ControlID        = 1,
        INP_Level           = 1,
        INP_DoNotifyChanged = true,
    })

    InSize = self:AddInput("Size", "Size", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "SliderControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 0.5,
        INP_Default        = 0.08,
    })

    InTracking = self:AddInput("Tracking", "Tracking", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "SliderControl",
        INP_MinScale       = -1.0,
        INP_MaxScale       = 2.0,
        INP_MinAllowed     = -4.0,
        INP_MaxAllowed     = 5.0,
        INP_Default        = 1.0,
    })

    InLineSpacing = self:AddInput("Line Spacing", "LineSpacing", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "SliderControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 2.0,
        INP_MinAllowed     = 0.0,
        INP_MaxAllowed     = 10.0,
        INP_Default        = 1.0,
    })

    self:EndControlNest()


    self:BeginControlNest("Position", "PositionLabel", true);

    InOffset = self:AddInput("Offset", "Offset", {
        LINKID_DataType      = "Point",
        INPID_InputControl   = "OffsetControl",
        INPID_PreviewControl = "CrosshairControl",
    })

    InJustify = self:AddInput("Justification", "Justification", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "MultiButtonControl",
        INP_Default        = 1,
        { MBTNC_AddButton = "Left",   MBTNCD_ButtonWidth = 1 / 3, },
        { MBTNC_AddButton = "Center", MBTNCD_ButtonWidth = 1 / 3, },
        { MBTNC_AddButton = "Right",  MBTNCD_ButtonWidth = 1 / 3, },
        INP_Integer = true,
    })

    InAlign = self:AddInput("Alignment", "Alignment", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "MultiButtonControl",
        INP_Default        = 1,
        { MBTNC_AddButton = "Top",    MBTNCD_ButtonWidth = 1 / 3, },
        { MBTNC_AddButton = "Center", MBTNCD_ButtonWidth = 1 / 3, },
        { MBTNC_AddButton = "Bottom", MBTNCD_ButtonWidth = 1 / 3, },
        INP_Integer = true,
    })

    self:EndControlNest()


    self:BeginControlNest("Main Color", "MainColorLabel", true);

    InColorTarget = self:AddInput("Target", "ColorTarget", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "MultiButtonControl",
        INP_Default        = 0,
        { MBTNC_AddButton = "Inner", MBTNCD_ButtonWidth = 1 / 2, },
        { MBTNC_AddButton = "Outer", MBTNCD_ButtonWidth = 1 / 2, },
        INP_Integer = true,
    })

    InR = self:AddInput("Red", "Red", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = 1,
        IC_ControlID       = 0, -- Red ID
    })

    InG = self:AddInput("Green", "Green", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        IC_ControlGroup    = 1,
        IC_ControlID       = 1, -- Green ID
    })

    InB = self:AddInput("Blue", "Blue", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        IC_ControlGroup    = 1,
        IC_ControlID       = 2, -- Blue ID
    })

    InA = self:AddInput("Alpha", "Alpha", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        IC_ControlGroup    = 1,
        IC_ControlID       = 3, -- Alpha ID
    })

    self:EndControlNest()

    self:BeginControlNest("Outline", "OutlineLabel", true);

    InOutlineColorType = self:AddInput("Type", "OutlineColorType", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "MultiButtonControl",
        INP_Default        = 0,
        { MBTNC_AddButton = "Mono",           MBTNCD_ButtonWidth = 1 / 2, },
        { MBTNC_AddButton = "Complementary ", MBTNCD_ButtonWidth = 1 / 2, },
        INP_Integer = true,
    })

    InOutlineNum = self:AddInput("Num", "OutlineNum", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "SliderControl",
        INP_MinScale       = 0,
        INP_MaxScale       = 2,
        INP_Default        = 1,
        INP_MinAllowed     = 0,
        INP_MaxAllowed     = 2,
        INP_Integer        = true,
    })

    InOutlineThickness = self:AddInput("Tickness", "OutlineTickness", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "SliderControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 0.1,
        INP_Default        = 0.08,
    })

    self:EndControlNest()


    self:BeginControlNest("Emoji", "EmojiLabel", true);

    InEmojiFontEnabled = self:AddInput("Use alternative fonts for emojis", "EnableEmojiFontLabel", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Integer = true,
        INP_Default = 1.0,
        ICD_Width = 1,
        INP_DoNotifyChanged = true,
    })

    groupId = groupId + 1;
    InEmojiFont = self:AddInput("Font", "EmojiFont", {
        LINKID_DataType     = "Text",
        INPID_InputControl  = "FontFileControl",
        IC_ControlGroup     = groupId,
        IC_ControlID        = 0,
        INP_Level           = 1,
        INP_DoNotifyChanged = true,
        IC_Visible          = true,
    })

    InEmojiFontStyle = self:AddInput("Font Style", "EmojiFontStyle", {
        LINKID_DataType     = "Text",
        INPID_InputControl  = "FontFileControl",
        IC_ControlGroup     = groupId,
        IC_ControlID        = 1,
        INP_Level           = 1,
        INP_DoNotifyChanged = true,
        IC_Visible          = true,
    })

    InEmojiSize = self:AddInput("Size", "EmojiSize", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "SliderControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 0.5,
        INP_Default        = 0.08,
        IC_Visible         = true,
    })

    InEmojiTracking = self:AddInput("Tracking", "EmojiTracking", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "SliderControl",
        INP_MinScale       = -1.0,
        INP_MaxScale       = 2.0,
        INP_MinAllowed     = -4.0,
        INP_MaxAllowed     = 5.0,
        INP_Default        = 1.0,
        IC_Visible         = true,
    })

    self:EndControlNest()


    InImage = self:AddInput("Input", "Input", {
        LINKID_DataType = "Image",
        LINK_Main       = 1,
    })

    OutImage = self:AddOutput("Output", "Output", {
        LINKID_DataType = "Image",
        LINK_Main       = 1,
    })
end

------------------------------------------------------------
local bit = require("bit")

local UnicodeText = {
    New = function()
        return {
            Text = "",
            Unicode = {},

            ToUniCode = function(this)
                local utf16bytes = {}
                local utf32bytes = {}
                local line = 1
                local source = this.Text

                if source and (0 < #source) then
                    utf16bytes[line] = {}
                    local i = 1
                    while i <= #source do
                        local c = source:byte(i)
                        if c == 0x0A then
                            line = line + 1
                            utf16bytes[line] = {}
                            i = i + 1
                        elseif c < 0x80 then
                            table.insert(utf16bytes[line], 0)
                            table.insert(utf16bytes[line], c)
                            i = i + 1
                        elseif c < 0xE0 then
                            local c2 = source:byte(i + 1)
                            local u = bit.bor(bit.lshift(bit.band(c, 0x1F), 6), bit.band(c2, 0x3F))
                            table.insert(utf16bytes[line], bit.rshift(u, 8))
                            table.insert(utf16bytes[line], bit.band(u, 0xFF))
                            i = i + 2
                        elseif c < 0xF0 then
                            local c2 = source:byte(i + 1)
                            local c3 = source:byte(i + 2)
                            local u = bit.bor(bit.lshift(bit.band(c, 0x0F), 12), bit.lshift(bit.band(c2, 0x3F), 6),
                                bit.band(c3, 0x3F))
                            table.insert(utf16bytes[line], bit.rshift(u, 8))
                            table.insert(utf16bytes[line], bit.band(u, 0xFF))
                            i = i + 3
                        else
                            local c2 = source:byte(i + 1)
                            local c3 = source:byte(i + 2)
                            local c4 = source:byte(i + 3)
                            local u = bit.bor(bit.lshift(bit.band(c, 0x07), 18), bit.lshift(bit.band(c2, 0x3F), 12),
                                bit.lshift(bit.band(c3, 0x3F), 6), bit.band(c4, 0x3F))
                            u = u - 0x10000
                            local high = bit.bor(0xD800, bit.rshift(u, 10))
                            local low = bit.bor(0xDC00, bit.band(u, 0x3FF))
                            table.insert(utf16bytes[line], bit.rshift(high, 8))
                            table.insert(utf16bytes[line], bit.band(high, 0xFF))
                            table.insert(utf16bytes[line], bit.rshift(low, 8))
                            table.insert(utf16bytes[line], bit.band(low, 0xFF))
                            i = i + 4
                        end
                    end

                    for line = 1, #utf16bytes do
                        utf32bytes[line] = {}
                        local i = 1
                        while i <= #utf16bytes[line] do
                            local b1 = utf16bytes[line][i]
                            local b2 = utf16bytes[line][i + 1]
                            local code_unit = bit.bor(bit.lshift(b1, 8), b2)
                            if code_unit >= 0xD800 and code_unit <= 0xDBFF then
                                -- High surrogate
                                local b3 = utf16bytes[line][i + 2]
                                local b4 = utf16bytes[line][i + 3]
                                local low_surrogate = bit.bor(bit.lshift(b3, 8), b4)
                                local code_point = bit.bor(bit.lshift(bit.band(code_unit, 0x3FF), 10),
                                        bit.band(low_surrogate, 0x3FF)) +
                                    0x10000
                                table.insert(utf32bytes[line], code_point)
                                i = i + 4
                            else
                                -- Non-surrogate
                                if code_unit ~= 0xFE0F then
                                    table.insert(utf32bytes[line], code_unit)
                                end
                                i = i + 2
                            end
                        end
                    end
                end

                return utf32bytes
            end,

            SetText = function(this, text)
                this.Text = text
                this.Unicode = this.ToUniCode(this)
            end,

            GetLineNum = function(this)
                return #this.Unicode
            end,

            GetLine = function(this, line)
                if line <= this.GetLineNum(this) then
                    return this.Unicode[line]
                else
                    print(
                        string.format("Requested line number is out of range: request=%d, line=%d",
                            line,
                            this.GetLineNum(this))
                    )
                    return {}
                end
            end
        }
    end
}

local TextPosition = {
    New = function(x, y, justify, align, tracking, lineSpacing, emojiTracking)
        return {
            X = x,
            Y = y,
            Justify = justify,
            Align = align,
            Tracking = tracking,
            LineSpacing = lineSpacing,
            EmojiTracking = emojiTracking
        }
    end
}

local TextFont = {
    New = function(name, style)
        return {
            Name = name,
            Style = style,
        }
    end
}

local sSourceText = UnicodeText.New()
local sInnerColor = Pixel { R = 0, G = 0, B = 0, A = 1.0 }
local sOuterColor1 = Pixel { R = 0, G = 0, B = 0, A = 1.0 }
local sOuterColor2 = Pixel { R = 0, G = 0, B = 0, A = 1.0 }


local function rgbToHsv(r, g, b)
    local max = math.max(r, g, b)
    local min = math.min(r, g, b)
    local h, s, v = 0, 0, max

    local d = max - min
    s = max == 0 and 0 or d / max

    if max == min then
        h = 0 -- achromatic
    else
        if max == r then
            h = (g - b) / d + (g < b and 6 or 0)
        elseif max == g then
            h = (b - r) / d + 2
        elseif max == b then
            h = (r - g) / d + 4
        end
        h = h / 6
    end

    return h, s, v
end

local function hsvToRgb(h, s, v)
    local r, g, b

    local i = math.floor(h * 6)
    local f = h * 6 - i
    local p = v * (1 - s)
    local q = v * (1 - f * s)
    local t = v * (1 - (1 - f) * s)

    i = i % 6

    if i == 0 then
        r, g, b = v, t, p
    elseif i == 1 then
        r, g, b = q, v, p
    elseif i == 2 then
        r, g, b = p, v, t
    elseif i == 3 then
        r, g, b = p, q, v
    elseif i == 4 then
        r, g, b = t, p, v
    elseif i == 5 then
        r, g, b = v, p, q
    end

    return r, g, b
end

local function getLuminance(r, g, b)
    local function channelLuminance(channel)
        if channel <= 0.03928 then
            return channel / 12.92
        else
            return ((channel + 0.055) / 1.055) ^ 2.4
        end
    end

    return 0.2126 * channelLuminance(r) + 0.7152 * channelLuminance(g) + 0.0722 * channelLuminance(b)
end

local function calculateContrastRatio(color1, color2)
    local lum1 = getLuminance(color1.R, color1.G, color1.B)
    local lum2 = getLuminance(color2.R, color2.G, color2.B)

    if lum1 > lum2 then
        return (lum1 + 0.05) / (lum2 + 0.05)
    else
        return (lum2 + 0.05) / (lum1 + 0.05)
    end
end

local function adjustLuminanceForContrast(color)
    local step = 0.5
    local maxAttempts = (1 / step)

    local testColor = { R = 0, G = 0, B = 0 }
    local bestH, bestS, bestV = 0, 0, 1
    local bestContrast = 0

    for i = 0, maxAttempts do
        local newV = 1.0 - (step * i)
        if newV >= 0 and newV <= 1 then
            testColor.R, testColor.G, testColor.B = hsvToRgb(bestH, bestS, newV)
            local contrast = calculateContrastRatio(color, testColor)
            if contrast > bestContrast then
                bestContrast = contrast
                bestV = newV
            end
        end
    end
    local bestR, bestG, bestB = hsvToRgb(bestH, bestS, bestV)

    return Pixel { R = bestR, G = bestG, B = bestB, A = color.A } -- Return the color with the highest contrast found
end

local function getComplementaryColor(color)
    local h, s, v = rgbToHsv(color.R, color.G, color.B)
    h = h + 0.5
    if 1 < h then
        h = h - 1
    end
    local r, g, b = hsvToRgb(h, s, v)

    return Pixel { R = r, G = g, B = b, A = color.A } -- Return the color with the highest contrast found
end

local function getClosestContrastingColor(color)
    local targetHue, _, _ = rgbToHsv(color.R, color.G, color.B)
    local bestColor = nil
    local bestContrast = 0

    for i = 0, 360, 1 do
        local testColor = { R = 0, G = 0, B = 0 }
        testColor.R, testColor.G, testColor.B = hsvToRgb(i / 360, 1, 1)
        local contrast = calculateContrastRatio(color, testColor)
        if contrast >= 7 and (bestColor == nil or math.abs(i / 360 - targetHue) < math.abs(bestColor.Hue - targetHue)) then
            bestColor = testColor
            bestColor.Hue = i / 360
            bestContrast = contrast
        end
    end

    return bestColor
end

local TextColor = {
    New = function(baseColor, target, type)
        return {
            BaseColor = Pixel { R = baseColor.R, G = baseColor.G, B = baseColor.B, A = baseColor.A },
            Target = target,
            Type = type,

            _innerColor = nil,
            _outlineColor1 = nil,
            _outlineColor2 = nil,

            _updateColor = function(this)
                local c1, c2
                if this.Type == 0 then
                    c1 = adjustLuminanceForContrast(this.BaseColor)
                    c2 = adjustLuminanceForContrast(c1)
                else
                    c1 = getComplementaryColor(this.BaseColor)
                    c2 = getComplementaryColor(c1)
                end
                if this._innerColor == nil then
                    if this.Target == 0 then
                        this._innerColor = this.BaseColor
                        this._outlineColor1 = c1
                        this._outlineColor2 = c2
                    else
                        this._outlineColor1 = this.BaseColor
                        this._innerColor = c1
                        this._outlineColor2 = c1
                    end
                end
            end,

            GetInnerColor = function(this)
                this._updateColor(this)
                return Pixel { R = this._innerColor.R, G = this._innerColor.G, B = this._innerColor.B, A = this._innerColor.A }
            end,

            GetOutlineColor1 = function(this)
                this._updateColor(this)
                return Pixel { R = this._outlineColor1.R, G = this._outlineColor1.G, B = this._outlineColor1.B, A = this._outlineColor1.A }
            end,

            GetOutlineColor2 = function(this)
                this._updateColor(this)
                return Pixel { R = this._outlineColor2.R, G = this._outlineColor2.G, B = this._outlineColor2.B, A = this._outlineColor2.A }
            end,
        }
    end
}

local function isEmoji(unicode)
    if 0x231A <= unicode and unicode <= 0x2B55 then
        return true
    elseif 0x1F004 <= unicode and unicode <= 0x1FAF8 then
        return true
    elseif 0xFE0F == unicode then
        return true
    end

    return false
end

local function getLineDrawWidth(unicodeArray, tfm, emojiTfm, origSize, emojiSize, tracking, emojiTracking)
    local lineWidth = 0

    for i = 1, #unicodeArray do
        -- add the kerning between this character and the previous one
        if 1 < i then
            local currentTfm
            local size
            if isEmoji(unicodeArray[i - 1]) then
                currentTfm = emojiTfm
                size = emojiSize
            else
                currentTfm = tfm
                size = origSize
            end
            local kerning = currentTfm:CharacterKerning(unicodeArray[i - 1], unicodeArray[i]) * 10 * size
            lineWidth = lineWidth + kerning
        end
        local currentTfm
        local size
        if isEmoji(unicodeArray[i]) then
            currentTfm = emojiTfm
            size = emojiSize
        else
            currentTfm = tfm
            size = origSize
        end
        -- add the width of the character
        lineWidth = lineWidth + (currentTfm:CharacterWidth(unicodeArray[i]) * 10 * size)
        if i < #unicodeArray then
            if isEmoji(unicodeArray[i]) then
                lineWidth = lineWidth + (origSize * (emojiTracking - 1.0))
            else
                lineWidth = lineWidth + (origSize * (tracking - 1.0))
                if 1 < i and isEmoji(unicodeArray[i - 1]) == true then
                    lineWidth = lineWidth + (origSize * (emojiTracking - 1.0) / 2)
                end
            end
        end
    end


    return lineWidth
end

--local debug = true
local function drawstring(img,
                          unicodeText,
                          position,
                          font,
                          emojiFont,
                          size,
                          emojiSize,
                          color,
                          quality,
                          thickness,
                          outlineNum)
    -- get the fonts metrics (see http://freetype.sourceforge.net/freetype2/docs/glyphs/index.html for a great guide)
    local tfm = TextStyleFontMetrics(TextStyleFont(font.Name, font.Style))
    local emojiTfm = TextStyleFontMetrics(TextStyleFont(emojiFont.Name, emojiFont.Style))
    local lineHeight = (tfm.TextAscent + tfm.TextDescent + tfm.TextExternalLeading) * 10 * size
    local emojiLineHeight = (emojiTfm.TextAscent + emojiTfm.TextDescent + emojiTfm.TextExternalLeading) * 10 * size
    local adjustEmojiY = (tfm.TextAscent - emojiTfm.TextAscent) * 10 * size

    local origSize = size

    -- This is the distance between this line and the next one.

    local mat = Matrix4()
    mat:Scale(1.0 / tfm.Scale, 1.0 / tfm.Scale, 1.0)
    mat:Scale(origSize, origSize, 1)
    mat:Move(position.X, position.Y - (lineHeight / 2), 0)

    local emojiMat = Matrix4()
    emojiMat:Scale(1.0 / tfm.Scale, 1.0 / tfm.Scale, 1.0)
    emojiMat:Scale(emojiSize, emojiSize, 1)
    emojiMat:Move(position.X, position.Y - (emojiLineHeight / 2), 0)
    emojiMat:Move(0, adjustEmojiY, 0)

    local boxHeight = (lineHeight + ((position.LineSpacing - 1) * origSize)) * unicodeText:GetLineNum()
    local emojiBoxHeight = (emojiLineHeight + ((position.LineSpacing - 1) * origSize)) * unicodeText:GetLineNum()
    if position.Align == 0 then
        mat:Move(0, 0, 0)
        emojiMat:Move(0, 0, 0)
    elseif position.Align == 1 then
        mat:Move(0, (boxHeight / 2) - (tfm.TextDescent * 10 * size), 0)
        emojiMat:Move(0, (emojiBoxHeight / 2) - (emojiTfm.TextDescent * 10 * size), 0)
    elseif position.Align == 2 then
        mat:Move(0, boxHeight - (lineHeight / 2), 0)
        emojiMat:Move(0, emojiBoxHeight - (emojiLineHeight / 2), 0)
    end

    local shapeNormal = Shape()
    local shapeOutline1 = Shape()
    local shapeOutline2 = Shape()
    local prevLineDrawWidth = 0
    for line = 1, unicodeText:GetLineNum() do
        local unicodeArray = unicodeText:GetLine(line)
        local lineWidth = getLineDrawWidth(unicodeArray, tfm, emojiTfm, origSize, emojiSize,
            position.Tracking,
            position.EmojiTracking)

        if position.Justify == 0 then
            mat:Move(-prevLineDrawWidth, 0, 0)
            mat:Move(0, 0, 0)
            emojiMat:Move(-prevLineDrawWidth, 0, 0)
            emojiMat:Move(0, 0, 0)
        elseif position.Justify == 1 then
            mat:Move(-prevLineDrawWidth / 2, 0, 0)
            mat:Move(-(lineWidth / 2), 0, 0)
            emojiMat:Move(-prevLineDrawWidth / 2, 0, 0)
            emojiMat:Move(-(lineWidth / 2), 0, 0)
        elseif position.Justify == 2 then
            mat:Move(0, 0, 0)
            mat:Move(-lineWidth, 0, 0)
            emojiMat:Move(0, 0, 0)
            emojiMat:Move(-lineWidth, 0, 0)
        end

        local xPos = 0
        local prevWidth
        for i = 1, #unicodeArray do
            local characterCode = unicodeArray[i]

            local currentTmf
            local currentMat
            local currentTracking
            if isEmoji(characterCode) then
                currentTmf = emojiTfm
                size = emojiSize
                currentMat = emojiMat
                currentTracking = position.EmojiTracking
                if 1 < i and isEmoji(unicodeArray[i - 1]) == false then
                    mat:Move((position.EmojiTracking - 1) * origSize / 2, 0, 0)
                    emojiMat:Move((position.EmojiTracking - 1) * origSize / 2, 0, 0)
                end
            else
                currentTmf = tfm
                currentMat = mat
                size = origSize
                currentTracking = position.Tracking
                if 1 < i and isEmoji(unicodeArray[i - 1]) == true then
                    -- mat:Move((position.EmojiTracking - 1) * (emojiSize / 2), 0, 0)
                    -- emojiMat:Move((position.EmojiTracking - 1) * (emojiSize / 2), 0, 0)
                end
            end
            local width = currentTmf:CharacterWidth(characterCode) * 10 * size

            -- if this is not the first character, apply kerning
            if 1 < i then
                local prevChar = unicodeArray[i - 1]
                local xOffset = currentTmf:CharacterKerning(prevChar, characterCode) * 10 * size
                mat:Move(xOffset, 0, 0)
                emojiMat:Move(xOffset, 0, 0)
            end

            -- move the cursor to the center of the character
            mat:Move(width / 2, 0, 0)
            emojiMat:Move(width / 2, 0, 0)


            if debug == true then
                local testMat = Matrix4()
                local testMat = currentMat * testMat
                local testMatTable = testMat:GetTable()
                local testX = testMatTable[13]
                local testY = testMatTable[14]
                -- shapeNormal:MoveTo(0.2, testY)
                local lineHeightB = (tfm.TextAscent + tfm.TextExternalLeading) * 10 * size
                local emojiLineHeightB = (emojiTfm.TextAscent + emojiTfm.TextExternalLeading) * 10 *
                    size

                if isEmoji(characterCode) then
                    shapeOutline1:AddRectangle(testX - (width / 2), testX + (width / 2), testY + (emojiLineHeight / 2),
                        testY - (emojiLineHeight / 2))
                    shapeNormal:AddRectangle(testX - (width / 2), testX + (width / 2), testY + (emojiLineHeightB / 2),
                        testY - (emojiLineHeightB / 2))
                else
                    shapeOutline1:AddRectangle(testX - (width / 2), testX + (width / 2), testY + (lineHeight / 2),
                        testY - (lineHeight / 2))
                    shapeNormal:AddRectangle(testX - (width / 2), testX + (width / 2), testY + (lineHeightB / 2),
                        testY - (lineHeightB / 2))
                end
            end

            -- get the shape of the character
            local characterShape = currentTmf:GetCharacterShape(characterCode, false)
            if characterShape then
                local base = characterShape:TransformOfShape(currentMat)
                shapeNormal:AddShape(base)
                if 1 <= outlineNum then
                    local outline1 = base:OutlineOfShape(
                        thickness * size, "OLT_Solid", "OJT_Round", 8, "SWM_Normal", 8
                    )
                    shapeOutline1:AddShape(outline1)
                end
                if 2 <= outlineNum then
                    local outline2 = base:OutlineOfShape(
                        thickness * 2 * size, "OLT_Solid", "OJT_Round", 8, "SWM_Normal", 8
                    )
                    shapeOutline2:AddShape(outline2)
                end
            end

            mat:Move(width / 2, 0, 0)
            emojiMat:Move(width / 2, 0, 0)

            if i < #unicodeArray then
                mat:Move((currentTracking - 1) * origSize, 0, 0)
                emojiMat:Move((currentTracking - 1) * origSize, 0, 0)
            end
            prevWidth = width
            ::continue::
        end

        -- line end, move the cursor back to the start
        mat:Move(0, -lineHeight, 0)
        mat:Move(0, -(position.LineSpacing - 1) * origSize, 0)
        emojiMat:Move(0, -emojiLineHeight, 0)
        emojiMat:Move(0, -(position.LineSpacing - 1) * origSize, 0)
        prevLineDrawWidth = lineWidth
    end

    local ic = ImageChannel(img, quality)
    local fs = FillStyle()
    local cs = ChannelStyle()
    ic:SetStyleFill(fs)
    if outlineNum >= 2 then
        -- print("R: "..sOuterColor2.R.." G: "..sOuterColor2.G.." B: "..sOuterColor2.B.." A: "..sOuterColor2.A)
        cs.Color = color:GetOutlineColor2()
        ic:ShapeFill(shapeOutline2)
        ic:PutToImage("CM_Merge", cs)
    end
    if outlineNum >= 1 then
        -- print("R: "..sOuterColor1.R.." G: "..sOuterColor1.G.." B: "..sOuterColor1.B.." A: "..sOuterColor1.A)
        cs.Color = color:GetOutlineColor1()
        ic:ShapeFill(shapeOutline1)
        ic:PutToImage("CM_Merge", cs)
    end
    -- print("R: "..sInnerColor.R.." G: "..sInnerColor.G.." B: "..sInnerColor.B.." A: "..sInnerColor.A)
    cs.Color = color:GetInnerColor()
    ic:ShapeFill(shapeNormal)
    ic:PutToImage("CM_Merge", cs)
end

function OnAddToFlow()
    -- print("OnAddToFlow")
end

function PreCalcProcess(req)
    -- print("PreCalcProcess")
    local text = InText:GetValue(req).Value
    sSourceText = UnicodeText.New()
    sSourceText:SetText(text)

    local r = InR:GetValue(req).Value
    local g = InG:GetValue(req).Value
    local b = InB:GetValue(req).Value
    local a = InA:GetValue(req).Value
    if InColorTarget:GetValue(req).Value == 0 then
        sInnerColor = Pixel { R = r, G = g, B = b, A = a }
        sOuterColor1 = adjustLuminanceForContrast(sInnerColor)
        sOuterColor2 = adjustLuminanceForContrast(sOuterColor1)
    else
        sOuterColor1 = Pixel { R = r, G = g, B = b, A = a }
        sInnerColor = adjustLuminanceForContrast(sOuterColor1)
        sOuterColor2 = adjustLuminanceForContrast(sOuterColor1)
    end

    local img = InImage:GetValue(req)
    local dod = req:GetInputDoD(InImage)
    -- print("Input DoD:   ", dod, dod:ValidWidth().."x"..dod:ValidHeight())
    -- print("Request ROI: ", "not available during PreCalc")
    local datawnd = dod:Intersect(img.DataWindow)
    local out = Image({
        IMG_Like = img,
        IMG_DataWindow = datawnd,
        IMG_ValidWindow = nil,
        IMG_NoData = true,
    })
    OutImage:Set(req, out)
end

function Process(req)
    local img              = InImage:GetValue(req)

    -- font
    local font             = InFont:GetValue(req).Value
    local style            = InFontStyle:GetValue(req).Value
    local mainFont         = TextFont.New(font, style)

    -- emoji font
    local emojiFontEnabled = InEmojiFontEnabled:GetValue(req).Value
    local emojiFontName    = InEmojiFont:GetValue(req).Value
    local emojiFontStyle   = InEmojiFontStyle:GetValue(req).Value
    local emojiFont
    if emojiFontEnabled == 1 then
        emojiFont = TextFont.New(emojiFontName, emojiFontStyle)
    else
        emojiFont = TextFont.New(font, style)
    end


    local roi              = req:GetRoI()
    local out              = img:CopyOf()

    local size             = InSize:GetValue(req).Value
    local emojiSize        = InEmojiSize:GetValue(req).Value

    local r                = InR:GetValue(req).Value
    local g                = InG:GetValue(req).Value
    local b                = InB:GetValue(req).Value
    local a                = InA:GetValue(req).Value
    local colorTarget      = InColorTarget:GetValue(req).Value
    local outlineColorType = InOutlineColorType:GetValue(req).Value
    local textColor        = TextColor.New(Pixel { R = r, G = g, B = b, A = a }, colorTarget, outlineColorType)

    local thickness        = InOutlineThickness:GetValue(req).Value
    local outlineNum       = InOutlineNum:GetValue(req).Value

    -- Position
    local aspectRatio      = (out.Height * out.YScale) / (out.Width * out.XScale)
    local offset           = InOffset:GetValue(req)
    local x                = offset.X
    local y                = offset.Y * aspectRatio
    local justify          = InJustify:GetValue(req).Value
    local align            = InAlign:GetValue(req).Value
    local tracking         = InTracking:GetValue(req).Value
    local lineSpacing      = InLineSpacing:GetValue(req).Value
    local emojiTracking    = InEmojiTracking:GetValue(req).Value
    local position
    if emojiFontEnabled == 1 then
        position = TextPosition.New(x, y, justify, align, tracking, lineSpacing, emojiTracking)
    else
        position = TextPosition.New(x, y, justify, align, tracking, lineSpacing, tracking)
    end

    local quality = 32
    if req:IsQuick() then
        quality = 1
    end

    local text = InText:GetValue(req).Value
    local sourceText = UnicodeText.New()
    sourceText:SetText(text)

    -- if the FontManager list is empty, scan the font list
    -- If the UI has never been shown, as would always be the case on a render node,
    -- nothing will scan the font list for available fonts. So we check for that here,
    -- and force a scan if needed.
    if not next(FontManager:GetFontList()) then
        FontManager:ScanDir()
    end

    -- the drawstring function is doing all the heavy lifting
    drawstring(
        out,
        sourceText,
        position,
        mainFont,
        emojiFont,
        size,
        emojiSize,
        textColor,
        quality,
        thickness,
        outlineNum
    )

    OutImage:Set(req, out)
end

function NotifyChanged(inp, param, time)
    -- when the tools FontFileControl is first created, the FontManager has not yet
    -- provided a FontList, so we can't set a default value. Instead we do it here.
    if (inp == InFont) or (inp == InEmojiFont) then
        local f = param.Value

        if f == nil or string.len(f) == 0 then
            local fontList = FontManager:GetFontList()
            if inp == InEmojiFont and fontList["Segoe UI Emoji"] then
                inp:SetSource(Text("Segoe UI Emoji"), time)
            else
                inp:SetSource(Text("Open Sans"), time)
            end
        end
    elseif (inp == InFontStyle) or (inp == InEmojiFontStyle) then
        local f = param.Value

        if f == nil or string.len(f) == 0 then
            inp:SetSource(Text("Regular"), time)
        end
    elseif inp == InText then
        local f = param.Value
        if f == nil or string.len(f) == 0 then
            InText:SetSource(Text("Sample"), time)
        end
    elseif inp == InEmojiFontEnabled then
        if param.Value == 1 then
            InEmojiFont:SetAttrs({ IC_Visible = true })
            InEmojiFontStyle:SetAttrs({ IC_Visible = true })
            InEmojiSize:SetAttrs({ IC_Visible = true })
            InEmojiTracking:SetAttrs({ IC_Visible = true })
        else
            InEmojiFont:SetAttrs({ IC_Visible = false })
            InEmojiFontStyle:SetAttrs({ IC_Visible = false })
            InEmojiSize:SetAttrs({ IC_Visible = false })
            InEmojiTracking:SetAttrs({ IC_Visible = false })
        end
    end
end
