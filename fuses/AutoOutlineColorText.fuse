--[[--
Auto Outline Color Text
--]] --

--******************************************************************************************************
FuRegisterClass("AutoOutlineColorText", CT_Tool, {
    REGS_Name             = "Auto Outline Color Text",
    REGS_Category         = "Fuses\\Mug",
    REGS_OpIconString     = "AOCT",
    REGS_OpDescription    = "Auto Outline Color Text",
    REGS_HelpTopic        = "https://x.com/MugLab3",     --This can be a URL
    REGS_URL              = "https://www.youtube.com/@MugLabVideoEditing",
    REGS_IconID           = "Icons.Tools.Icons.Example", -- This can be Inline as an array of Values
    REG_OpNoMask          = false,
    REG_NoBlendCtrls      = false,
    REG_NoObjMatCtrls     = true,
    REG_NoMotionBlurCtrls = true,
    REG_Fuse_NoEdit       = false,
    REG_Fuse_NoReload     = false,
    REG_SupportsDoD       = true,
    REG_NoPreCalcProcess  = false,
    REG_Version           = 1,
})

function Create()
    self:AddControlPage("Controls")
    local groupId = 0;

    self:BeginControlNest("Text", "TextLabel", true);

    InText = self:AddInput("Text", "Text", {
        LINKID_DataType     = "Text",
        INPID_InputControl  = "TextEditControl",
        TEC_Lines           = 5,
        INP_DoNotifyChanged = false,
    })

    -- Font group
    groupId = groupId + 1;

    InFont = self:AddInput("Font", "Font", {
        LINKID_DataType     = "Text",
        INPID_InputControl  = "FontFileControl",
        IC_ControlGroup     = groupId,
        IC_ControlID        = 0,
        INP_Level           = 1,
        INP_DoNotifyChanged = true,
    })

    InFontStyle = self:AddInput("Font Style", "FontStyle", {
        LINKID_DataType     = "Text",
        INPID_InputControl  = "FontFileControl",
        IC_ControlGroup     = groupId,
        IC_ControlID        = 1,
        INP_Level           = 1,
        INP_DoNotifyChanged = true,
    })

    InSize = self:AddInput("Size", "Size", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "SliderControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 0.5,
        INP_Default        = 0.08,
    })

    InTracking = self:AddInput("Tracking", "Tracking", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "SliderControl",
        INP_MinScale       = -1.0,
        INP_MaxScale       = 2.0,
        INP_MinAllowed     = -4.0,
        INP_MaxAllowed     = 5.0,
        INP_Default        = 1.0,
    })

    InLineSpacing = self:AddInput("Line Spacing", "LineSpacing", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "SliderControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 2.0,
        INP_MinAllowed     = 0.0,
        INP_MaxAllowed     = 10.0,
        INP_Default        = 1.0,
    })

    self:BeginControlNest("Main Color", "MainColorLabel", true);

    InColorTarget = self:AddInput("Target", "ColorTarget", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "MultiButtonControl",
        INP_Default        = 0,
        { MBTNC_AddButton = "Inner", MBTNCD_ButtonWidth = 1 / 2, },
        { MBTNC_AddButton = "Outer", MBTNCD_ButtonWidth = 1 / 2, },
        INP_Integer = true,
        INP_DoNotifyChanged = true,
    })

    groupId = groupId + 1;
    InR = self:AddInput("Red", "Red", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupId,
        IC_ControlID       = 0, -- Red ID
    })

    InG = self:AddInput("Green", "Green", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        IC_ControlGroup    = groupId,
        IC_ControlID       = 1, -- Green ID
    })

    InB = self:AddInput("Blue", "Blue", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        IC_ControlGroup    = groupId,
        IC_ControlID       = 2, -- Blue ID
    })

    InA = self:AddInput("Alpha", "Alpha", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        IC_ControlGroup    = groupId,
        IC_ControlID       = 3, -- Alpha ID
    })

    self:EndControlNest()

    self:BeginControlNest("Outline", "OutlineLabel", true);

    InOutlineColorType = self:AddInput("Type", "OutlineColorType", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "MultiButtonControl",
        INP_Default        = 0,
        { MBTNC_AddButton = "Mono",    MBTNCD_ButtonWidth = 1 / 3, },
        { MBTNC_AddButton = "Comp",    MBTNCD_ButtonWidth = 1 / 3, },
        { MBTNC_AddButton = "Custom ", MBTNCD_ButtonWidth = 1 / 3, },
        INP_Integer = true,
        INP_DoNotifyChanged = true,
    })

    InOutlineNum = self:AddInput("Num", "OutlineNum", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "SliderControl",
        INP_MinScale       = 0,
        INP_MaxScale       = 2,
        INP_Default        = 1,
        INP_MinAllowed     = 0,
        INP_MaxAllowed     = 2,
        INP_Integer        = true,
    })

    InOutlineThickness = self:AddInput("Tickness", "OutlineTickness", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "SliderControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 0.1,
        INP_Default        = 0.08,
    })


    self:BeginControlNest("Color 1", "OutlineColor1", true);
    groupId = groupId + 1;
    InR2 = self:AddInput("Red", "Red2", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupId,
        IC_ControlID       = 0, -- Red ID
    })

    InG2 = self:AddInput("Green", "Green2", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        IC_ControlGroup    = groupId,
        IC_ControlID       = 1, -- Green ID
    })

    InB2 = self:AddInput("Blue", "Blue2", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        IC_ControlGroup    = groupId,
        IC_ControlID       = 2, -- Blue ID
    })

    InA2 = self:AddInput("Alpha", "Alpha2", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        IC_ControlGroup    = groupId,
        IC_ControlID       = 3, -- Alpha ID
    })
    self:EndControlNest()

    self:BeginControlNest("Color 2", "OutlineColor2", true);

    groupId = groupId + 1;

    InR3 = self:AddInput("Red", "Red3", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 0.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupId,
        IC_ControlID       = 0, -- Red ID
    })

    InG3 = self:AddInput("Green", "Green3", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 0.0,
        IC_ControlGroup    = groupId,
        IC_ControlID       = 1, -- Green ID
    })

    InB3 = self:AddInput("Blue", "Blue3", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 0.0,
        IC_ControlGroup    = groupId,
        IC_ControlID       = 2, -- Blue ID
    })

    InA3 = self:AddInput("Alpha", "Alpha3", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        IC_ControlGroup    = groupId,
        IC_ControlID       = 3, -- Alpha ID
    })
    self:EndControlNest()

    self:EndControlNest()


    self:EndControlNest()

    ------------- Position -------------
    self:AddControlPage("Position")
    self:BeginControlNest("Position", "PositionLabel", true);

    InOffset = self:AddInput("Offset", "Offset", {
        LINKID_DataType      = "Point",
        INPID_InputControl   = "OffsetControl",
        INPID_PreviewControl = "CrosshairControl",
    })

    InJustify = self:AddInput("Justification", "Justification", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "MultiButtonControl",
        INP_Default        = 1,
        { MBTNC_AddButton = "Left",   MBTNCD_ButtonWidth = 1 / 3, },
        { MBTNC_AddButton = "Center", MBTNCD_ButtonWidth = 1 / 3, },
        { MBTNC_AddButton = "Right",  MBTNCD_ButtonWidth = 1 / 3, },
        INP_Integer = true,
    })

    InAlign = self:AddInput("Alignment", "Alignment", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "MultiButtonControl",
        INP_Default        = 1,
        { MBTNC_AddButton = "Top",    MBTNCD_ButtonWidth = 1 / 3, },
        { MBTNC_AddButton = "Center", MBTNCD_ButtonWidth = 1 / 3, },
        { MBTNC_AddButton = "Bottom", MBTNCD_ButtonWidth = 1 / 3, },
        INP_Integer = true,
    })
    self:EndControlNest()

    self:BeginControlNest("Fitting", "FittingLabel", true);
    groupId = groupId + 1;
    InFittingPaddingWidth = self:AddInput("Width", "FittingPaddingWidth", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INPID_PreviewControl = "RectangleControl",
        PC_ControlGroup = groupId,
        PC_ControlID = 0,
        INP_MaxScale = 1,
        INP_Default = 0.92,
    })
    InFittingPaddingHeight = self:AddInput("Height", "FittingPaddingHeight", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INPID_PreviewControl = "RectangleControl",
        PC_ControlGroup = groupId,
        PC_ControlID = 1,
        INP_MaxScale = 1,
        INP_Default = 0.85,
    })
    InFittingTop = self:AddInput("Top", "FittingTop", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "MultiButtonControl",
        MBTNC_Type         = "Normal",
        MBTNC_ShowName     = false,
        INP_Default        = 0,
        { MBTNC_AddButton = "↖", MBTNCD_ButtonWidth = 1 / 3, },
        { MBTNC_AddButton = "↑", MBTNCD_ButtonWidth = 1 / 3, },
        { MBTNC_AddButton = "↗", MBTNCD_ButtonWidth = 1 / 3, },
        INP_Integer = true,
        INP_DoNotifyChanged = true,
    })
    InFittingMiddle = self:AddInput("Middle", "FittingMiddle", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "MultiButtonControl",
        MBTNC_Type         = "Normal",
        MBTNC_ShowName     = false,
        INP_Default        = 0,
        { MBTNC_AddButton = "←", MBTNCD_ButtonWidth = 1 / 3, },
        { MBTNC_AddButton = "+", MBTNCD_ButtonWidth = 1 / 3, },
        { MBTNC_AddButton = "→", MBTNCD_ButtonWidth = 1 / 3, },
        INP_Integer = true,
        INP_DoNotifyChanged = true,
    })
    InFittingBottom = self:AddInput("Bottom", "FittingBottom", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "MultiButtonControl",
        MBTNC_Type         = "Normal",
        MBTNC_ShowName     = false,
        INP_Default        = 0,
        { MBTNC_AddButton = "↙", MBTNCD_ButtonWidth = 1 / 3, },
        { MBTNC_AddButton = "↓", MBTNCD_ButtonWidth = 1 / 3, },
        { MBTNC_AddButton = "↘", MBTNCD_ButtonWidth = 1 / 3, },
        INP_Integer = true,
        INP_DoNotifyChanged = true,
    })
    self:EndControlNest()

    ------------- Emoji -------------
    self:AddControlPage("Emoji")

    self:BeginControlNest("Emoji", "EmojiLabel", true);

    InEmojiFontEnabled = self:AddInput("Use alternative fonts for emojis", "EnableEmojiFontEnabled", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Integer = true,
        INP_Default = 1.0,
        ICD_Width = 1,
        INP_DoNotifyChanged = true,
    })

    groupId = groupId + 1;
    InEmojiFont = self:AddInput("Font", "EmojiFont", {
        LINKID_DataType     = "Text",
        INPID_InputControl  = "FontFileControl",
        IC_ControlGroup     = groupId,
        IC_ControlID        = 0,
        INP_Level           = 1,
        INP_DoNotifyChanged = true,
        IC_Visible          = true,
    })

    InEmojiFontStyle = self:AddInput("Font Style", "EmojiFontStyle", {
        LINKID_DataType     = "Text",
        INPID_InputControl  = "FontFileControl",
        IC_ControlGroup     = groupId,
        IC_ControlID        = 1,
        INP_Level           = 1,
        INP_DoNotifyChanged = true,
        IC_Visible          = true,
    })

    InEmojiSize = self:AddInput("Size", "EmojiSize", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "SliderControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 0.5,
        INP_Default        = 0.08,
        IC_Visible         = true,
    })

    InEmojiTracking = self:AddInput("Tracking", "EmojiTracking", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "SliderControl",
        INP_MinScale       = -1.0,
        INP_MaxScale       = 2.0,
        INP_MinAllowed     = -4.0,
        INP_MaxAllowed     = 5.0,
        INP_Default        = 1.0,
        IC_Visible         = true,
    })

    InCustomEmojiOutline = self:AddInput("Match outline count with normal characters", "CustomEmojiOutline", {
        LINKID_DataType     = "Number",
        INPID_InputControl  = "CheckboxControl",
        INP_Integer         = true,
        INP_Default         = 1,
        ICD_Width           = 1,
        INP_MinAllowed      = 0,
        INP_MaxAllowed      = 1,
        INP_DoNotifyChanged = true,
    })

    InEmojiOutlineNum = self:AddInput("Outline Num", "EmojiOutlineNum", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "SliderControl",
        INP_MinScale       = 0,
        INP_MaxScale       = 2,
        INP_Default        = 0,
        INP_MinAllowed     = 0,
        INP_MaxAllowed     = 2,
        INP_Integer        = true,
    })

    self:EndControlNest()


    ------------- Debug -------------
    self:AddControlPage("Debug")

    self:BeginControlNest("Debug", "DebugLabel", true);

    InDebug = self:AddInput("Enable", "DebugEnable", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Integer        = true,
        INP_Default        = 0,
        ICD_Width          = 1,
        INP_MinAllowed     = 0,
        INP_MaxAllowed     = 1,
    })

    self:EndControlNest()


    InImage = self:AddInput("Input", "Input", {
        LINKID_DataType = "Image",
        LINK_Main       = 1,
    })

    OutImage = self:AddOutput("Output", "Output", {
        LINKID_DataType = "Image",
        LINK_Main       = 1,
    })
end

------------------------------------------------------------
local bit = require("bit")

local UnicodeText = {
    New = function()
        return {
            Text = "",
            Unicode = {},

            ToUniCode = function(this)
                local utf16bytes = {}
                local utf32bytes = {}
                local line = 1
                local source = this.Text

                if source and (0 < #source) then
                    utf16bytes[line] = {}
                    local i = 1
                    while i <= #source do
                        local c = source:byte(i)
                        if c == 0x0A then
                            line = line + 1
                            utf16bytes[line] = {}
                            i = i + 1
                        elseif c < 0x80 then
                            table.insert(utf16bytes[line], 0)
                            table.insert(utf16bytes[line], c)
                            i = i + 1
                        elseif c < 0xE0 then
                            local c2 = source:byte(i + 1)
                            local u = bit.bor(bit.lshift(bit.band(c, 0x1F), 6), bit.band(c2, 0x3F))
                            table.insert(utf16bytes[line], bit.rshift(u, 8))
                            table.insert(utf16bytes[line], bit.band(u, 0xFF))
                            i = i + 2
                        elseif c < 0xF0 then
                            local c2 = source:byte(i + 1)
                            local c3 = source:byte(i + 2)
                            local u = bit.bor(bit.lshift(bit.band(c, 0x0F), 12), bit.lshift(bit.band(c2, 0x3F), 6),
                                bit.band(c3, 0x3F))
                            table.insert(utf16bytes[line], bit.rshift(u, 8))
                            table.insert(utf16bytes[line], bit.band(u, 0xFF))
                            i = i + 3
                        else
                            local c2 = source:byte(i + 1)
                            local c3 = source:byte(i + 2)
                            local c4 = source:byte(i + 3)
                            local u = bit.bor(bit.lshift(bit.band(c, 0x07), 18), bit.lshift(bit.band(c2, 0x3F), 12),
                                bit.lshift(bit.band(c3, 0x3F), 6), bit.band(c4, 0x3F))
                            u = u - 0x10000
                            local high = bit.bor(0xD800, bit.rshift(u, 10))
                            local low = bit.bor(0xDC00, bit.band(u, 0x3FF))
                            table.insert(utf16bytes[line], bit.rshift(high, 8))
                            table.insert(utf16bytes[line], bit.band(high, 0xFF))
                            table.insert(utf16bytes[line], bit.rshift(low, 8))
                            table.insert(utf16bytes[line], bit.band(low, 0xFF))
                            i = i + 4
                        end
                    end

                    for line = 1, #utf16bytes do
                        utf32bytes[line] = {}
                        local i = 1
                        while i <= #utf16bytes[line] do
                            local b1 = utf16bytes[line][i]
                            local b2 = utf16bytes[line][i + 1]
                            local code_unit = bit.bor(bit.lshift(b1, 8), b2)
                            if code_unit >= 0xD800 and code_unit <= 0xDBFF then
                                -- High surrogate
                                local b3 = utf16bytes[line][i + 2]
                                local b4 = utf16bytes[line][i + 3]
                                local low_surrogate = bit.bor(bit.lshift(b3, 8), b4)
                                local code_point = bit.bor(bit.lshift(bit.band(code_unit, 0x3FF), 10),
                                        bit.band(low_surrogate, 0x3FF)) +
                                    0x10000
                                table.insert(utf32bytes[line], code_point)
                                i = i + 4
                            else
                                -- Non-surrogate
                                if code_unit ~= 0xFE0F then
                                    table.insert(utf32bytes[line], code_unit)
                                end
                                i = i + 2
                            end
                        end
                    end
                end

                return utf32bytes
            end,

            SetText = function(this, text)
                this.Text = text
                this.Unicode = this.ToUniCode(this)
            end,

            GetLineNum = function(this)
                return #this.Unicode
            end,

            GetLine = function(this, line)
                if line <= this.GetLineNum(this) then
                    return this.Unicode[line]
                else
                    print(
                        string.format(
                            "Requested line number is out of range: request=%d, line=%d",
                            line,
                            this.GetLineNum(this)
                        )
                    )
                    return {}
                end
            end
        }
    end
}

local TextPosition = {
    New = function(x, y, justify, align, tracking, lineSpacing, emojiTracking)
        return {
            X = x,
            Y = y,
            Justify = justify,
            Align = align,
            Tracking = tracking,
            LineSpacing = lineSpacing,
            EmojiTracking = emojiTracking
        }
    end
}

local TextFont = {
    New = function(name, style)
        return {
            Name = name,
            Style = style,
        }
    end
}

local function rgbToHsv(r, g, b)
    local max = math.max(r, g, b)
    local min = math.min(r, g, b)
    local h, s, v = 0, 0, max

    local d = max - min
    s = max == 0 and 0 or d / max

    if max == min then
        h = 0 -- achromatic
    else
        if max == r then
            h = (g - b) / d + (g < b and 6 or 0)
        elseif max == g then
            h = (b - r) / d + 2
        elseif max == b then
            h = (r - g) / d + 4
        end
        h = h / 6
    end

    return h, s, v
end

local function hsvToRgb(h, s, v)
    local r, g, b

    local i = math.floor(h * 6)
    local f = h * 6 - i
    local p = v * (1 - s)
    local q = v * (1 - f * s)
    local t = v * (1 - (1 - f) * s)

    i = i % 6

    if i == 0 then
        r, g, b = v, t, p
    elseif i == 1 then
        r, g, b = q, v, p
    elseif i == 2 then
        r, g, b = p, v, t
    elseif i == 3 then
        r, g, b = p, q, v
    elseif i == 4 then
        r, g, b = t, p, v
    elseif i == 5 then
        r, g, b = v, p, q
    end

    return r, g, b
end

local function getLuminance(r, g, b)
    local function channelLuminance(channel)
        if channel <= 0.03928 then
            return channel / 12.92
        else
            return ((channel + 0.055) / 1.055) ^ 2.4
        end
    end

    return 0.2126 * channelLuminance(r) + 0.7152 * channelLuminance(g) + 0.0722 * channelLuminance(b)
end

local function calculateContrastRatio(color1, color2)
    local lum1 = getLuminance(color1.R, color1.G, color1.B)
    local lum2 = getLuminance(color2.R, color2.G, color2.B)

    if lum1 > lum2 then
        return (lum1 + 0.05) / (lum2 + 0.05)
    else
        return (lum2 + 0.05) / (lum1 + 0.05)
    end
end

local function adjustLuminanceForContrast(color)
    local step = 0.5
    local maxAttempts = (1 / step)

    local testColor = { R = 0, G = 0, B = 0 }
    local bestH, bestS, bestV = 0, 0, 1
    local bestContrast = 0

    for i = 0, maxAttempts do
        local newV = 1.0 - (step * i)
        if newV >= 0 and newV <= 1 then
            testColor.R, testColor.G, testColor.B = hsvToRgb(bestH, bestS, newV)
            local contrast = calculateContrastRatio(color, testColor)
            if contrast > bestContrast then
                bestContrast = contrast
                bestV = newV
            end
        end
    end
    local bestR, bestG, bestB = hsvToRgb(bestH, bestS, bestV)

    return Pixel { R = bestR, G = bestG, B = bestB, A = color.A } -- Return the color with the highest contrast found
end

local function getComplementaryColor(color)
    local h, s, v = rgbToHsv(color.R, color.G, color.B)
    h = h + 0.5
    if 1 < h then
        h = h - 1
    end
    local r, g, b = hsvToRgb(h, s, v)

    return Pixel { R = r, G = g, B = b, A = color.A } -- Return the color with the highest contrast found
end

local function getClosestContrastingColor(color)
    local targetHue, _, _ = rgbToHsv(color.R, color.G, color.B)
    local bestColor = nil
    local bestContrast = 0

    for i = 0, 360, 1 do
        local testColor = { R = 0, G = 0, B = 0 }
        testColor.R, testColor.G, testColor.B = hsvToRgb(i / 360, 1, 1)
        local contrast = calculateContrastRatio(color, testColor)
        if contrast >= 7 and (bestColor == nil or math.abs(i / 360 - targetHue) < math.abs(bestColor.Hue - targetHue)) then
            bestColor = testColor
            bestColor.Hue = i / 360
            bestContrast = contrast
        end
    end

    return bestColor
end

local TextColor = {
    New = function(baseColor, customColor1, customColor2, target, type)
        return {
            BaseColor = Pixel { R = baseColor.R, G = baseColor.G, B = baseColor.B, A = baseColor.A },
            CustomColor1 = Pixel { R = customColor1.R, G = customColor1.G, B = customColor1.B, A = customColor1.A },
            CustomColor2 = Pixel { R = customColor2.R, G = customColor2.G, B = customColor2.B, A = customColor2.A },
            Target = target,
            Type = type,

            _innerColor = nil,
            _outlineColor1 = nil,
            _outlineColor2 = nil,

            _updateColor = function(this)
                local c1, c2
                if this.Type == 0 then --Mono
                    c1 = adjustLuminanceForContrast(this.BaseColor)
                    c2 = adjustLuminanceForContrast(c1)
                elseif this.Type == 1 then --Comp
                    c1 = getComplementaryColor(this.BaseColor)
                    c2 = getComplementaryColor(c1)
                elseif this.Type == 2 then -- Custom
                    c1 = this.CustomColor1
                    c2 = this.CustomColor2
                end
                if this._innerColor == nil then
                    if this.Target == 0 then -- Inner
                        this._innerColor = this.BaseColor
                        this._outlineColor1 = c1
                        this._outlineColor2 = c2
                    elseif this.Target == 1 then -- Outer
                        this._outlineColor1 = this.BaseColor
                        this._innerColor = c1
                        this._outlineColor2 = c1
                    end
                end
            end,

            GetInnerColor = function(this)
                this._updateColor(this)
                return Pixel { R = this._innerColor.R, G = this._innerColor.G, B = this._innerColor.B, A = this._innerColor.A }
            end,

            GetOutlineColor1 = function(this)
                this._updateColor(this)
                return Pixel { R = this._outlineColor1.R, G = this._outlineColor1.G, B = this._outlineColor1.B, A = this._outlineColor1.A }
            end,

            GetOutlineColor2 = function(this)
                this._updateColor(this)
                return Pixel { R = this._outlineColor2.R, G = this._outlineColor2.G, B = this._outlineColor2.B, A = this._outlineColor2.A }
            end,
        }
    end
}

local function isEmoji(unicode)
    if 0x231A <= unicode and unicode <= 0x2B55 then
        return true
    elseif 0x1F004 <= unicode and unicode <= 0x1FAF8 then
        return true
    elseif 0xFE0F == unicode then
        return true
    end

    return false
end

local function getLineDrawWidth(unicodeArray, tfm, emojiTfm, origSize, emojiSize, tracking, emojiTracking)
    local lineWidth = 0

    for i = 1, #unicodeArray do
        -- add the kerning between this character and the previous one
        local currentTfm
        local size
        if isEmoji(unicodeArray[i]) then
            currentTfm = emojiTfm
            size = emojiSize
        else
            currentTfm = tfm
            size = origSize
        end

        -- add the width of the character
        lineWidth = lineWidth + (currentTfm:CharacterWidth(unicodeArray[i]) * 10 * size)

        -- Tracking
        if i < #unicodeArray then
            local offset = 0
            if isEmoji(unicodeArray[i]) or isEmoji(unicodeArray[i + 1]) then
                offset = offset + (tracking - 1) * origSize
                offset = offset + (emojiTracking - 1) * origSize
            else
                offset = offset + (tracking - 1) * origSize
            end
            lineWidth = lineWidth + offset
        end
    end


    return lineWidth
end

local function debugRectangle(img, baseMat, offsetX, offsetY, width, height, color, debug)
    if debug == 1 then
        local baseMatTable = baseMat:GetTable()
        local baseX        = baseMatTable[13]
        local baseY        = baseMatTable[14]
        local thickness    = 0.0006

        local shape        = Shape()
        shape:AddRectangle(
            (baseX + offsetX) + thickness / 2,
            (baseX + offsetX) + width - (thickness / 2),
            (baseY + offsetY),
            ((baseY + offsetY) + height),
            0,
            8
        )

        local shapeOutline =
            shape:OutlineOfShape(thickness, "OLT_Solid", "OJT_Round", 8, "SWM_Normal", 8)

        local cs = ChannelStyle()
        cs.Color = color

        local ic = ImageChannel(img, 1)
        local fs = FillStyle()
        ic:SetStyleFill(fs)
        ic:ShapeFill(shapeOutline)
        ic:PutToImage("CM_Merge", cs)
    end
end

local function drawstring(img,
                          unicodeText,
                          position,
                          font,
                          emojiFont,
                          size,
                          emojiSize,
                          color,
                          quality,
                          thickness,
                          outlineNum,
                          emojiOutlineNum,
                          debug)
    -- get the fonts metrics (see http://freetype.sourceforge.net/freetype2/docs/glyphs/index.html for a great guide)
    local tfm = TextStyleFontMetrics(TextStyleFont(font.Name, font.Style))
    local emojiTfm = TextStyleFontMetrics(TextStyleFont(emojiFont.Name, emojiFont.Style))
    local lineHeight = (tfm.TextAscent + tfm.TextDescent + tfm.TextExternalLeading) * 10 * size
    local emojiLineHeight = (emojiTfm.TextAscent + emojiTfm.TextDescent + emojiTfm.TextExternalLeading) * 10 * size
    local adjustEmojiY = (tfm.TextAscent - emojiTfm.TextAscent) * 10 * size

    local origSize = size

    -- This is the distance between this line and the next one.

    local mat = Matrix4()
    mat:Scale(1.0 / tfm.Scale, 1.0 / tfm.Scale, 1.0)
    mat:Scale(origSize, origSize, 1)
    mat:Move(position.X, position.Y - (lineHeight / 2), 0)

    local emojiMat = Matrix4()
    emojiMat:Scale(1.0 / tfm.Scale, 1.0 / tfm.Scale, 1.0)
    emojiMat:Scale(emojiSize, emojiSize, 1)
    emojiMat:Move(position.X, position.Y - (emojiLineHeight / 2), 0)
    emojiMat:Move(0, adjustEmojiY, 0)

    local boxHeight = (lineHeight + ((position.LineSpacing - 1) * origSize)) * unicodeText:GetLineNum()
    local emojiBoxHeight = (emojiLineHeight + ((position.LineSpacing - 1) * origSize)) * unicodeText:GetLineNum()
    if position.Align == 0 then
        mat:Move(0, 0, 0)
        emojiMat:Move(0, 0, 0)
    elseif position.Align == 1 then
        mat:Move(0, (boxHeight / 2) - (tfm.TextDescent * 10 * size), 0)
        emojiMat:Move(0, (emojiBoxHeight / 2) - (emojiTfm.TextDescent * 10 * size), 0)
    elseif position.Align == 2 then
        mat:Move(0, boxHeight - (lineHeight / 2), 0)
        emojiMat:Move(0, emojiBoxHeight - (emojiLineHeight / 2), 0)
    end

    local shapeNormal = Shape()
    local shapeOutline1 = Shape()
    local shapeOutline2 = Shape()
    local prevLineDrawWidth = 0
    for line = 1, unicodeText:GetLineNum() do
        local unicodeArray = unicodeText:GetLine(line)
        local lineWidth = getLineDrawWidth(
            unicodeArray,
            tfm,
            emojiTfm,
            origSize,
            emojiSize,
            position.Tracking,
            position.EmojiTracking
        )

        if position.Justify == 0 then
            mat:Move(-prevLineDrawWidth, 0, 0)
            emojiMat:Move(-prevLineDrawWidth, 0, 0)
        elseif position.Justify == 1 then
            mat:Move(-prevLineDrawWidth / 2, 0, 0)
            mat:Move(-(lineWidth / 2), 0, 0)
            emojiMat:Move(-prevLineDrawWidth / 2, 0, 0)
            emojiMat:Move(-(lineWidth / 2), 0, 0)
        elseif position.Justify == 2 then
            mat:Move(-lineWidth, 0, 0)
            emojiMat:Move(-lineWidth, 0, 0)
        end

        for i = 1, #unicodeArray do
            local characterCode = unicodeArray[i]

            local currentTmf
            local currentMat
            local currentOutlineNum
            if isEmoji(characterCode) then
                size = emojiSize
                currentTmf = emojiTfm
                currentMat = emojiMat
                currentOutlineNum = emojiOutlineNum
            else
                size = origSize
                currentTmf = tfm
                currentMat = mat
                currentOutlineNum = outlineNum
            end
            local width = currentTmf:CharacterWidth(characterCode) * 10 * size
            local halfWidth = width / 2

            -- if this is not the first character, apply kerning
            if 1 < i then
                local prevChar = unicodeArray[i - 1]
                local xOffset = currentTmf:CharacterKerning(prevChar, characterCode) * 10 * size
                mat:Move(xOffset, 0, 0)
                emojiMat:Move(xOffset, 0, 0)
            end

            -- move the cursor to the center of the character
            mat:Move(halfWidth, 0, 0)
            emojiMat:Move(halfWidth, 0, 0)

            -- get the shape of the character
            local characterShape = currentTmf:GetCharacterShape(characterCode, false)
            if characterShape then
                local base = characterShape:TransformOfShape(currentMat)
                shapeNormal:AddShape(base)
                if 1 <= currentOutlineNum then
                    local outline1 = base:OutlineOfShape(
                        thickness * size, "OLT_Solid", "OJT_Round", 8, "SWM_Normal", 8
                    )
                    shapeOutline1:AddShape(outline1)
                end
                if 2 <= currentOutlineNum then
                    local outline2 = base:OutlineOfShape(
                        thickness * 2 * size, "OLT_Solid", "OJT_Round", 8, "SWM_Normal", 8
                    )
                    shapeOutline2:AddShape(outline2)
                end
                debugRectangle(img, currentMat, -width / 2, -lineHeight / 2, width, lineHeight,
                    Pixel { R = 1, G = 1, B = 0, A = 1 }, debug)
            end

            mat:Move(halfWidth, 0, 0)
            emojiMat:Move(halfWidth, 0, 0)

            -- Tracking
            if i < #unicodeArray then
                local baseTracking = (position.Tracking - 1) * origSize
                local emojiTracking = 0
                if isEmoji(unicodeArray[i]) or isEmoji(unicodeArray[i + 1]) then
                    emojiTracking = (position.EmojiTracking - 1) * origSize
                    debugRectangle(img, mat, baseTracking, -lineHeight / 2, emojiTracking, lineHeight,
                        Pixel { R = 0, G = 1, B = 1, A = 1 }, debug)
                end
                local tracking = baseTracking + emojiTracking
                debugRectangle(img, mat, 0, -lineHeight / 2, baseTracking, lineHeight,
                    Pixel { R = 1, G = 0, B = 1, A = 1 }, debug)
                mat:Move(tracking, 0, 0)
                emojiMat:Move(tracking, 0, 0)
            end

            ::continue::
        end

        -- line end, move the cursor back to the start
        local scaledLineSpacing = (position.LineSpacing - 1) * origSize
        mat:Move(0, -(lineHeight + scaledLineSpacing), 0)
        emojiMat:Move(0, -(emojiLineHeight + scaledLineSpacing), 0)
        prevLineDrawWidth = lineWidth
    end

    local ic = ImageChannel(img, quality)
    local fs = FillStyle()
    local cs = ChannelStyle()
    ic:SetStyleFill(fs)
    if (outlineNum >= 2) or (emojiOutlineNum >= 2) then
        cs.Color = color:GetOutlineColor2()
        -- print("[outline2] R: " .. cs.Color.R .. " G: " .. cs.Color.G .. " B: " .. cs.Color.B .. " A: " .. cs.Color.A)
        ic:ShapeFill(shapeOutline2)
        ic:PutToImage("CM_Merge", cs)
    end
    if (outlineNum >= 1) or (emojiOutlineNum >= 1) then
        cs.Color = color:GetOutlineColor1()
        -- print("[outline1] R: " .. cs.Color.R .. " G: " .. cs.Color.G .. " B: " .. cs.Color.B .. " A: " .. cs.Color.A)
        ic:ShapeFill(shapeOutline1)
        ic:PutToImage("CM_Merge", cs)
    end
    -- print("R: "..sInnerColor.R.." G: "..sInnerColor.G.." B: "..sInnerColor.B.." A: "..sInnerColor.A)
    cs.Color = color:GetInnerColor()
    ic:ShapeFill(shapeNormal)
    ic:PutToImage("CM_Merge", cs)
end

function OnAddToFlow()
    -- print("OnAddToFlow")
end

function Process(req)
    local img              = InImage:GetValue(req)
    local out              = img:CopyOf()

    -- font
    local font             = InFont:GetValue(req).Value
    local style            = InFontStyle:GetValue(req).Value
    local mainFont         = TextFont.New(font, style)

    -- emoji font
    local emojiFontEnabled = InEmojiFontEnabled:GetValue(req).Value
    local emojiFontName    = InEmojiFont:GetValue(req).Value
    local emojiFontStyle   = InEmojiFontStyle:GetValue(req).Value
    local emojiFont
    if emojiFontEnabled == 1 then
        emojiFont = TextFont.New(emojiFontName, emojiFontStyle)
    else
        emojiFont = TextFont.New(font, style)
    end

    local size       = InSize:GetValue(req).Value
    local emojiSize  = InEmojiSize:GetValue(req).Value

    -- Outline
    local thickness  = InOutlineThickness:GetValue(req).Value
    local outlineNum = InOutlineNum:GetValue(req).Value
    local emojiOutlineNum
    if InCustomEmojiOutline:GetValue(req).Value == 1 then
        emojiOutlineNum = outlineNum
    else
        emojiOutlineNum = InEmojiOutlineNum:GetValue(req).Value
    end

    -- Color
    local r                = InR:GetValue(req).Value
    local g                = InG:GetValue(req).Value
    local b                = InB:GetValue(req).Value
    local a                = InA:GetValue(req).Value
    local r2               = InR2:GetValue(req).Value
    local g2               = InG2:GetValue(req).Value
    local b2               = InB2:GetValue(req).Value
    local a2               = InA2:GetValue(req).Value
    local r3               = InR3:GetValue(req).Value
    local g3               = InG3:GetValue(req).Value
    local b3               = InB3:GetValue(req).Value
    local a3               = InA3:GetValue(req).Value
    local colorTarget      = InColorTarget:GetValue(req).Value
    local outlineColorType = InOutlineColorType:GetValue(req).Value
    local textColor        = TextColor.New(
        Pixel { R = r, G = g, B = b, A = a },
        Pixel { R = r2, G = g2, B = b2, A = a2 },
        Pixel { R = r3, G = g3, B = b3, A = a3 },
        colorTarget,
        outlineColorType
    )

    -- Position
    local aspectRatio      = (out.Height * out.YScale) / (out.Width * out.XScale)
    local offset           = InOffset:GetValue(req)
    local x                = offset.X
    local y                = offset.Y * aspectRatio
    local justify          = InJustify:GetValue(req).Value
    local align            = InAlign:GetValue(req).Value
    local tracking         = InTracking:GetValue(req).Value
    local lineSpacing      = InLineSpacing:GetValue(req).Value
    local emojiTracking    = InEmojiTracking:GetValue(req).Value
    local position
    if emojiFontEnabled == 1 then
        position = TextPosition.New(x, y, justify, align, tracking, lineSpacing, emojiTracking)
    else
        position = TextPosition.New(x, y, justify, align, tracking, lineSpacing, tracking)
    end

    -- Debug
    local debug = InDebug:GetValue(req).Value

    local quality = 32
    if req:IsQuick() then
        quality = 1
    end

    local text = InText:GetValue(req).Value
    local sourceText = UnicodeText.New()
    sourceText:SetText(text)

    -- if the FontManager list is empty, scan the font list
    -- If the UI has never been shown, as would always be the case on a render node,
    -- nothing will scan the font list for available fonts. So we check for that here,
    -- and force a scan if needed.
    if not next(FontManager:GetFontList()) then
        FontManager:ScanDir()
    end

    -- the drawstring function is doing all the heavy lifting
    drawstring(
        out,
        sourceText,
        position,
        mainFont,
        emojiFont,
        size,
        emojiSize,
        textColor,
        quality,
        thickness,
        outlineNum,
        emojiOutlineNum,
        debug
    )

    OutImage:Set(req, out)
end

function NotifyChanged(inp, param, time)
    -- when the tools FontFileControl is first created, the FontManager has not yet
    -- provided a FontList, so we can't set a default value. Instead we do it here.
    if (inp == InFont) or (inp == InEmojiFont) then
        local f = param.Value
        if (f == nil) or (string.len(f) == 0) then
            local fontList = FontManager:GetFontList()
            if inp == InEmojiFont and fontList["Segoe UI Emoji"] then
                inp:SetSource(Text("Segoe UI Emoji"), time)
            else
                inp:SetSource(Text("Open Sans"), time)
            end
        end
    elseif (inp == InFontStyle) or (inp == InEmojiFontStyle) then
        local f = param.Value
        if f == nil or string.len(f) == 0 then
            inp:SetSource(Text("Regular"), time)
        end
    elseif inp == InText then
        local f = param.Value
        if f == nil or string.len(f) == 0 then
            InText:SetSource(Text("Sample"), time)
        end
    elseif inp == InColorTarget then
        if param.Value ~= 0 and InOutlineColorType:GetSource(time).Value == 2 then -- Custom
            inp:SetSource(Number(0), time)                                         -- Inner
        end
    elseif inp == InOutlineColorType then
        if param.Value == 2 then -- Custom
            InR2:SetAttrs({ IC_Visible = true })
            InG2:SetAttrs({ IC_Visible = true })
            InB2:SetAttrs({ IC_Visible = true })
            InA2:SetAttrs({ IC_Visible = true })
            InR3:SetAttrs({ IC_Visible = true })
            InG3:SetAttrs({ IC_Visible = true })
            InB3:SetAttrs({ IC_Visible = true })
            InA3:SetAttrs({ IC_Visible = true })
            if InColorTarget:GetSource(time).Value ~= 0 then
                InColorTarget:SetSource(Number(0), time) -- Inner
            end
        else
            InR2:SetAttrs({ IC_Visible = false })
            InG2:SetAttrs({ IC_Visible = false })
            InB2:SetAttrs({ IC_Visible = false })
            InA2:SetAttrs({ IC_Visible = false })
            InR3:SetAttrs({ IC_Visible = false })
            InG3:SetAttrs({ IC_Visible = false })
            InB3:SetAttrs({ IC_Visible = false })
            InA3:SetAttrs({ IC_Visible = false })
        end
    elseif inp == InFittingTop then
        if 0 < param.Value then
            local x = (1 - InFittingPaddingWidth:GetSource(time).Value) / 2
            local y = (1 - InFittingPaddingHeight:GetSource(time).Value) / 2
            if param.Value == 1 then                 -- Top Left
                InAlign:SetSource(Number(0), time)   -- Top
                InJustify:SetSource(Number(0), time) -- Left
                InOffset:SetSource(Point(0 + x, 1 - y), time)
            elseif param.Value == 2 then             -- Top Center
                InAlign:SetSource(Number(0), time)   -- Top
                InJustify:SetSource(Number(1), time) -- Center
                InOffset:SetSource(Point(0.5, 1 - y), time)
            elseif param.Value == 3 then             -- Top Right
                InAlign:SetSource(Number(0), time)   -- Top
                InJustify:SetSource(Number(2), time) -- Right
                InOffset:SetSource(Point(1 - x, 1 - y), time)
            end
        end
    elseif inp == InFittingMiddle then
        if 0 <= param.Value then
            local x = (1 - InFittingPaddingWidth:GetSource(time).Value) / 2
            local y = (1 - InFittingPaddingHeight:GetSource(time).Value) / 2
            if param.Value == 1 then                 -- Middle Left
                InAlign:SetSource(Number(1), time)   -- Middle
                InJustify:SetSource(Number(0), time) -- Left
                InOffset:SetSource(Point(0 + x, 0.5), time)
            elseif param.Value == 2 then             -- Middle Center
                InAlign:SetSource(Number(1), time)   -- Middle
                InJustify:SetSource(Number(1), time) -- Center
                InOffset:SetSource(Point(0.5, 0.5), time)
            elseif param.Value == 3 then             -- Middle Right
                InAlign:SetSource(Number(1), time)   -- Middle
                InJustify:SetSource(Number(2), time) -- Right
                InOffset:SetSource(Point(1 - x, 0.5), time)
            end
        end
    elseif inp == InFittingBottom then
        if 0 <= param.Value then
            local x = (1 - InFittingPaddingWidth:GetSource(time).Value) / 2
            local y = (1 - InFittingPaddingHeight:GetSource(time).Value) / 2
            if param.Value == 1 then                 -- Bottom Left
                InAlign:SetSource(Number(2), time)   -- Bottom
                InJustify:SetSource(Number(0), time) -- Left
                InOffset:SetSource(Point(0 + x, 0 + y), time)
            elseif param.Value == 2 then             -- Bottom Center
                InAlign:SetSource(Number(2), time)   -- Bottom
                InJustify:SetSource(Number(1), time) -- Center
                InOffset:SetSource(Point(0.5, 0 + y), time)
            elseif param.Value == 3 then             -- Bottom Right
                InAlign:SetSource(Number(2), time)   -- Bottom
                InJustify:SetSource(Number(2), time) -- Right
                InOffset:SetSource(Point(1 - x, 0 + y), time)
            end
        end
    elseif inp == InEmojiFontEnabled then
        if param.Value == 1 then
            InEmojiFont:SetAttrs({ IC_Visible = true })
            InEmojiFontStyle:SetAttrs({ IC_Visible = true })
            InEmojiSize:SetAttrs({ IC_Visible = true })
            InEmojiTracking:SetAttrs({ IC_Visible = true })
        else
            InEmojiFont:SetAttrs({ IC_Visible = false })
            InEmojiFontStyle:SetAttrs({ IC_Visible = false })
            InEmojiSize:SetAttrs({ IC_Visible = false })
            InEmojiTracking:SetAttrs({ IC_Visible = false })
        end
    elseif inp == InCustomEmojiOutline then
        if param.Value == 0 then -- unchecked
            InEmojiOutlineNum:SetAttrs({ IC_Visible = true })
        else
            InEmojiOutlineNum:SetAttrs({ IC_Visible = false })
        end
    end
end
