--[[-- 
Auto Outline Color Text
--]]--

--******************************************************************************************************

local sUnicodeArray = {}
local sInnerColor = Pixel{R = 0, G = 0, B = 0, A = 1.0}
local sOuter1Color = Pixel{R = 0, G = 0, B = 0, A = 1.0}
local sOuter2Color = Pixel{R = 0, G = 0, B = 0, A = 1.0}

local function Utf8StrToUtf32Array(utf8str)
    local utf16bytes = {}
    local utf32bytes = {}
    local line = 1

    if utf8str and (0 < #utf8str) then
        utf16bytes[line] = {}
        local i = 1
        while i <= #utf8str do
            local c = utf8str:byte(i)
            if c == 0x0A then
                line = line + 1
                utf16bytes[line] = {}
                i = i + 1
            elseif c < 0x80 then
                table.insert(utf16bytes[line], 0)
                table.insert(utf16bytes[line], c)
                i = i + 1
            elseif c < 0xE0 then
                local c2 = utf8str:byte(i + 1)
                local u = bit.bor(bit.lshift(bit.band(c, 0x1F), 6), bit.band(c2, 0x3F))
                table.insert(utf16bytes[line], bit.rshift(u, 8))
                table.insert(utf16bytes[line], bit.band(u, 0xFF))
                i = i + 2
            elseif c < 0xF0 then
                local c2 = utf8str:byte(i + 1)
                local c3 = utf8str:byte(i + 2)
                local u = bit.bor(bit.lshift(bit.band(c, 0x0F), 12), bit.lshift(bit.band(c2, 0x3F), 6), bit.band(c3, 0x3F))
                table.insert(utf16bytes[line], bit.rshift(u, 8))
                table.insert(utf16bytes[line], bit.band(u, 0xFF))
                i = i + 3
            else
                local c2 = utf8str:byte(i + 1)
                local c3 = utf8str:byte(i + 2)
                local c4 = utf8str:byte(i + 3)
                local u = bit.bor(bit.lshift(bit.band(c, 0x07), 18), bit.lshift(bit.band(c2, 0x3F), 12), bit.lshift(bit.band(c3, 0x3F), 6), bit.band(c4, 0x3F))
                u = u - 0x10000
                local high = bit.bor(0xD800, bit.rshift(u, 10))
                local low = bit.bor(0xDC00, bit.band(u, 0x3FF))
                table.insert(utf16bytes[line], bit.rshift(high, 8))
                table.insert(utf16bytes[line], bit.band(high, 0xFF))
                table.insert(utf16bytes[line], bit.rshift(low, 8))
                table.insert(utf16bytes[line], bit.band(low, 0xFF))
                i = i + 4
            end
        end

        for line = 1, #utf16bytes do
            utf32bytes[line] = {}
            local i = 1
            while i <= #utf16bytes[line] do
                local b1 = utf16bytes[line][i]
                local b2 = utf16bytes[line][i + 1]
                local code_unit = bit.bor(bit.lshift(b1, 8), b2)
                if code_unit >= 0xD800 and code_unit <= 0xDBFF then
                    -- High surrogate
                    local b3 = utf16bytes[line][i + 2]
                    local b4 = utf16bytes[line][i + 3]
                    local low_surrogate = bit.bor(bit.lshift(b3, 8), b4)
                    local code_point = bit.bor(bit.lshift(bit.band(code_unit, 0x3FF), 10), bit.band(low_surrogate, 0x3FF)) + 0x10000
                    table.insert(utf32bytes[line], code_point)
                    i = i + 4
                else
                    -- Non-surrogate
                    table.insert(utf32bytes[line], code_unit)
                    i = i + 2
                end
            end
        end
    end

    return utf32bytes
end

local function rgbToHsv(r, g, b)
    local max = math.max(r, g, b)
    local min = math.min(r, g, b)
    local h, s, v = 0, 0, max

    local d = max - min
    s = max == 0 and 0 or d / max

    if max == min then
        h = 0 -- achromatic
    else
        if max == r then
            h = (g - b) / d + (g < b and 6 or 0)
        elseif max == g then
            h = (b - r) / d + 2
        elseif max == b then
            h = (r - g) / d + 4
        end
        h = h / 6
    end

    return h, s, v
end

local function hsvToRgb(h, s, v)
    local r, g, b

    local i = math.floor(h * 6)
    local f = h * 6 - i
    local p = v * (1 - s)
    local q = v * (1 - f * s)
    local t = v * (1 - (1 - f) * s)

    i = i % 6

    if i == 0 then
        r, g, b = v, t, p
    elseif i == 1 then
        r, g, b = q, v, p
    elseif i == 2 then
        r, g, b = p, v, t
    elseif i == 3 then
        r, g, b = p, q, v
    elseif i == 4 then
        r, g, b = t, p, v
    elseif i == 5 then
        r, g, b = v, p, q
    end

    return r, g, b
end

local function getLuminance(r, g, b)
    local function channelLuminance(channel)
        if channel <= 0.03928 then
            return channel / 12.92
        else
            return ((channel + 0.055) / 1.055) ^ 2.4
        end
    end

    return 0.2126 * channelLuminance(r) + 0.7152 * channelLuminance(g) + 0.0722 * channelLuminance(b)
end

local function calculateContrastRatio(color1, color2)
    local lum1 = getLuminance(color1.R, color1.G, color1.B)
    local lum2 = getLuminance(color2.R, color2.G, color2.B)

    if lum1 > lum2 then
        return (lum1 + 0.05) / (lum2 + 0.05)
    else
        return (lum2 + 0.05) / (lum1 + 0.05)
    end
end

local function adjustLuminanceForContrast(color)
    local step = 0.5
    local maxAttempts = (1 / step)

    local testColor = {R = 0, G = 0, B = 0}
    local bestH, bestS, bestV = 0, 0, 1
    local bestContrast = 0

    for i = 0, maxAttempts do
        local newV = 1.0 - (step * i)
        if newV >= 0 and newV <= 1 then
            testColor.R, testColor.G, testColor.B = hsvToRgb(bestH, bestS, newV)
            local contrast = calculateContrastRatio(color, testColor)
            if contrast > bestContrast then
                bestContrast = contrast
                bestV = newV
            end
        end
    end
    local bestR, bestG, bestB = hsvToRgb(bestH, bestS, bestV)
    
    return Pixel{R = bestR, G = bestG, B = bestB, A = color.A} -- Return the color with the highest contrast found
end

local function getClosestContrastingColor(color)
    local targetHue, _, _ = rgbToHsv(color.R, color.G, color.B)
    local bestColor = nil
    local bestContrast = 0

    for i = 0, 360, 1 do
        local testColor = {R = 0, G = 0, B = 0}
        testColor.R, testColor.G, testColor.B = hsvToRgb(i / 360, 1, 1)
        local contrast = calculateContrastRatio(color, testColor)
        if contrast >= 7 and (bestColor == nil or math.abs(i / 360 - targetHue) < math.abs(bestColor.Hue - targetHue)) then
            bestColor = testColor
            bestColor.Hue = i / 360
            bestContrast = contrast
        end
    end

    return bestColor
end

local function resetXpos(matrix, lineWidth, justify)
    local offset = 0
    if justify == 0 then
        offset = -lineWidth
    elseif justify == 1 then
        offset = -(lineWidth / 2)
    elseif justify == 2 then 
        offset = 0
    end

    matrix:Move(offset, 0, 0)
end

local function drawstring(img, font, style, size, justify, quality, x, y, color, text, thinckness, outlineNum)
    local ic = ImageChannel(img, quality) 
    local fs = FillStyle()

    ic:SetStyleFill(fs)
    
    -- get the fonts metrics (see http://freetype.sourceforge.net/freetype2/docs/glyphs/index.html for a great guide)
    local tfm = TextStyleFontMetrics(TextStyleFont(font, style))
    
    -- This is the distance between this line and the next one. 
    local line_height = (tfm.TextAscent + tfm.TextDescent + tfm.TextExternalLeading) * 10 * size 
    local x_move = 0
    
    local mat = Matrix4()
            
    mat:Scale(1.0/tfm.Scale, 1.0/tfm.Scale, 1.0)
    mat:Scale(size, size, 1)

    local shapeNormal = Shape()
    local shapeOutline1 = Shape()
    local shapeOutline2 = Shape()
    mat:Move(x, y, 0)
    
    -- split the text into separate lines
    for line = 1, #sUnicodeArray do
        local unicodeArray = sUnicodeArray[line]
        local lineWidth = getLineDrawWidth(unicodeArray, font, style, size)
        
        if justify == 0 then
            mat:Move(0, 0, 0)
        elseif justify == 1 then
            mat:Move(-(lineWidth/2), 0, 0)
        elseif justify == 2 then 
            mat:Move(-lineWidth, 0, 0)
        end
    
        local xPos = 0
        local firstCharcterWidth = 0
        for i = 1, #unicodeArray do
            local charcterCode = unicodeArray[i]
            
            local width = tfm:CharacterWidth(charcterCode) * 10 * size

            -- if this is not the first character, apply kerning
            if 1 < i  then
                local prevChar = unicodeArray[i - 1]
                -- local xOffset = tfm:CharacterKerning(prevChar, charcterCode) * 10 * size
                local xOffset = tfm:CharacterKerning(0x32, 0x32) * 10 * size
                mat:Move(xOffset, 0, 0)
                xPos = xPos + xOffset
            end

            -- move the cursor to the center of the character
            mat:Move(width/2, 0, 0)

            -- get the shape of the character
            local charcteShape = tfm:GetCharacterShape(charcterCode, false)
            if charcteShape then
                local base = charcteShape:TransformOfShape(mat)
                shapeNormal:AddShape(base)
                local outline1 = base:OutlineOfShape(thinckness * size, "OLT_Solid", "OJT_Round", 8, "SWM_Normal", 8)
                shapeOutline1:AddShape(outline1)
                local outline2 = base:OutlineOfShape(thinckness * 2 * size, "OLT_Solid", "OJT_Round", 8, "SWM_Normal", 8)
                shapeOutline2:AddShape(outline2)
            end

            -- move the cursor to the end of the character
            xPos = xPos + width
            mat:Move(width/2, 0, 0)
        end
        
        -- line end, move the cursor back to the start
        resetXpos(mat, lineWidth, justify)
        mat:Move(0, -line_height, 0)
    end
    
    local cs = ChannelStyle()
    if outlineNum >= 2 then
        -- print("R: "..sOuter2Color.R.." G: "..sOuter2Color.G.." B: "..sOuter2Color.B.." A: "..sOuter2Color.A)
        cs.Color = sOuter2Color
        ic:ShapeFill(shapeOutline2)
        ic:PutToImage("CM_Merge", cs)
    end
    if outlineNum >= 1 then
        -- print("R: "..sOuter1Color.R.." G: "..sOuter1Color.G.." B: "..sOuter1Color.B.." A: "..sOuter1Color.A)
        cs.Color = sOuter1Color
        ic:ShapeFill(shapeOutline1)
        ic:PutToImage("CM_Merge", cs)
    end
    -- print("R: "..sInnerColor.R.." G: "..sInnerColor.G.." B: "..sInnerColor.B.." A: "..sInnerColor.A)
    cs.Color = sInnerColor
    ic:ShapeFill(shapeNormal)
    ic:PutToImage("CM_Merge", cs)
end


FuRegisterClass("AutoOutlineColorText", CT_Tool, {
    REGS_Name             = "Auto Outline Color Text",
    REGS_Category         = "Fuses\\Mug\\Text",
    REGS_OpIconString     = "AOCT",
    REGS_OpDescription    = "Auto Outline Color Text",
    REGS_HelpTopic        = "https://x.com/MugLab3", --This can be a URL
    REGS_URL              = "https://www.youtube.com/@MugLabVideoEditing",
    REGS_IconID           = "Icons.Tools.Icons.Example",-- This can be Inline as an array of Values
    REG_OpNoMask          = false,
    REG_NoBlendCtrls      = false,
    REG_NoObjMatCtrls     = true,
    REG_NoMotionBlurCtrls = true,
    REG_Fuse_NoEdit       = false,
    REG_Fuse_NoReload     = false,
    REG_SupportsDoD       = true,
    REG_NoPreCalcProcess  = false,
    REG_Version           = 1, 
})

function Create()
    local groupId = 0;

    self:BeginControlNest("Text", "TextLabel", true);

    InPosition = self:AddInput("Position", "Position", {
        LINKID_DataType      = "Point",
        INPID_InputControl   = "OffsetControl",
        INPID_PreviewControl = "CrosshairControl",
        })

    InText = self:AddInput("Text", "Text", {
        LINKID_DataType     = "Text",
        INPID_InputControl  = "TextEditControl",
        TEC_Lines           = 5,
        INP_DoNotifyChanged = false,
    })
    
    -- Font group
    groupId = groupId +1;

    InFont = self:AddInput("Font", "Font", {
        LINKID_DataType     = "Text",
        INPID_InputControl  = "FontFileControl",
        IC_ControlGroup     = groupId,
        IC_ControlID        = 0,
        INP_Level           = 1,
        INP_DoNotifyChanged = true,
    })
        
    InFontStyle = self:AddInput("FontStyle", "FontStyle", {
        LINKID_DataType     = "Text",
        INPID_InputControl  = "FontFileControl",
        IC_ControlGroup     = groupId,
        IC_ControlID        = 1,
        INP_Level           = 1,
        INP_DoNotifyChanged = true,
    })

    InSize = self:AddInput("Size", "Size", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "SliderControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 0.5,
        INP_Default        = 0.08,
    })

    self:EndControlNest()


    self:BeginControlNest("Anchor position", "AnchorPositionLabel", true);

    InJustify = self:AddInput("Justification", "Justification", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "MultiButtonControl",
        INP_Default        = 1,
        { MBTNC_AddButton  = "Left",   MBTNCD_ButtonWidth = 1/3, },
        { MBTNC_AddButton  = "Center", MBTNCD_ButtonWidth = 1/3, },
        { MBTNC_AddButton  = "Right",  MBTNCD_ButtonWidth = 1/3, },
        INP_Integer = true,
        })

    InAlign = self:AddInput("Alignment", "Alignment", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "MultiButtonControl",
        INP_Default        = 1,
        { MBTNC_AddButton  = "Top",   MBTNCD_ButtonWidth = 1/3, },
        { MBTNC_AddButton  = "Center", MBTNCD_ButtonWidth = 1/3, },
        { MBTNC_AddButton  = "Bottom",  MBTNCD_ButtonWidth = 1/3, },
        INP_Integer = true,
    })
    
    self:EndControlNest()

           
    self:BeginControlNest("Main Color", "MainColorLabel", true);
    
    InColorTarget = self:AddInput("Target", "ColorTarget", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "MultiButtonControl",
        INP_Default        = 0,
        { MBTNC_AddButton  = "Inner", MBTNCD_ButtonWidth = 1/2, },
        { MBTNC_AddButton  = "Outer", MBTNCD_ButtonWidth = 1/2, },
        INP_Integer = true,
    })

    InR = self:AddInput("Red", "Red", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = 1,
        IC_ControlID       = 0,  -- Red ID
        })
        
    InG = self:AddInput("Green", "Green", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        IC_ControlGroup    = 1,
        IC_ControlID       = 1,  -- Green ID
        })
        
    InB = self:AddInput("Blue", "Blue", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        IC_ControlGroup    = 1,
        IC_ControlID       = 2,  -- Blue ID
        })
        
    InA = self:AddInput("Alpha", "Alpha", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        IC_ControlGroup    = 1,
        IC_ControlID       = 3,  -- Alpha ID
        })

    self:EndControlNest()
    
    self:BeginControlNest("Outline", "OutlineLabel", true);

    InOutlineNum = self:AddInput("Num", "OutlineNum", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "SliderControl",
        INP_MinScale       = 0,
        INP_MaxScale       = 2,
        INP_Default        = 1,
        INP_MinAllowed     = 0,
        INP_MaxAllowed     = 2,
        INP_Integer = true,
    })
    
    InOutlineThickness = self:AddInput("Tickness", "OutlineTickness", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "SliderControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 0.1,
        INP_Default        = 0.08,
    })

    self:EndControlNest()

    InImage = self:AddInput("Input", "Input", {
        LINKID_DataType = "Image",
        LINK_Main       = 1,
        })

            
    OutImage = self:AddOutput("Output", "Output", {
        LINKID_DataType = "Image",
        LINK_Main       = 1,
        })	
end

function OnAddToFlow()
    -- print("OnAddToFlow")
end

function PreCalcProcess (req)
    -- print("PreCalcProcess")
    local text = InText:GetValue(req).Value
    sUnicodeArray = Utf8StrToUtf32Array(text)

    local r = InR:GetValue(req).Value
    local g = InG:GetValue(req).Value
    local b = InB:GetValue(req).Value
    local a = InA:GetValue(req).Value
    if InColorTarget:GetValue(req).Value == 0 then
        sInnerColor = Pixel{R = r, G = g, B = b, A = a}
        sOuter1Color = adjustLuminanceForContrast(sInnerColor)
        sOuter2Color = adjustLuminanceForContrast(sOuter1Color)
    else
        sOuter1Color = Pixel{R = r, G = g, B = b, A = a}
        sInnerColor = adjustLuminanceForContrast(sOuter1Color)
        sOuter2Color = adjustLuminanceForContrast(sOuter1Color)
    end

    local img = InImage:GetValue(req)
    local dod = req:GetInputDoD(InImage)
	-- print("Input DoD:   ", dod, dod:ValidWidth().."x"..dod:ValidHeight())
	-- print("Request ROI: ", "not available during PreCalc")
	local datawnd = dod:Intersect(img.DataWindow)
	local out = Image({
		IMG_Like = img,
		IMG_DataWindow = datawnd,
		IMG_ValidWindow = nil,
		IMG_NoData = true,
		})
    OutImage:Set(req, out)
end

local bit = require("bit")



function getLineDrawWidth(unicodeArray, font, style, size)
    local lineWidth = 0
    
    local tfm = TextStyleFontMetrics(TextStyleFont(font, style))
    for i = 1, #unicodeArray do
        -- add the kerning between this character and the previous one
        if 1 < i then
            local kerning = tfm:CharacterKerning(unicodeArray[i - 1], unicodeArray[i]) * 10 * size
            lineWidth = lineWidth + kerning
        end
        -- add the width of the character
        lineWidth = lineWidth + tfm:CharacterWidth(unicodeArray[i]) * 10 * size
    end
    
    return lineWidth
end



function Process(req)
    local img = InImage:GetValue(req)
    local font = InFont:GetValue(req).Value
    local style = InFontStyle:GetValue(req).Value
    local roi = req:GetRoI()
    local out = img:CopyOf()
    
    local text      = InText:GetValue(req).Value
    local size      = InSize:GetValue(req).Value
    local center    = InPosition:GetValue(req)
    local justify	= InJustify:GetValue(req).Value
    local r         = InR:GetValue(req).Value
    local g         = InG:GetValue(req).Value
    local b         = InB:GetValue(req).Value
    local a         = InA:GetValue(req).Value

    local thickness = InOutlineThickness:GetValue(req).Value
    local outlineNum = InOutlineNum:GetValue(req).Value
    
    local cx = center.X
    local cy = center.Y * (out.Height * out.YScale) / (out.Width * out.XScale)
    local quality = 32
    if req:IsQuick() then 
        quality = 1
    end
    
    -- if the FontManager list is empty, scan the font list
    -- If the UI has never been shown, as would always be the case on a render node, 
    -- nothing will scan the font list for available fonts. So we check for that here, 
    -- and force a scan if needed.
    if not next( FontManager:GetFontList() ) then
        FontManager:ScanDir()
    end

    -- the drawstring function is doing all the heavy lifting 
    drawstring(
        out, 
        font,
        style,
        size,
        justify,
        quality,
        cx,
        cy,
        Pixel{R=r,G=g,B=b,A=a},
        text,
        thickness,
        outlineNum
    )
    
    OutImage:Set(req, out)
end

function NotifyChanged(inp, param, time)
    -- when the tools FontFileControl is first created, the FontManager has not yet 
    -- provided a FontList, so we can't set a default value. Instead we do it here.
    if inp == InFont then
        local f = param.Value
        
        if f == nil or string.len(f) == 0 then
            InFont:SetSource(Text("Open Sans"), time)
        end
    elseif inp == InFontStyle then
        local f = param.Value
        
        if f == nil or string.len(f) == 0 then
            InFontStyle:SetSource(Text("Regular"), time)
        end
    elseif inp == InText then
        local f = param.Value
        if f == nil or string.len(f) == 0 then
            InText:SetSource(Text("Sample"), time)
        end
    end
end

