# ハーフトーンエフェクトにおけるアンチエイリアス処理の目的と仕組み

`MugAdvancedHalftone.fuse` において、ドットの境界線を滑らかに描画するための**「アンチエイリアス処理（Anti-Aliasing）」**がどのように実装されているのか、その目的と数学的な計算ロジックを解説します。

---

## 1. アンチエイリアス処理の目的：ジャギー（ギザギザ）の解消

コンピューターのモニターは四角いピクセル（画素）の集まりであるため、プログラムで単純に「円」を描画しようとすると、ピクセルがマス目に沿って階段状に並んだ**「ジャギー（ギザギザの輪郭）」**が発生してしまいます。

特にハーフトーンエフェクトのように、画面上に無数の小さな図形（ドット）を敷き詰める処理の場合、このジャギーが高周波ノイズとなり、映像がチラチラと不快に瞬く（モアレやピクセル干渉）大きな原因となります。これを防ぎ、印刷物のような滑らかな輪郭を持つドットを描画するために、ドットの境界線をピクセル単位で滑らかなグラデーション（半透明）へと変換する局所的な処理が導入されています。

### 【重要】本エフェクトにおけるAAの対象（単体ドットの輪郭）
ここで最も勘違いしやすいポイントですが、本エフェクトにおけるアンチエイリアスは**「個々のドット（円や四角など）単体の図形エッジに対する処理」**です。

複数のドットの並びによって構成される「画像全体の斜め線のジャギー」をぼかして滑らかにしようとする、画面全体に対する空間的なAA（Spatial AA）ではありません。もし空間的なAAをかけてしまうと、せっかくの「点の大小で表現する」というハーフトーンエフェクトそのものがただのボヤけた映像に潰れてしまいます（それはもはやハーフトーンではありません）。

あくまで「1つ1つのドットの幾何学的な形状」を美しく保つための局所的な処理であると認識してください。

---

## 2. どのように解決しているのか（実現手法）

### マルチサンプリング（MSAA）の問題点
一般的な3DCGやゲームなどでは、1つのピクセル内で「少しずつズラした複数の場所（サブピクセル）」を何度もサンプリングし、その平均色を取ることで境界を滑らかにする「マルチサンプリング（MSAAなど）」という手法がよく使われます。

現代のGPUであればMSAAもリアルタイムで処理可能ですが、本エフェクトにおいては**「真円や直線といった単純な数学図形を描画するだけであれば、そこまで複雑で負荷のかかるサンプリング処理は必要ない」**というアプローチを取っています。
動画編集ソフト（DaVinci Resolve）内では、他にもカラーグレーディングや合成など無数の重い処理が同時に走るため、1つのエフェクトの計算負荷（GPUリソース）は徹底して抑え、他の処理にリソースを譲れるように設計することが重要だからです。

### 距離関数（SDF: Signed Distance Field）による数学的解決
本プログラムでは、追加のサンプリング処理を一切行わず、**「ピクセルとドットの中心との数学的な距離」**をそのまま利用して、境界の不透明度（アルファ値/カバレッジ値）を計算する手法を採用しています。

この手法を用いれば、ピクセルごとにたった1回の距離計算（数式）を走らせるだけで、いかなる解像度やドットサイズであっても完璧に滑らかな境界線を描画でき、極めて高いパフォーマンスを維持できます。

### 距離ベースAAの根本的な特徴と視覚的な影響（ドットの縮小）
本プログラムにおける距離を利用したアンチエイリアスの実装には、**「輪郭を滑らかにするほど、ドット自体が本来の計算サイズよりも少し小さく見える」**という根本的な視覚的特徴があります。

これは、本エフェクトのAAが「設定されたドットの本来の境界線（半径）」を基準とし、**そこから図形の内側にむかって半透明のグラデーション（削り取り）を作っていくアプローチ**を採用しているためです。
外側ににじみ出させるのではなく内側を透過させる処理であるため、AA（Softness）を強く設定すればするほど、図形の実体（完全に不透明な黒の芯）の面積が減少し、結果としてユーザーの目には「ドットが一回り小さくなった」ように映ります。

この特性により、ドットが膨張しても隣と不必要に癒着しづらい反面、AAを極端に強くすると全体の画像が全体的に明るく（インク量が少なく）見える現象が起きます。

---

## 3. アンチエイリアス計算の具体的なステップ (`checkCellDot` 関数)

実際に `RenderDotsKernel` 内で、「中心からの距離（`dist`）」をもとにピクセルの不透明度がどのように計算されているか順を追って解説します。

### 3-1. 境界幅（aaEdgeWidth）の決定と「セルピッチ」への依存
まず、「輪郭を何ピクセル分ぼかすか（グラデーションにする幅）」の基準を決めますが、ここで**「現在の画面解像度に基づくドット同士の間隔（セルピッチ）」**を掛け合わせて動的に `aaEdgeWidth`（アンチエイリアス幅）を算出します。

```lua
-- Lua側での計算例
aaEdgeWidth = aaSoftness * cellPitchX
```

**なぜ固定のピクセル数ではなく、セルピッチ（マス目の大きさ）に依存させるのか？**
もしアンチエイリアスの幅を「常に絶対値の2ピクセル」などと固定してしまうと、以下のような致命的な視覚的破綻が起きます。
*   **ドットが非常に大きい（密度が低い）時:** 直径が100pxもある巨大なドットに対してフチのぼかしが2pxしかないと、相対的に境界線がカリカリに尖って見え、不自然でジャギーな印象を与えてしまいます。
*   **ドットが極小（密度が高い）時:** 直径が3pxしかない極小ドットに対して2pxのぼかしを与えると、ドット全体が完全に削り取られて視界から消え去るか、ただの薄いグレーのシミになってしまいます。

そのため、ユーザーが設定した「Softness（柔らかさ）」のパラメータを「マス目の大きさ（セルピッチ）」に対する**相対的な比率（パーセンテージ）**として掛け合わせることで、ドットが巨大化した時も極小まで縮んだ時も、常に「図形に対する同じ割合の滑らかさ」が視覚的に担保されるように設計されています。

### 3-2. 不透明度の判定分岐（距離に基づく3ステート）
各ピクセルに対する最終的な不透明度（0.0〜1.0）は、算出した「ピクセルからドット中心までの距離（`dist`）」と「設定されたドットの本来の半径（`dotRadius`）」を使用して、以下の3つの状態に分類・処理されます。

*   **状態A: 完全に境界の外側（透明）**
    距離が本来の半径以上であれば、そのピクセルは完全にドットの外側にあります。
    ```c
    if (dist >= dotRadius)
        return 0.0f; // 不透明度0%
    ```

*   **状態B: 完全に境界の内側（完全被覆）**
    「本来の半径」から「アンチエイリアス幅」を引いた内側の円を `innerRadius` と定義します。
    距離がこの `innerRadius` 以下であれば、そのピクセルは中心の中心核（真っ黒な部分）に属します。
    ```c
    const float innerRadius = _fmaxf(dotRadius - aaEdgeWidth, 0.0f);
    if (dist <= innerRadius)
        return 1.0f; // 不透明度100%
    ```

*   **状態C: 境界線のぼかしエリア内部（グラデーション補間）**
    距離が状態Aと状態Bの間（つまり境界線のフチ部分）に位置するピクセルに対してのみ、最終的なアンチエイリアス計算が行われます。

    ここまでの距離情報は以下の式に当てはめられ、ピクセルが境界線上で「どれくらい外側に寄っているか」の割合が計算されます。
    ```c
    const float t = (dotRadius - dist) / aaEdgeWidth;
    return _saturatef(t); // 不透明度を0.0～1.0の範囲で返す
    ```

    **【具体例：計算式に数値を当てはめた場合】**
    * 設定された半径 `dotRadius` = 10.0 ピクセル
    * 輪郭のぼかし幅 `aaEdgeWidth` = 2.0 ピクセル
    * 対象ピクセルの距離 `dist` = 9.0 ピクセル の場合

    式: `(10.0 - 9.0) / 2.0` = `1.0 / 2.0` = **`0.5`**
    結果、この境界線上のピクセルは **不透明度0.5（50%のグレー/半透明）** という中間の値を返し、階段状のジャギーを視覚的に埋める非常に滑らかなグラデーションとして描画されます。

## まとめ

本プログラムのアンチエイリアス処理は、計算負荷の高い複数回のサンプリングに頼ることなく、**「ドットの中心からの距離」を直接グラデーションの強さに変換する数学的アプローチ（解析的アンチエイリアス）**を用いています。

これにより、高解像度の動画処理においても、ジャギーやチラつきのない美しく高品質なハーフトーンドットをリアルタイムで生成することが可能になっています。
