# ドット間干渉（重なり合い）における優先順位判定の目的と仕組み

`MugAdvancedHalftone.fuse` において、**「カバレッジ判定（距離に基づく優先度チェック）」**という仕組みがなぜ導入されているのか、その目的と計算ロジックを解説します。

---

## 1. 目的：ドット同士の重なり（干渉）の解決

ハーフトーンにおいて、画像が暗い部分（影など）ではドットの半径が大きくなり、隣のマス目のドットと境界を越えて**重なり合う**状態が発生します。さらに、Positionジッター（位置ずれ）を利用した場合には、明るい部分であっても偶然ドット同士が重なることがあります。

もし単純に「左上のマスから順番にドットを描画（上書き）していく」というプログラムを組むと、後から描いたドットが先のドットの「滑らかな円のフチ（アンチエイリアス部分）」を四角く上書きしてしまい、**いびつな欠けた形状のドット**が画面にあふれてしまいます。

これを防ぐため、各ピクセルを描画する際に**「複数のドットが重なり合った時、どのマスのドットの中心に最も近いか（どれを採用すれば一番美しく自然か）」**をピクセル単位で比較し、最適なものを選択するための判定システム（`updateBestCell`）が存在しています。

> **[補足: CG用語における Coverage（カバレッジ/被覆率）]**
> 本ドキュメントでは直感的な理解のために「ドットの中心からの距離に基づく不透明度合」と表現していますが、3DCGやシェーダープログラミングの世界では、幾何学的な図形がピクセル領域をどれだけの割合で覆っているか（どのくらい内部に含まれているか）を示すこの指標を一般的に **Coverage（カバレッジ・被覆率）** と呼びます。本プログラム内の変数名 `bestCoverage` などもこの用語に従っています。

---

## 2. どのように解決しているのか（実現手法）

「後から上書きしていびつな形になる」現象を防ぐため、GPUは各ピクセルを描画する際、**「自身の周囲（最大9マス）に存在する各ドットの中心からの距離を測る」**ことで、そのピクセルがどのドットに最も強く影響されるべきか（不透明度や所属度合い）を計算します。

そして、複数のマス目のドットが重なる場合、以下の優先度のルールに従って**不透明度が高く、かつドットの中心に最も近いマスの色を、そのピクセルの最終出力として採用（BestCellの更新）**します。

### 判定の優先順位（`updateBestCell` ロジック）

1. **ドットの中心に近い（不透明度が高い）マスを優先**
   * 例：「ドットAのフチの薄い部分（中心から遠い）」と、「ドットBの真っ黒な中心部分（中心に近い）」が重なった場合、より中心に近いドットBが採用されます。
   * これにより、「後から計算された薄いフチ」が「すでに描画されている真っ黒な既存のドット」を上塗りしていびつに欠ける現象を防ぎます。

2. **中心からの距離（不透明度）が全く同じ（真っ黒な領域同士）の場合、より「画像の暗さ（Strength）」が強いドットを優先**
   * エッジが完全に結合する重なり合いの中で、どちらのドットの色（Color）を最終採用するかを決めるルールです。
   * これにより、色が違うドット同士が重なり合っても、境界線が自然に強い色側にブレンドされます。

---

## 3. 「中心からの距離」計算の具体的なステップ (`checkCellDot` 関数)

具体的に、各ピクセルがドットの中心からどれだけ近いか（不透明度：0.0〜1.0）という数値をどのように判定しているのか順を追って解説します。（※位置ジッターやサイズ設定などは、すべて事前に行われた状態の座標データを受け取って計算されます）

### 3-1. バウンディングボックスによる足切り（高速化のため）
自身のマス目と周囲8マス（計9マス）すべてに対して詳細な距離計算を行うのは非常に負荷が高いため、最初に「絶対にドットに届かないピクセル」を四角形の境界（バウンディングボックス）で判定し、対象外の場合は素早く `0.0f` を返して処理を短絡します。

このバウンディングボックスのサイズ（`bbSize`）は、以下の3つの要素を足し合わせて計算されます：
1. **`dotRadius`**: そのマス目に描画予定の、元の画像明度などに影響されたドット自体の本来の半径
2. **`BOUNDING_BOX_MARGIN`**: 余裕を持たせるための安全マージン（プログラム内で定数 `1.0f` ピクセル加算など）
3. **`aaEdgeWidth`**: アンチエイリアス（ぼかし）によってドットの輪郭が外側に広がる分の幅

ピクセルとドット中心のX軸・Y軸の距離が、どちらか一方でもこの `bbSize` を超えていれば、そのピクセルは絶対にドット（およびそのぼかし領域）に含まれることはないと確定し、カバレッジはゼロになります。

### 3-2. アスペクト比（縦横比）の適用
ドットを縦長や横長に変形させる際、ドットの半径自体を直接引き伸ばすとマス目からはみ出し、隣のバウンディングボックスの描画判定をも狂わせてしまいます。そこでここでは**「ピクセルとドット中心の距離を測るスケール（物差し）」の方を変更**します。

実際のソースコード（`checkCellDot`関数内）では以下のように実装されています：
```c
float2 measureDiff = absDiff; // ここまで計算したX,Yの距離
// 縦横のアスペクト比率（finalAspect）によるスケーリング
if (finalAspect > 1.0f) {
    measureDiff.x *= finalAspect; // X軸方向の距離を大きく見積もる（横幅を縮める）
} else if (finalAspect < 1.0f) {
    measureDiff.y /= _fmaxf(0.01f, finalAspect); // Y軸方向の距離を大きく見積もる（縦幅を縮める）
}
```

**【具体例：縦長ドット (finalAspect = 2.0) の場合】**
実際のピクセルが中心から右に「2ピクセル」離れていたとします。普通に距離を測れば `X = 2` ですが、上の計算式によって `measureDiff.x = 2.0 * 2.0 = 4.0` となり、「中心から右に4ピクセルも離れている（＝中心から遠い）」と過大に計算させられます。
遠いと判定されるため、黒から透明に変わるグラデーション（不透明度）が急激に下がり、結果的に**X軸（横方向）だけがギュッと縮んだスリムな縦長のドット**が描画されます。

このように、「外側に引き伸ばす」のではなく「内側に向かって圧縮する」計算式を使うことで、いかなる比率においてもマス目（描画枠）をはみ出して描画が一部欠ける（クリッピングされる）不具合を未然に防いでいます。

### 3-3. 形状ごとの「中心からの距離」の計算
ユーザーが選択したドットの形状に応じて、ピクセルと「ドットの中心」の距離（`dist`）を数学的に算出します。
*   **円 (Circle):** ユークリッド距離 `sqrt(x^2 + y^2)`
*   **四角 (Square):** チェビシェフ距離 `max(|x|, |y|)`
*   **ひし形 (Diamond):** マンハッタン距離 `(|x| + |y|) * 0.707...`
    *   **※ 0.707... の補足**: これは $1 / \sqrt{2}$ （または $\sin(45^\circ)$）の値です。単なる `|x| + |y|` だと、算出される距離の最大値が円の半径と合わなくなり枠をはみ出してしまいます。そのため、45度回転した正方形（ひし形）の先端がピタリと元の円の半径に収まるよう、スケールを正規化する（縮める）ための係数として掛け合わせています。

### 3-4. アンチエイリアスと不透明度の決定
算出した「中心からの距離（`dist`）」と「設定されたドットの半径（`dotRadius`）」を比較し、最終的な不透明度の数値（0.0〜1.0）を決定します。

*   **アンチエイリアスあり（縁が滑らか）の場合:**
    境界部分のピクセルを滑らかにするため、輪郭の幅（`aaEdgeWidth`）の内と外でグラデーションを作ります。
    1.  `dist <= innerRadius` (完全に中心側) -> 不透明度 `1.0`（完全な黒）
    2.  `dist >= dotRadius` (完全に完全に半径の外) -> 不透明度 `0.0`（透明）
    3.  その中間（境界線のぼかしエリア） -> `(dotRadius - dist) / aaEdgeWidth` の式で、中間の半透明な数値を算出します。

## まとめ

各ピクセルは、周囲の最大9マスからこの「0.0～1.0（透明〜中心）」の数値を集め、「最もドットの中心に近く、不透明度が高いマス」の情報を自身の最終的な色として採用します。

この**「中心からの距離を通じた比較選択（最大値ブレンド）」**が組み込まれていることで、ドットが密接したりジッターによって激しく重なり合っても、**お互いがいびつに上書きして変形させることなく、自然に融合した輪郭を維持できる**仕組みになっています。
