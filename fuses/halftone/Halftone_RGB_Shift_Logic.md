# ハーフトーンにおけるRGBシフト（色収差）処理のロジック

`MugAdvancedHalftone.fuse` では、古いブラウン管レンズの歪みによる色収差（Chromatic Aberration）や、アナログ印刷時のインク版ズレ（Misregistration）を再現するために、**「RGB Shift (色収差)」**というパラメータが用意されています。

このドキュメントでは、この機能がGPU上でどのように各カラーチャンネル（赤・緑・青）を分離し、処理の最適化を行いつつ計算しているのかを解説します。

---

> [!IMPORTANT]  
> **効果が有効になる前提条件**  
> この機能は、ドットや背景の色を「入力された元画像から抽出（サンプリング）している場合」にのみ機能します。  
> 単一色で塗りつぶされた単なる黒いドットや白い背景といった「ベタ塗りモード」（`Use Original Color` と `Blend With Input` が両方ともオフの状態）では、そもそもサンプリングする「ズレた元画像の色」が存在しないため、シフト値をどのように設定しても無意味（機能しない）設計となっています。

## 1. RGBシフトの目的と視覚的効果

アナログのカラー印刷（CMYK）では、各色の版を何度も紙に重ねて刷るため、紙の僅かなズレによって特定の色だけがはみ出してしまう「版ズレ」という現象が起きます。また、映像分野ではレンズの歪みによって光の波長（色）ごとに屈折率が変わってエッジが虹色に滲む現象を「色収差（Chromatic Aberration）」と呼びます。

本エフェクトの `rgbShift` パラメータは、色情報を抽出する際に**「元画像のR（赤）とB（青）のサンプリング座標を、逆方向にずらして読み込む」**という処理を行っています。中心となるG（緑）の座標を固定することで、全体の像が不自然に移動してしまうのを防いでいます。

---

## 2. 座標オフセット（収差量）の算出

処理の根幹である `RenderDotsKernel` 内において、UIで指定されたピクセル単位のズレ量（`rgbShift`）は、まずUV空間（0.0 ～ 1.0）のオフセット値へと変換されます。

```c
// ユーザーが指定したピクセル単位のズレ幅
const float shiftVal = (blendWithInput != 0 || useOriginalColorFlag != 0) ? params->rgbShift : 0.0f;

// UV空間（0.0～1.0）に乗算するための補正
// 赤(R)は左上（マイナス方向）へズラす
const float2 shiftROFF = to_float2(-shiftVal / intWidth, -shiftVal / intHeight);

// 青(B)は右下（プラス方向）へズラす
const float2 shiftBOFF = to_float2( shiftVal / intWidth,  shiftVal / intHeight);
```

このように、赤は左上へ、青は右下へという完全に対称なベクトル（逆方向）へズラすことで、エッジ付近に特徴的でアバンギャルドな色収差効果を生み出します。映像エフェクトとしては、版ズレ（平行移動）よりもこの色収差的な広がり方の方が視覚的によりリッチな効果を与えます。

---

## 3. サンプリングの最適化（Early Exitと分岐）

GPUシェーダーにおいて、「テクスチャをサンプリング（読み込み）する処理」は非常に重たく、ピクセルごとに3回も別々の場所を読み込むとパフォーマンスが大きく低下します。

そのため本作では、以下のコードのように**「シフト量がゼロ（0.0）の場合は、強制的に1回のサンプリングだけで済ませる」**という最適化（if分岐）が徹底されています。

```c
float4 inputColor = paperColor;

if (blendWithInput != 0) {
    if (shiftVal == 0.0f) {
        // 【最適化】シフト値が0なら、1回だけ元座標をサンプリングして終了（めちゃくちゃ軽い）
        inputColor = _tex2DVecN(src_img, px, py, 15);
    } else {
        // シフト値がある場合のみ、R, G, B を独立して3回サンプリングする
        const float4 sR = _tex2DVecN(src_img, px + shiftROFF.x, py + shiftROFF.y, 15); // ちょっと左上を読む
        const float4 sG = _tex2DVecN(src_img, px, py, 15);                             // 真下（本来の座標）を読む
        const float4 sB = _tex2DVecN(src_img, px + shiftBOFF.x, py + shiftBOFF.y, 15); // ちょっと右下を読む
        
        // 読み込んだ3つのピクセル情報から、R, G, B成分だけを抽出して1つの色に合体（再構築）させる
        inputColor = to_float4(sR.x, sG.y, sB.z, sG.w);
    }
}
```
※ Gチャンネルに付随する `sG.w` はアルファ値（透明度）です。シフトにおいて透明度の輪郭だけがズレてしまうと不自然になるため、中心であるGチャンネルの透明度をそのまま全体の形として採用しています。

---

## 4. ドット色（Use Original Color）への適用

RGBシフトの対象となるのは、背景（`Blend With Input`）の映像だけではありません。
「ドットそのものの色を元画像から拾う設定（`Use Original Color`）」をオンにした場合、上記のロジックと全く同じ計算が、ドットの色決めを行う `checkCellDot` 後段の色抽出プロセスでも実行されます。

これにより、「輪郭が虹色に滲んだ背景」の上に、「それをなぞるように虹色に滲んだ色のドット」が配置されるため、安易に画面全体へ色収差エフェクトを乗せただけでは表現できない、根本から滲んだような強烈なアナログ感が表現されています。

## まとめ

`MugAdvancedHalftone` におけるRGBシフトロジックは：
1. **R（左上）とB（右下）の座標を逆方向にズラし、G成分で元の形を保持する手法**
2. **シフト量が0のときは1回のサンプリングに自動短絡（ショートカット）する高速化**
3. **背景映像だけでなく、抽出するドットの色情報自体にも波及する深い統合**

これらによって、パフォーマンスを落とすことなく直感的で美しい色収差効果（Chromatic Aberration）を提供しています。
