# ハーフトーンにおけるセル分割とサンプリング処理のロジック

## そもそも「ハーフトーン」とは何か？
ハーフトーン（網点）とは、写真のような無数のグラデーション（連続階調）を持つ画像を、単色のインク（例えば黒一色など）だけで表現するための印刷技術です。
インクの「色の濃さ」を変えることができない代わりに、一定の間隔で配置された**「ドット（点）の大きさを変える」**ことで、人間の目には離れて見ると「明るい（ドットが小さい・空間が多い）」や「暗い（ドットが大きくてくっついている）」といった滑らかな階調に見せるという錯視を利用しています。

## なぜ「セル分割（グリッド化）」が必要なのか？
コンピューター上のデジタル画像は「ピクセル（1ピクセルごとに自由に1670万色を出せる）」の集まりですが、ハーフトーン効果を作るためには、このピクセル単位の自由な色表現を一度破壊し、**「一定の間隔でただ1つのドットしか存在できない世界」**へと変換しなければなりません。

そのために必要なのが、画面全体を均等なマス目（セル）に分割する処理です。
1. **空間を区切る:** 画面を無数の「セル」というマス目に分割し、それぞれのマス目に対して「ここに打つドットは1個だけ」と空間を定義します。
2. **色を要約する:** そのマス目の面積内に存在している元の画像のピクセル群を読み取り、「このマス目エリア全体の平均的な明るさはどれくらいか？」を計算（サンプリング）します。
3. **大きさに変換する:** その平均輝度に基づいて、セルの中央に配置する網点の「半径（大きさ）」を決定し、描画します。

このように、連続したピクセル画像を離散的な「点のサイズの集まり」へと再構築するためには、キャンバスを幾何学的に分割する「グリッド化（セル分割）」と、その分割された空間内の明るさを測る「サンプリング処理」がアルゴリズムの最も重要な心臓部となります。

---

`MugAdvancedHalftone.fuse` は、この分割処理において以下の最適化されたロジックを採用しています。

## 1. セル分割（グリッド生成）の仕組み

マス目の大きさ（ピッチ）は、CPU側（`Process` 関数）とGPU側（`CellInfoKernel` 等）の両方で同じ計算式を用いて導出されます。

> [!NOTE] 【補足】なぜCPUとGPUの両方で同じ計算を行うのか？
> 「CPUで一度計算したピッチを変数としてGPUへ渡せば、GPU側で何百万回も再計算させる無駄を省けるのではないか？」という疑問が生じるかもしれません。プログラミングの一般論としてはその通りですが、本コードでは以下のGPU（シェーダー）開発特有の理由から、あえてGPU内で再計算させています。
> 1. **ALU演算のコストが実質ゼロ:** GPUにおいて最も時間がかかるのはメモリ（テクスチャ）からのデータ読み書きであり、単純な四則演算や `floor` 等の算術計算（ALU演算）は異常なほど高速です。CPUからGPUへ変数を引き渡す手間（メモリ帯域の消費）を増やすよりも、GPU側でサクッと全ピクセル同時に再計算させた方がパフォーマンスへの影響がありません。
> 2. **浮動小数点の精度誤差（Float Drift）の回避:** CPU（Lua環境）の数学関数精度と、GPU（OpenCL/CUDA/Metal環境）の計算精度は極僅かに異なります。画面のピクセル位置を決定する超シビアな計算式をGPU側に寄せることで、言語やハードウェア間の計算誤差による「1ピクセルのズレバグ」を未然に防いでいます。
> 3. **コードの自己完結性:** シェーダー言語内に「UIの設定値からこうやってピッチを割り出している」という数式がすべて書いてある方が、アルゴリズムの全貌をシェーダー単体で追いやすくなる（可読性が上がる）というメリットがあります。

### CPU側での事前計算（メモリ確保）
GPUに計算を投げる前、CPUのLuaコード上でまず画面サイズと密度からピッチを計算し、`cellGridNumX` と `cellGridNumY`（画面内にマス目が何個あるか）を割り出します。これは**「中間データを保存するテクスチャバッファ（`dst_info1`, `dst_info2`）を、ぴったりマス目の数と同じ解像度で無駄なくメモリ確保する」**という重要な役割を担っています。

### GPU側での再計算（実際の描画・ベースピッチ）
GPU側（シェーダー内部）でも、改めて同じ計算式を用いて各ピクセルがどのマス目に属しているかを計算します。ユーザーがUIで指定する `Screen Density`（画面の横幅に対してドットを何個並べるか）という値から、1つのマス目のピクセルサイズ（`cellBasePitch`）が動的に導かれます。

```c
// 画面横幅を密度（ドットの数）で割り、マス目1辺の基礎となるピクセル数を算出
const float cellBasePitch = _fmaxf(3.0f, _floorf(width / params->screenDensity));
```
※ どんなに密度を高くしても、描画が破綻しないよう最低3ピクセル（`_fmaxf(3.0f, ...)`）の大きさが保証されています。

### アスペクト比に合わせた全グリッドの歪曲
本エフェクトでは「ドット自体を縦長に引き伸ばす」のではなく、**「世界（マス目自体）を縦長に歪ませてから円を描く」**というアプローチを取っています。個々のドットを変形させると隣のドットと衝突してしまいますが、マス目ごと拡縮させることで、どれだけアスペクト比を変えても完全な等間隔・高精度な描画を維持できます。

```c
const float gridAspect = params->aspectRatio;
float cx = cellBasePitch;
float cy = cellBasePitch * params->gridSpacingY; // 行の間隔（Y軸スペース補正）

// アスペクト比に応じてマス目の幅・高さを圧縮する
if (gridAspect > 1.0f) {
    cx /= gridAspect; // 横長の指定なら、X軸のマス目を縮める（縦長ドットになる）
} else if (gridAspect < 1.0f) {
    cy *= gridAspect; // 縦長の指定なら、Y軸のマス目を縮める（横長ドットになる）
}
```

---

## 2. セルの中心座標（ハニカム構造）

各マス目の中心座標（`cellCenterX, cellCenterY`）を決定する際、単なる方眼紙のような正方配列（Orthogonal Grid）ではなく、印刷物で使われる**ハニカム構造（Honeycomb Grid, 千鳥配置とも呼ばれる）**をサポートしています。

### なぜ「ハニカム構造」が必要なのか？
もし円形（やひし形）のドットを、エクセルのマス目のように「縦横の格子状（正方配列）」に並べたとします。ドット同士が最大まで大きくなって上下左右で接触したとしても、**4つのドットの斜めの隙間に「決して消えない星型の大きな余白（白抜け）」が残ってしまい、画面を100%単色で塗りつぶす（純黒などを表現する）ことが物理的に不可能**になります。
これを防ぐため、上の段のドットとドットの「間の谷間」に、下の段のドットを潜り込ませるようにズラして配置する（みっちり詰め込む）ことで、余白を完全にゼロにするのが「ハニカム構造」の目的です。（※四角形ドットの場合は、正方配列でも隙間なくタイル状に敷き詰められるため、この問題は起きません）

### X軸のズレとY軸の圧縮
このハニカム構造をGPU上で数学的に組み上げるために、X軸とY軸の両方で特別な計算が行われています。

**【Y軸の間隔（Spacing）の圧縮】**
ドットを斜めの谷間に潜り込ませるということは、行と行の間隔が「マス目の高さ100%」ではなくなります。正三角形の高さの比率に従い、本来のピッチに `0.866... (√3/2)` を掛け合わせてY軸を少し押しつぶしています。
```lua
// 円・ひし形なら √3/2 (0.866025) を掛けて行間を詰める。四角形(正方配列)なら 1.0 のまま。
local gridSpacingY = (dotShape == 1) and 1.0 or SIN60
float cy = cellBasePitch * params->gridSpacingY;
```

**【X軸の半マスズレ（Stagger）】**
行間を詰めた上で、奇数行のときだけ「横方向に半マス分だけズラす」処理を加えます。
```c
// 現在処理しているのが奇数行（Y % 2 != 0）かどうかを判定
const int isOddRow = (y % 2 != 0) ? 1 : 0;

// 奇数行の場合のみ、X座標を「マス目の半分のサイズ」だけマイナス方向へズラす
const float rowOffset = (isOddRow != 0) ? (-halfPitchX * params->gridStaggerX) : 0.0f;

// 最終的な中心座標の決定
const float cellCenterX = (...Xの基本計算...) + rowOffset + (ランダムジッター);
```
これにより、X軸の半マス移動と、Y軸の√3/2圧縮が組み合わさり、空間を最も効率的に埋める美しいハニカム印刷配列が実現されています。

**【補足】ドット形状によるハニカム構造の適用ルール**
円形やひし形のドットでは、空間を最も綺麗に埋めるために常にこの「X軸半マス移動 ＋ Y軸の圧縮」による完全なハニカム構造が内部的に強制されます。
例外として、**「四角形（Square）」ドットの場合のみY軸の圧縮計算が行われません（`gridSpacingY` は常に `1.0`）**。そのため、UIのチェックボックス（`Stagger Squares`）をオンにしたとしても完全なハニカム構造になるわけではなく、「単に奇数行のX座標のみが横に半分ズレただけの、レンガ状の配列（Brick Pattern）」へと切り替わる仕様になっています。

---

## 3. サンプリング処理（明るさの取得と最適化）

マス目の位置が決まったら、そのマス目の中心から周囲の画像のピクセルを読み取り（サンプリングし）、平均的な明るさ（輝度・Luma）を計算します。
数百万ピクセル単位で周辺ピクセルを総当りループ検索することはGPUにとって非常に重い処理になるため、本エフェクトでは複数の強烈な最適化が施されています。

### A. 円形バウンディングボックスによる走査カット (Early Cutoff)
四角い領域をすべて調べるのではなく、マス目に内接する「円形」の範囲内のみを計算対象とします。さらに数学的アプローチでループ回数を強制的に削減します。

```c
// 1. 各行（Y）において、すでに円の半径を越えている行なら即座にスキップ（計算しない）
if (dySquared > radiusSquared) continue;

// 2. その行の中で、Xがどこからどこまでなら「円の内側」に収まるかを方程式で逆算。
//    円の端から端までの「計算すべきXの範囲」だけをピンポイントでループする。
const float maxDxSq = radiusSquared - dySquared;
const float maxDx = _sqrtf(maxDxSq);
const int localMinX = max(minX, (int)(cellCenterX - maxDx));
const int localMaxX = min(maxX, (int)(cellCenterX + maxDx));

for (int pixelX = localMinX; pixelX <= localMaxX; pixelX += sampleStep) {
    // 実際に読み込んで明るさを足し合わせる...
}
```
このダイナミックなループ制限により、無駄な余白のピクセルをチェックする処理を完全にゼロにし、劇的な軽量化を果たしています。

> [!WARNING] 【仕様上のトレードオフ】サンプリング形状と明るさの乖離について
> お気づきの通り、「マス目（四角形）」全体をサンプリングするのではなく、「マス目に内接する円」の中でピクセルを平均化しているため、**計算されるセルの平均輝度は、四角いマス目の四隅（角）にあるピクセル情報を無視したものとなります。**
> そのため、元画像の「マス目の角っこ」に極端に明るい/暗い極小のディテールが存在した場合、サンプリング結果にそれが反映されず、厳密な意味での画像全体の平均輝度とはわずかに乖離する可能性があります。これは「厳密な平均値よりも、GPUが処理する総ピクセル数（ループ回数）を削減してリアルタイムパフォーマンスを確保することを優先した」意図的な最適化トレードオフです。

### B. 超巨大ドット時のサンプリング間引き（Step Size Decimation）
もしユーザーが「ドットの密度を極端に低く（巨大なドットに）設定」した場合、1つのマス目の半径が数百ピクセルに達し、GPUの検索ループが爆発してフリーズしてしまいます。
これを防ぐため、一定の半径を越えた場合は**「1ピクセルずつ読み込むのをやめ、数ピクセル飛ばし（間引き）で大雑把に読み込む」**という動的ステップ処理が組み込まれています。

```c
#define SAMPLING_STEP_THRESHOLD 12.0f  // これより半径が大きければ間引く
#define SAMPLING_STEP_LARGE 2          // 2ピクセル飛ばしで読み込む設定

// 走査の歩幅（Step）を動的に決定
const int sampleStep = ((float)samplingRadius > SAMPLING_STEP_THRESHOLD) ? SAMPLING_STEP_LARGE : 1;

// ループの増加量に適用（pixelY += sampleStep）
for (int pixelY = minY; pixelY <= maxY; pixelY += sampleStep) { ... }
```
これにより、どれほどドットを巨大化させてもGPUループの負荷が一定の安全ラインを越えないよう設計されています。

---

## 4. テクスチャサンプラーの重要設定（データ保存）

`MugAdvancedHalftone.fuse` では、第1パス（`CellInfoKernel`）で計算した「マス目の中心座標」や「ドット半径」といった数値を、一時的な画像データ（テクスチャバッファ `dst_info1`, `dst_info2`）に書き込み、第2パスでそれを読み取っています。

通常の画像処理において、GPUは画像を滑らかに見せるために「ピクセルとピクセルの間の色を自動で平均化して混ぜ合わせる（補間する）」というお節介な機能がデフォルトでオンになっています。しかし今回のように**「画像を計算結果（座標や半径などの純粋な数値）を保存する『ただの配列・メモリ』として扱う」**場合、この自動補間機能が働くと「15という座標データと30という座標データが勝手に混ざって、22.5という存在しない嘘の座標が読み出される」といった**致命的なデータ破壊（数値の汚染）**が起きてしまいます。

これを防ぐため、読込時の設定（サンプラー）を通じて「絶対に値を混ぜるな」とGPUに命令を出す必要があります。`Process` 関数内（1310行目付近）では、以下の必須設定が記述されています。

```lua
cellInfoNode:AddSampler("RowSampler", 
    TEX_FILTER_MODE_POINT, 
    TEX_ADDRESS_MODE_CLAMP,
    TEX_NORMALIZED_COORDS_FALSE)
```

1. **`TEX_FILTER_MODE_POINT`（ニアレストネイバー補間）**
   * 通常の画像処理で使われる「バイリニア補間」が有効だと、隣接するマス目のX座標やY座標のデータが勝手に混ざり合って（平均化されて）しまい、データが破壊されます。 POINT補間を指定することで、「その座標にある最も近いピクセルの純粋な数値を、一切加工せずに100%生の状態で返す」ようになります。
2. **`TEX_ADDRESS_MODE_CLAMP`（はみ出し処理）**
   * 計算上のサンプリング座標が画像の端（限界）を突き抜けた際、逆サイド（画面の反対側）の数値をループ（Wrap）して読み込んでしまうのを防ぎます。限界を突破した場合は「一番端っこの安全なピクセルの値をそのまま延長して返す」保護設定です。
3. **`TEX_NORMALIZED_COORDS_FALSE`（絶対ピクセル座標系）**
   * 一般的な「左下0.0 ～ 右上1.0」という正規化座標（%での指定）ではなく、C言語の配列アクセスのように「X=1920, Y=1080」という**絶対的なInteger（整数）ピクセル単位**でのテクスチャ読み書きを強制し、浮動小数点の変換誤差や不要な掛け算処理を完全に排除しています。

## まとめ

`MugAdvancedHalftone`のセル分割・サンプリングロジックは：
1. **世界（グリッド）ごと歪ませることで、高精度なアスペクト比変形を実現**
2. **奇数行を判定したオフセット加算により、印刷特有のハニカム配置を生成**
3. **円形方程式による逆算ループ制限と、動的なピクセル間引きによる安全かつ超高速なサンプリング**
4. **サンプラー設定（Point / Clamp / 絶対座標）の厳密な管理による、テクスチャを介したロスレスな数値データの受け渡し**

これらの高度に最適化と管理が行き届いたシステムにより、リアルタイムで美しいハーフトーンエフェクトを構築する土台を作り上げています。
