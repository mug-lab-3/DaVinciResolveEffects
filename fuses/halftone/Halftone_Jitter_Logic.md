# ハーフトーンにおけるジッター（ランダム変動）の生成ロジック

`MugAdvancedHalftone.fuse` では、ドットの配置を規則正しく均等に並べるだけでなく、アナログ印刷の荒れやノイズを再現するために、ドットの「位置」や「サイズ」を意図的にランダムにズラす**ジッター（Jitter）機能**が実装されています。

このドキュメントでは、数百万ピクセルを処理する並列GPU環境において、**「動画として再生してもノイズがチカチカと点滅せず、かつドットごとに完全に独立したランダムな数値（乱数）」**をどのように生成しているのか、その数学的アプローチを解説します。

---

## 1. ジッターの目的と直面する計算上の課題

アナログ印刷の不完全さをシミュレートするためには、各ドットに対して`-1.0 ～ 1.0` のようなランダムな数値を割り当てる必要があります。
しかし、GPUで「単なるランダム（例：`rand()` 関数）」を使ってしまうと、以下の2つの深刻な問題に直面します。

1. **フリッカー（チラつき）の発生:**
   動画のフレーム（1秒間に24回など）が更新されるたびに乱数が再計算されてしまい、ドットの位置や大きさが毎フレーム毎フレーム激しく振動し、砂嵐のようにチカチカと点滅する映像になってしまいます。
2. **ピクセル間の不整合:**
   GPUは「ドット単位」ではなく「画面の全ピクセル」を同時に計算しているため、同じドットに属するピクセル同士で違う乱数が出てしまうと、円の形が崩壊してしまいます。

これを解決するため、本エフェクトでは**「座標ベースのハッシュ関数（疑似乱数）」**を利用して、空間に完全に「固定（固定化=deterministic）」された乱数マップを生成しています。

---

## 2. 実現手法：座標ベースの3Dハッシュ関数（PCG Hash）

この問題を解決するため、`CellInfoKernel` 内では以下のような、ビット演算のみを用いた強力な数学的ハッシュ関数 `hash3D` が定義されています。

この関数は独自に考案された適当な数式ではなく、**Jenkins Hash（ジェンキンス・ハッシュ）**や**PCG（Permuted Congruential Generator）**といった、コンピュータサイエンスや最新のゲームグラフィックスにおいて「極めて偏りが少なく、高速で、実績のある標準的な疑似乱数アルゴリズム」をベースに実装されています。

```c
// 整数(uint)のX, Y, Z座標と、シード値から -1.0～1.0 の疑似乱数を生成する
__DEVICE__ float hash3D(uint x, uint y, uint z, uint seedOffset) {
    // Jenkins Hash / PCG パターンに基づく強力な非線形ハッシュ
    uint h = x + y * 374761393u + z * 668265263u + seedOffset;
    h += h << 10;
    h ^= h >> 6;
    h += h << 3;
    h ^= h >> 11;
    h += h << 15;
    
    // PCGスタイルの最終ミックス
    h = (h ^ (h >> 16)) * 2654435761u;
    h = h ^ (h >> 16);
    
    // 最終的に -1.0f ～ 1.0f のfloat値に変換
    return (float)(h & 0x00FFFFFF) * (1.0f / (float)0x00FFFFFF) * 2.0f - 1.0f;
}
```

### 【解説】hash3D関数の引数と役割
1. **入力は「絶対的なマス目の座標」:**
   関数 `hash3D` に与えられるXとYは**「そのドットが何列目・何行目にあるか」という固定の住所の整数値（`cellIdX`, `cellIdY`）**です。これにより、毎回全く同じ値が入れば完全に同じ乱数が返ってきます。
2. **Z軸はアニメーションのための「時間（Phase）」:**
   第3の引数 `z` には、後述する `Jitter Phase` の整数値が渡されます。つまり、X（横）とY（縦）だけでなく**Z（時間軸にあたる3次元目）の座標を持たせる**ことで、同じマス目の中にいながら「時間の経過とともに異なる乱数マップを切り替えてボイリング（アニメーション）」させるための層（レイヤー）として機能しています。
3. **シードオフセットによる独立化 (固定値):**
   4番目の引数 `seedOffset` には、位置Xなら `0`、位置Yなら `10007`、サイズなら `9973` といった、各機能ごとに固有の大きな素数（ハードコーディングされた定数）が渡されます。もしこれがすべて同じ値だと「右にズレたドットは必ず下にも同じ割合だけズレて、サイズも必ず大きくなる」といった完全に連動・同期した不自然な動きになってしまいます。機能ごとに大きく離れた固定オフセットを足すことで、同じマス目の中にいながら**「位置Xは大きくズレたが、サイズは逆に小さい」といった、完全に無関係で独立した乱数（無相関のノイズ）を同時に生成する**ことを保証しています。

### なぜサイン波(sin)ではなく整数のビット演算(uint)なのか？
   過去の手法では `sin()` 関数などの小数がよく使われていましたが、AMD, NVIDIA, Apple Silicon などで `sin()` の計算精度が微妙に異なるため、OSやGPUが変わると乱数結果がズレて形が崩れる（ドリフトする）問題がありました。これを防ぐため、**絶対に計算結果がブレない整数（uint）のビットシフト演算**を活用し、最後にだけfloatへ戻す堅牢なアプローチを採用しています。

---

## 3. Jitter Phase（位相）によるアニメーションと滑らかな補間

ユーザーがUIから操作できる **`Jitter Noise Phase`** パラメータは、上記の `hash3D` 関数のZ軸（時間軸にあたる3番目の引数 `z`）として機能します。
この値をアニメーションさせることで、チカチカしない滑らかにウネウネと動くノイズ（ボイリング効果）を作り出します。

### 【解説】スムーズな推移のカラクリ
単に `jitterPhase` の小数（例：`1.5`）をそのまま乱数の種にしてしまうと、整数部分が変わる瞬間（`1.99` → `2.00`）にノイズマップがパキッと一瞬で切り替わってしまい映像として破綻します。これを防ぐため、以下のステップで補間処理（Blend）を行っています。

1. **2つの整数の状態を同時に計算する**
   現在の `jitterPhase` が `1.5` であれば、整数切り捨ての `1` (現在) と `2` (未来) の2パターンの乱数を、事前に両方とも計算（サンプリング）します。
2. **Fraction（小数点）による補間 (Smoothstep)**
   残りの小数点部分 `0.5` を、ただの直線的な割合（線形補間）ではなく、`3t^2 - 2t^3` という滑らかな曲線（Smoothstep）に通して補間割合（`t`）を算出します。直線だとカクカクとしたロボットのような動きになりますが、曲線化することで加速度・減速度を持った滑らかな変化になります。
3. **ブレンド（Mix）する**
   `1`の乱数結果と`2`の乱数結果を、上記の `t` の割合で混ぜ合わせます。

これにより、Phaseの数値が動くと、現在のノイズパターンから次のノイズパターンへと**「ぬるっと溶け込むように」完全にシームレスに変化していく**という、非常に質の高いアニメーション乱数を実現しています。

---

## 4. 生成された乱数の適用（実装例）

上記の補間プロセスを経て得られた『そのマス目固有の `-1.0 ～ 1.0` の乱数（`randX`, `randY`）』を使って、実際にマス目の中心座標やドットの大きさをズラします。

### 4-1. 位置のズレ（Position Jitter）の計算
```c
// ユーザーインターフェースからのジッター強度（0.0〜1.0）
const float jitterAmountX = params->positionJitter * halfPitchX;
const float jitterAmountY = params->positionJitter * halfPitchY;

// 本来の中心座標に対して、乱数に基づく移動距離を加算する
const float cellCenterX = baseCenterX + (randX * jitterAmountX);
const float cellCenterY = baseCenterY + (randY * jitterAmountY);
```
もし `positionJitter` が最大（1.0）であれば、ドットは本来のマス目の中心から、隣のマス目の境界線ギリギリの範囲において、ランダムな方向へと散らばって配置されます。

### 4-2. サイズのズレ（Size Jitter）の計算
位置（X,Y）とは全く異なるシード値で作られた独立した乱数（`randS`）を用いて、ドットの大きさを拡大・縮小させます。
```c
// 元画像の明るさ等に基づく本来の半径
float dotRadius = ･･･ ;

if (params->sizeJitter > 0.0f) {
    // randS (-1.0 ～ 1.0) を用いて、最大で元のサイズの ±50% の変動を与える
    const float sizeVariation = 1.0f + (randS * params->sizeJitter * 0.5f);
    dotRadius *= sizeVariation; // 乱数の倍率を掛けて半径を再計算
}
```
`sizeVariation` は最大で `0.5倍(50%) ～ 1.5倍(150%)` の範囲で変動するため、強すぎてもドットが完全に消えにくく、自然なインクの滲みや欠けを表現できます。

### 4-3. アスペクト比のズレ（Aspect Jitter）の計算
さらに別の独立した乱数（`randAspect`）を用いて、ドットがランダムな方向に縦長・横長に潰れるような変動を与えます。
```c
// 指数関数（2の冪乗）を用いて、縦横の変動幅が対称的になるように計算
const float aspectMultiplier = _exp2f(params->aspectJitter * randAspect * 2.0f);
const float finalAspect = _fmaxf(0.01f, params->aspectRatio * aspectMultiplier);
```
掛け算や割り算ではなく`_exp2f`（2の冪乗）を用いることで、「半分に潰れる（0.5倍）」と「2倍に伸びる（2.0倍）」という変動の確率・割合が数学的に完全に対称的になるよう設計されています。

## まとめ

`MugAdvancedHalftone`のジッター機能は、単なる乱数発生器ではなく、**「マス目の絶対的なID（座標）」をシード値とするPCGスタイルのビット演算ハッシュ（hash3D）**と、**整数区間のスムーズな補間（Smoothstep）**によって生成されています。

これにより、隣り合うドット同士が独立した無秩序なパラツキを持ちつつも、ハードウェア環境（OSやGPU）に依存して形崩れすることなく、動画として再生した際にも一切チラつかない高品質なアニメーションノイズを提供しています。
