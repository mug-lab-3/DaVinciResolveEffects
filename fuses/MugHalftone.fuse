FuRegisterClass("MugHalftone", CT_SourceTool, {
    REGS_Category          = "Fuses\\Mug",
    REGS_OpIconString      = "MHT",
    REGS_OpDescription     = "Mug Halftone",
    REGS_HelpTopic         = "https://x.com/MugLab3", --This can be a URL
    REGS_URL               = "https://www.youtube.com/@MugLabVideoEditing",
    -- REGS_IconID            = "Icons.Tools.Icons.Example", -- This can be Inline as an array of Values
    REG_OpNoMask           = false,
    REG_NoObjMatCtrls      = false,
    REG_NoMotionBlurCtrls  = false,
    REG_Source_GlobalCtrls = true,
    REG_Source_SizeCtrls   = true,
    REG_Source_AspectCtrls = true,
    REG_Source_DepthCtrls  = true,
    REG_Version            = 0.1,
})

-- パラメーター構造体の更新
HalftoneParams = [[
  int srcSize[2];        // ソース画像のサイズ
  float contrast;        // コントラスト調整（1.0がデフォルト）
  int useOriginalColor;  // 元の色を使用するかどうか（0=白黒、1=カラー）
  int useCMYKMode;       // CMYKモードを使用するかどうか（0=標準ハーフトーン、1=CMYKスタイル）
  float dotAngle;        // ドットの角度（CMYK モードでのみ使用）
  float aaStrength;      // アンチエイリアス強度（0.0=無効、1.0=強い）
  int useSubSamplingAA;  // サブサンプリングAAの使用（0=無効、1=有効）
  int subSampleCount;    // サブサンプル数（1=無効、2x2=4、3x3=9）
  float dotGain;         // ドットゲイン効果の強さ（0.0-1.0）
  float regError;        // 色版ずれの程度（0.0-1.0）
  float ucrAmount;       // UCR/GCR適用量（0.0-1.0）
  float paperTexture;    // 紙の質感強度（0.0-1.0）
  int paperTextureType;  // 紙の種類（0=なめらか、1=わずかな繊維、2=強い繊維）
  float screenDensity;   // スクリーンの密度
  float paperColor[4];   // 紙の色（背景色）[R,G,B,A]
  int showCellBoundaries; // セル境界を表示（デバッグ用）
]]

-- 標準ハーフトーンカーネル（サブサンプリングAA対応版）
-- 標準ハーフトーンカーネル（サブサンプリングAA対応版、大ドット時のAA抑制機能付き）
HalftoneKernel = [[
__KERNEL__ void HalftoneKernel(__CONSTANTREF__ HalftoneParams *params, __TEXTURE2D__ src, __TEXTURE2D_WRITE__ dst)
{
    DEFINE_KERNEL_ITERATORS_XY(x, y);

    // 六角形パターンの方向ベクトル（定数）
    // 偶数行用の隣接セル相対位置
    const int hexNeighborsEven[6][2] = {
        {-1, 0}, {1, 0},   // 左右
        {-1, -1}, {0, -1}, // 左上、右上
        {-1, 1}, {0, 1}    // 左下、右下
    };

    // 奇数行用の隣接セル相対位置
    const int hexNeighborsOdd[6][2] = {
        {-1, 0}, {1, 0},  // 左右
        {0, -1}, {1, -1}, // 左上、右上
        {0, 1}, {1, 1}    // 左下、右下
    };

    if (x < params->srcSize[0] && y < params->srcSize[1])
    {
        // 定数の事前計算
        const float SIN60 = 0.866025f; // √3/2
        const float PI = 3.14159265359f;

        // ドット半径の基準定数 - Gain=0でセルいっぱい、Gain=-0.5で半分、Gain=1でセルの2倍
        const float MAX_CELL_RADIUS = 0.433f;

        // 基本ドットサイズ設定
        const float cellSize = 1000.0f / params->screenDensity;
        const float cellSizeX = cellSize;
        const float cellSizeY = cellSize * SIN60;
        const float cellRowSpacing = MAX_CELL_RADIUS * 2.0f * cellSizeX * 0.88f;
        const float zigzagFactor = 0.5f;

        // 平方根計算コストを下げるための閾値の二乗
        const float centerThresholdSq = 0.75f;
        const float distThresholdBaseSq = 0.625f * 0.625f;
        const float distThresholdAltSq = 0.645f * 0.645f;
        const float verticalBoostFactor = 1.1025f; // 1.05^2

        // 高密度関連の定数
        const float highDensityFactor = _fmaxf(1.0f, _fminf(1.5f, 200.0f / params->screenDensity));
        const float aaDensityFactor = _fminf(1.0f + (200.0f / params->screenDensity) * 0.15f, 1.3f);
        const bool useAA = params->aaStrength > 0.001f;

        // サブサンプリングAA関連
        const bool useSubSamplingAA = params->useSubSamplingAA > 0 && useAA;
        const int subSampleCount = params->subSampleCount;
        const int sqrtSampleCount = _fmaxf(1, (int)_sqrtf((float)subSampleCount));
        const float subPixelStep = 1.0f / (float)sqrtSampleCount;

        // 新しいAA関連パラメータ
        const float densityScale = _fmaxf(1.0f, 8.0f / cellSize);
        const float baseAAWidth = useAA ?
            _fmaxf(0.5f / cellSizeX * params->aaStrength * aaDensityFactor * densityScale, 0.005f) : 0.0f;

        // セルサイズに応じたAA幅調整
        const float aaWidthScale = _fmaxf(1.0f, _fminf(1.5f, 8.0f / cellSize));
        const float aaWidthBase = useAA ?
            baseAAWidth * (_fmaxf(1.0f, 1.0f + (params->aaStrength - 0.5f) * 0.5f)) :
            0.0f;

        // 座標正規化
        const float xf = (float)x;
        const float yf = (float)y;
        const float xNorm = xf / (float)params->srcSize[0];
        const float yNorm = yf / (float)params->srcSize[1];
        const float4 pixelColor = _tex2DVecN(src, xNorm, yNorm, 15);

        // セルのグリッド計算
        const int cellIdX = (int)(xf / cellSizeX);
        const int cellIdY = (int)(yf / cellRowSpacing);

        // 行オフセットフラグ
        const bool isCurrentRowOffset = ((cellIdY & 1) != 0);

        // テクスチャサイズの逆数
        const float invSrcSizeX = 1.0f / (float)params->srcSize[0];
        const float invSrcSizeY = 1.0f / (float)params->srcSize[1];

        // ドットゲイン補正
        const float dotGainFactor = 1.0f + params->dotGain;

        // デフォルト値として背景色を設定（常に紙の色を使用）
        float4 result = to_float4(
            params->paperColor[0],
            params->paperColor[1],
            params->paperColor[2],
            params->paperColor[3]
        );

        // スコアリング用の変数
        float bestAlpha = 0.0f;
        float bestLuma = 1.0f;
        float4 bestColor = result;
        bool hasInfluence = false;
        float bestScore = -1.0f;
        float bestRadius = 0.0f;

        // 高密度時のブースト係数
        const bool isSmallCell = cellSize < 12.0f;
        const bool isVerySmallCell = cellSize < 8.0f;
        const bool isTinyCell = cellSize < 6.0f;
        const bool isUltraSmallCell = cellSize < 3.5f;

        // スモールセルブースト - 条件分岐削減
        const float smallCellBoostFactor = isSmallCell ?
                   (12.0f - cellSize) * (_fminf(0.06f, 0.03f * highDensityFactor)) : 0.0f;
        const float smallCellBoost = 1.0f + smallCellBoostFactor;

        // Original color flag
        const bool useOriginalColor = params->useOriginalColor == 1;

        // 暗部強調係数の事前計算 - 多用されるので定数化
        const float darknessEnhanceFactor = 0.15f;

        // 中心セルを処理
        {
            const float rowOffsetX = isCurrentRowOffset ? cellSizeX * zigzagFactor : 0.0f;
            const float cellCenterX = cellIdX * cellSizeX + rowOffsetX + cellSizeX * 0.5f;
            const float cellCenterY = cellIdY * cellRowSpacing + cellSizeY * 0.5f;

            // 距離計算
            float distX = xf - cellCenterX;
            float distY = yf - cellCenterY;

            // 高密度時の歪み補正（条件分岐を減少）
            const float distYMult = isVerySmallCell ?
                                   _fmaxf(0.8f, 1.0f - (10.0f - cellSize) * 0.02f) : 1.0f;
            distY *= distYMult;

            const float distXNorm = distX / cellSizeX;
            const float distYNorm = distY / cellSizeY;
            float normDistSq = distXNorm*distXNorm + distYNorm*distYNorm;

            // 高密度時の形状補正（条件分岐を減少）
            if (isVerySmallCell) {
                const float dirFactor = _fabs(distXNorm) / (_fabs(distYNorm) + 0.0001f);

                // 密度に応じた形状調整
                float shapeAdjust = 1.0f;
                if (dirFactor > 1.5f) {
                    // X方向優勢パターン
                    const float adjustFactor = _fminf(dirFactor - 1.5f, 1.0f) * 0.2f;
                    shapeAdjust = 1.0f - adjustFactor * (8.0f - cellSize) * 0.03f;
                } else if (dirFactor < 0.65f) {
                    // Y方向優勢パターン
                    const float adjustFactor = _fminf(0.65f - dirFactor, 0.5f) * 0.4f;
                    shapeAdjust = 1.0f - adjustFactor * (8.0f - cellSize) * 0.025f;
                }

                // 対角線方向の補正（複雑な形状のためにブレンド）
                if (dirFactor > 0.8f && dirFactor < 1.2f) {
                    const float diagFactor = 1.0f - _fabs(dirFactor - 1.0f) * 0.4f;
                    const float diagAdjust = 1.0f + diagFactor * 0.05f;
                    shapeAdjust *= diagAdjust;
                }

                normDistSq *= shapeAdjust;
            }

            // 早期脱出チェック
            if (normDistSq <= centerThresholdSq) {
                const float centerUVx = cellCenterX * invSrcSizeX;
                const float centerUVy = cellCenterY * invSrcSizeY;

                // テクスチャ範囲チェック
                if (centerUVx >= 0.0f && centerUVx <= 1.0f &&
                    centerUVy >= 0.0f && centerUVy <= 1.0f)
                {
                    const float4 cellColor = _tex2DVecN(src, centerUVx, centerUVy, 15);

                    // 輝度とコントラスト計算
                    const float rawLuma = cellColor.x * 0.3f + cellColor.y * 0.59f + cellColor.z * 0.11f;
                    const float cellLuma = _clampf(
                        (rawLuma - 0.5f) * params->contrast + 0.5f,
                        0.0f, 1.0f
                    );

                    // ドット半径計算
                    float radius = MAX_CELL_RADIUS * (1.0f - cellLuma);
                    radius = _fmaxf(radius, 0.01f);

                    // 高密度と暗部調整の統合
                    if (isTinyCell && cellLuma < 0.4f) {
                        radius = _fmaxf(radius, 0.08f * (1.0f - cellSize / 6.0f));
                    }

                    if (cellLuma < 0.3f) {
                        radius += (0.3f - cellLuma) * darknessEnhanceFactor;
                    }

                    // 高密度時の微調整 - 超小型セルでは若干半径を大きく
                    if (isUltraSmallCell) {
                        radius *= 1.05f;
                    }

                    // ドットゲイン適用
                    radius *= smallCellBoost * dotGainFactor;

                    // 大きなドットかどうかをチェック
                    const bool isLargeDot = radius > 0.35f;

                    // 完全に刷新したAA処理
                    float alpha = 0.0f;
                    const float normDist = _sqrtf(normDistSq);

                    if (useSubSamplingAA && (isVerySmallCell || isTinyCell) && !isLargeDot) {
                        // サブサンプリングAA（高密度時のみ、大ドット時は除外）
                        float alpha_sum = 0.0f;
                        int effectiveSamples = 0;

                        // サブピクセルパスを適応的に調整（セルサイズに応じて）
                        const float gridStep = subPixelStep * (_fminf(0.65f, cellSize * 0.1f));

                        // サブピクセルサンプリング
                        for (float dy = -0.5f + gridStep * 0.5f; dy < 0.5f; dy += gridStep) {
                            for (float dx = -0.5f + gridStep * 0.5f; dx < 0.5f; dx += gridStep) {
                                // 各サブピクセル位置での距離計算
                                float sub_distX = distX + dx;
                                float sub_distY = distY + dy;

                                // 形状補正を適用
                                sub_distY *= distYMult;

                                const float sub_distXNorm = sub_distX / cellSizeX;
                                const float sub_distYNorm = sub_distY / cellSizeY;
                                float sub_normDistSq = sub_distXNorm*sub_distXNorm + sub_distYNorm*sub_distYNorm;

                                // 高密度時の形状補正
                                if (isVerySmallCell) {
                                    const float dirFactor = _fabs(sub_distXNorm) / (_fabs(sub_distYNorm) + 0.0001f);

                                    float shapeAdjust = 1.0f;
                                    if (dirFactor > 1.5f) {
                                        const float adjustFactor = _fminf(dirFactor - 1.5f, 1.0f) * 0.2f;
                                        shapeAdjust = 1.0f - adjustFactor * (8.0f - cellSize) * 0.03f;
                                    } else if (dirFactor < 0.65f) {
                                        const float adjustFactor = _fminf(0.65f - dirFactor, 0.5f) * 0.4f;
                                        shapeAdjust = 1.0f - adjustFactor * (8.0f - cellSize) * 0.025f;
                                    }

                                    if (dirFactor > 0.8f && dirFactor < 1.2f) {
                                        const float diagFactor = 1.0f - _fabs(dirFactor - 1.0f) * 0.4f;
                                        const float diagAdjust = 1.0f + diagFactor * 0.05f;
                                        shapeAdjust *= diagAdjust;
                                    }

                                    sub_normDistSq *= shapeAdjust;
                                }

                                // 各サブピクセル位置でのアルファ値を計算
                                float sub_normDist = _sqrtf(sub_normDistSq);
                                float sub_alpha = 0.0f;

                                if (!useAA) {
                                    sub_alpha = (sub_normDist <= radius) ? 1.0f : 0.0f;
                                } else {
                                    // アンチエイリアス計算
                                    float aaWidth = aaWidthBase * 0.7f; // サブサンプル用にやや狭めに

                                    if (isVerySmallCell) {
                                        aaWidth *= 1.0f + (8.0f - cellSize) * 0.1f;
                                    }

                                    const float edgeDist = sub_normDist - radius;

                                    if (edgeDist < 0.0f) {
                                        sub_alpha = 1.0f;
                                    }
                                    else if (edgeDist < aaWidth) {
                                        const float t = edgeDist / aaWidth;

                                        if (isUltraSmallCell) {
                                            sub_alpha = 0.5f * (1.0f + _cosf(PI * t));
                                        }
                                        else if (isVerySmallCell) {
                                            sub_alpha = 1.0f - (t * t * (3.0f - 2.0f * t));
                                        }
                                        else {
                                            sub_alpha = 1.0f - (t * t * (1.0f + 0.25f * t));
                                        }
                                    }
                                }

                                alpha_sum += sub_alpha;
                                effectiveSamples++;
                            }
                        }

                        // サブピクセルの平均を計算
                        alpha = effectiveSamples > 0 ? alpha_sum / (float)effectiveSamples : 0.0f;

                        // 超高密度時はAAをわずかに強化
                        if (isUltraSmallCell && alpha > 0.0f && alpha < 1.0f) {
                            alpha = _powf(alpha, 0.85f);
                        }
                    } else {
                        // 標準のAA処理（単一サンプル）
                        if (!useAA || isLargeDot) {
                            // AAなしの場合または大きなドットの場合は単純な閾値処理
                            alpha = (normDist <= radius) ? 1.0f : 0.0f;
                        } else {
                            // 新しい適応型AA幅計算
                            float aaWidth = aaWidthBase;

                            // 大きなドットの場合はAAの幅を狭める
                            if (radius > 0.3f && radius <= 0.35f) {
                                // 中間サイズのドットではAAを弱める
                                aaWidth *= (0.35f - radius) * 3.33f; // 0.3→0.35で1→0に変化
                            }

                            // 超高密度時は幅を拡張
                            if (isVerySmallCell) {
                                aaWidth *= 1.0f + (8.0f - cellSize) * 0.1f;
                            }

                            // エッジ距離の計算
                            const float edgeDist = normDist - radius;

                            if (edgeDist < 0.0f) {
                                // ドット内部 - 完全に不透明
                                alpha = 1.0f;
                            }
                            else if (edgeDist < aaWidth) {
                                // エッジ部分 - 密度に応じて最適なカーブを選択
                                const float t = edgeDist / aaWidth;

                                if (isUltraSmallCell) {
                                    // 超高密度用 - cosカーブ（非常に滑らか）
                                    alpha = 0.5f * (1.0f + _cosf(PI * t));
                                }
                                else if (isVerySmallCell) {
                                    // 高密度用 - smoothstep
                                    alpha = 1.0f - (t * t * (3.0f - 2.0f * t));
                                }
                                else if (radius > 0.3f) {
                                    // 大きめのドット用 - より急峻なカーブ
                                    alpha = 1.0f - (t * t * t);
                                }
                                else {
                                    // 標準密度用の3次曲線 - 少しシャープ
                                    alpha = 1.0f - (t * t * (1.0f + 0.25f * t));
                                }

                                // 超高密度時はAAをわずかに強化
                                if (isUltraSmallCell && alpha > 0.0f && alpha < 1.0f) {
                                    alpha = _powf(alpha, 0.85f);
                                }
                            }
                            else {
                                // エッジ外 - 完全に透明
                                alpha = 0.0f;
                            }
                        }
                    }

                    // 閾値による早期決定
                    if (alpha > 0.01f) {
                        const float currentDotLuma = useOriginalColor ? cellLuma : 0.0f;

                        // スコア計算を統合
                        const float score = (1.0f - currentDotLuma) * 5.0f + alpha * alpha * 1.2f;

                        bestScore = score;
                        bestAlpha = alpha;
                        bestLuma = currentDotLuma;
                        bestRadius = radius; // 半径も保存
                        bestColor = useOriginalColor ? cellColor : to_float4(0.0f, 0.0f, 0.0f, 1.0f);
                        hasInfluence = true;
                    }
                }
            }
        }

        // 隣接セルの参照テーブル
        const int (*hexNeighbors)[2] = isCurrentRowOffset ? hexNeighborsOdd : hexNeighborsEven;

        // 隣接セル処理
        #pragma unroll
        for (int i = 0; i < 6; i++) {
            const int dx = hexNeighbors[i][0];
            const int dy = hexNeighbors[i][1];

            const int checkX = cellIdX + dx;
            const int checkY = cellIdY + dy;

            const bool isCheckRowOffset = ((checkY & 1) != 0);
            const float rowOffsetX = isCheckRowOffset ? cellSizeX * zigzagFactor : 0.0f;

            // セル中心計算
            const float cellCenterX = checkX * cellSizeX + rowOffsetX + cellSizeX * 0.5f;
            const float cellCenterY = checkY * cellRowSpacing + cellSizeY * 0.5f;

            // 距離計算
            float distX = xf - cellCenterX;
            float distY = yf - cellCenterY;

            // 高密度時の歪み補正（条件分岐を減少）
            const float distYMult = isVerySmallCell ?
                                   _fmaxf(0.8f, 1.0f - (10.0f - cellSize) * 0.02f) : 1.0f;
            distY *= distYMult;

            const float distXNorm = distX / cellSizeX;
            const float distYNorm = distY / cellSizeY;
            float normDistSq = distXNorm*distXNorm + distYNorm*distYNorm;

            // 高密度時の形状補正（条件分岐を減少）
            if (isVerySmallCell) {
                const float dirFactor = _fabs(distXNorm) / (_fabs(distYNorm) + 0.0001f);

                // 密度に応じた形状調整
                float shapeAdjust = 1.0f;
                if (dirFactor > 1.5f) {
                    // X方向優勢パターン
                    const float adjustFactor = _fminf(dirFactor - 1.5f, 1.0f) * 0.2f;
                    shapeAdjust = 1.0f - adjustFactor * (8.0f - cellSize) * 0.03f;
                } else if (dirFactor < 0.65f) {
                    // Y方向優勢パターン
                    const float adjustFactor = _fminf(0.65f - dirFactor, 0.5f) * 0.4f;
                    shapeAdjust = 1.0f - adjustFactor * (8.0f - cellSize) * 0.025f;
                }

                // 対角線方向の補正（複雑な形状のためにブレンド）
                if (dirFactor > 0.8f && dirFactor < 1.2f) {
                    const float diagFactor = 1.0f - _fabs(dirFactor - 1.0f) * 0.4f;
                    const float diagAdjust = 1.0f + diagFactor * 0.05f;
                    shapeAdjust *= diagAdjust;
                }

                normDistSq *= shapeAdjust;
            }

            // 距離閾値計算（条件分岐を最適化）
            float distThresholdSq = (isCurrentRowOffset == isCheckRowOffset) ?
                                  distThresholdBaseSq :
                                  distThresholdAltSq;

            // 垂直方向補正
            distThresholdSq *= (dy != 0) ? verticalBoostFactor : 1.0f;

            // 高密度時の調整（条件を簡略化）
            distThresholdSq *= isVerySmallCell ?
                            (1.0f + (8.0f - cellSize) * 0.03f) : 1.0f;

            // 早期脱出
            if (normDistSq > distThresholdSq) continue;

            const float centerUVx = cellCenterX * invSrcSizeX;
            const float centerUVy = cellCenterY * invSrcSizeY;

            if (centerUVx >= 0.0f && centerUVx <= 1.0f &&
                centerUVy >= 0.0f && centerUVy <= 1.0f)
            {
                const float4 cellColor = _tex2DVecN(src, centerUVx, centerUVy, 15);

                // 輝度計算
                const float rawLuma = cellColor.x * 0.3f + cellColor.y * 0.59f + cellColor.z * 0.11f;
                const float cellLuma = _clampf(
                    (rawLuma - 0.5f) * params->contrast + 0.5f,
                    0.0f, 1.0f
                );

                // ドット半径計算
                float radius = MAX_CELL_RADIUS * (1.0f - cellLuma);
                radius = _fmaxf(radius, 0.01f);

                // 高密度と暗部調整の統合
                if (isTinyCell && cellLuma < 0.4f) {
                    radius = _fmaxf(radius, 0.08f * (1.0f - cellSize / 6.0f));
                }

                if (cellLuma < 0.3f) {
                    radius += (0.3f - cellLuma) * darknessEnhanceFactor;
                }

                // 高密度時の微調整 - 超小型セルでは若干半径を大きく
                if (isUltraSmallCell) {
                    radius *= 1.05f;
                }

                // ドットゲイン適用
                radius *= smallCellBoost * dotGainFactor;

                // 大きなドットかどうかをチェック
                const bool isLargeDot = radius > 0.35f;

                // 完全に刷新したAA処理
                float alpha = 0.0f;
                const float normDist = _sqrtf(normDistSq);

                if (useSubSamplingAA && (isVerySmallCell || isTinyCell) && !isLargeDot) {
                    // サブサンプリングAA（高密度時のみ、大ドット時は除外）
                    float alpha_sum = 0.0f;
                    int effectiveSamples = 0;

                    // サブピクセルパスを適応的に調整（セルサイズに応じて）
                    const float gridStep = subPixelStep * (_fminf(0.65f, cellSize * 0.1f));

                    // サブピクセルサンプリング
                    for (float dy = -0.5f + gridStep * 0.5f; dy < 0.5f; dy += gridStep) {
                        for (float dx = -0.5f + gridStep * 0.5f; dx < 0.5f; dx += gridStep) {
                            // 各サブピクセル位置での距離計算
                            float sub_distX = distX + dx;
                            float sub_distY = distY + dy;

                            // 形状補正を適用
                            sub_distY *= distYMult;

                            const float sub_distXNorm = sub_distX / cellSizeX;
                            const float sub_distYNorm = sub_distY / cellSizeY;
                            float sub_normDistSq = sub_distXNorm*sub_distXNorm + sub_distYNorm*sub_distYNorm;

                            // 高密度時の形状補正
                            if (isVerySmallCell) {
                                const float dirFactor = _fabs(sub_distXNorm) / (_fabs(sub_distYNorm) + 0.0001f);

                                float shapeAdjust = 1.0f;
                                if (dirFactor > 1.5f) {
                                    const float adjustFactor = _fminf(dirFactor - 1.5f, 1.0f) * 0.2f;
                                    shapeAdjust = 1.0f - adjustFactor * (8.0f - cellSize) * 0.03f;
                                } else if (dirFactor < 0.65f) {
                                    const float adjustFactor = _fminf(0.65f - dirFactor, 0.5f) * 0.4f;
                                    shapeAdjust = 1.0f - adjustFactor * (8.0f - cellSize) * 0.025f;
                                }

                                if (dirFactor > 0.8f && dirFactor < 1.2f) {
                                    const float diagFactor = 1.0f - _fabs(dirFactor - 1.0f) * 0.4f;
                                    const float diagAdjust = 1.0f + diagFactor * 0.05f;
                                    shapeAdjust *= diagAdjust;
                                }

                                sub_normDistSq *= shapeAdjust;
                            }

                            // 各サブピクセル位置でのアルファ値を計算
                            float sub_normDist = _sqrtf(sub_normDistSq);
                            float sub_alpha = 0.0f;

                            if (!useAA) {
                                sub_alpha = (sub_normDist <= radius) ? 1.0f : 0.0f;
                            } else {
                                // アンチエイリアス計算
                                float aaWidth = aaWidthBase * 0.7f; // サブサンプル用にやや狭めに

                                if (isVerySmallCell) {
                                    aaWidth *= 1.0f + (8.0f - cellSize) * 0.1f;
                                }

                                const float edgeDist = sub_normDist - radius;

                                if (edgeDist < 0.0f) {
                                    sub_alpha = 1.0f;
                                }
                                else if (edgeDist < aaWidth) {
                                    const float t = edgeDist / aaWidth;

                                    if (isUltraSmallCell) {
                                        sub_alpha = 0.5f * (1.0f + _cosf(PI * t));
                                    }
                                    else if (isVerySmallCell) {
                                        sub_alpha = 1.0f - (t * t * (3.0f - 2.0f * t));
                                    }
                                    else {
                                        sub_alpha = 1.0f - (t * t * (1.0f + 0.25f * t));
                                    }
                                }
                            }

                            alpha_sum += sub_alpha;
                            effectiveSamples++;
                        }
                    }

                    // サブピクセルの平均を計算
                    alpha = effectiveSamples > 0 ? alpha_sum / (float)effectiveSamples : 0.0f;

                    // 超高密度時はAAをわずかに強化
                    if (isUltraSmallCell && alpha > 0.0f && alpha < 1.0f) {
                        alpha = _powf(alpha, 0.85f);
                    }
                } else {
                    // 標準のAA処理（単一サンプル）
                    if (!useAA || isLargeDot) {
                        // AAなしの場合または大きなドットの場合は単純な閾値処理
                        alpha = (normDist <= radius) ? 1.0f : 0.0f;
                    } else {
                        // 新しい適応型AA幅計算
                        float aaWidth = aaWidthBase;

                        // 大きなドットの場合はAAの幅を狭める
                        if (radius > 0.3f && radius <= 0.35f) {
                            // 中間サイズのドットではAAを弱める
                            aaWidth *= (0.35f - radius) * 3.33f; // 0.3→0.35で1→0に変化
                        }

                        // 超高密度時は幅を拡張
                        if (isVerySmallCell) {
                            aaWidth *= 1.0f + (8.0f - cellSize) * 0.1f;
                        }

                        // エッジ距離の計算
                        const float edgeDist = normDist - radius;

                        if (edgeDist < 0.0f) {
                            // ドット内部 - 完全に不透明
                            alpha = 1.0f;
                        }
                        else if (edgeDist < aaWidth) {
                            // エッジ部分 - 密度に応じて最適なカーブを選択
                            const float t = edgeDist / aaWidth;

                            if (isUltraSmallCell) {
                                // 超高密度用 - cosカーブ（非常に滑らか）
                                alpha = 0.5f * (1.0f + _cosf(PI * t));
                            }
                            else if (isVerySmallCell) {
                                // 高密度用 - smoothstep
                                alpha = 1.0f - (t * t * (3.0f - 2.0f * t));
                            }
                            else if (radius > 0.3f) {
                                // 大きめのドット用 - より急峻なカーブ
                                alpha = 1.0f - (t * t * t);
                            }
                            else {
                                // 標準密度用の3次曲線 - 少しシャープ
                                alpha = 1.0f - (t * t * (1.0f + 0.25f * t));
                            }

                            // 超高密度時はAAをわずかに強化
                            if (isUltraSmallCell && alpha > 0.0f && alpha < 1.0f) {
                                alpha = _powf(alpha, 0.85f);
                            }
                        }
                        else {
                            // エッジ外 - 完全に透明
                            alpha = 0.0f;
                        }
                    }
                }

                // 閾値による早期脱出
                if (alpha > 0.01f) {
                    const float currentDotLuma = useOriginalColor ? cellLuma : 0.0f;

                    // ボーナス係数を効率的に計算
                    const float dirBonus = (!isCurrentRowOffset && dy != 0) ? 0.3f : 0.0f;
                    const float rowTypeBonus = (isCurrentRowOffset == isCheckRowOffset) ? 0.2f : 0.0f;

                    // アルファスコア計算の効率化
                    const float alphaSq = alpha * alpha;
                    const float alphaCube = isCurrentRowOffset ? 0.0f : alphaSq * alpha * 0.2f;

                    // 高密度時の暗い部分を強調（条件分岐を最適化）
                    const float densityMod = 1.0f +
                                           (isVerySmallCell && currentDotLuma < 0.3f ?
                                           (0.3f - currentDotLuma) * 0.5f : 0.0f);

                    // スコア計算を統合
                    const float lumaScore = (1.0f - currentDotLuma) * 5.0f;
                    const float score = lumaScore * densityMod + alphaSq + alphaCube + dirBonus + rowTypeBonus;

                    if (score > bestScore) {
                        bestScore = score;
                        bestAlpha = alpha;
                        bestLuma = currentDotLuma;
                        bestRadius = radius; // 半径も保存
                        bestColor = useOriginalColor ? cellColor : to_float4(0.0f, 0.0f, 0.0f, 1.0f);
                        hasInfluence = true;
                    }
                }
            }
        }

        // 最適なドット適用方法を根本的に刷新
        if (hasInfluence) {
            const float bgLuma = result.x * 0.3f + result.y * 0.59f + result.z * 0.11f;
            const float darknessFactor = 1.0f - bestLuma;

            // 大きなドットかどうかチェック
            const bool isLargeDot = bestRadius > 0.35f;

            if (isLargeDot && bestAlpha > 0.8f && darknessFactor > 0.7f) {
                // 暗くて大きなドットは完全に上書き（ブレンドせず）
                result = bestColor;
            } else {
                // 密度とアルファに応じた柔軟なブレンド係数
                float adaptiveBlendFactor;

                if (isTinyCell) {
                    // 超小型セルでの特別処理
                    if (bestAlpha > 0.9f) {
                        // 高アルファでも柔軟なブレンド
                        adaptiveBlendFactor = 0.95f;
                    } else {
                        // より柔軟なブレンド（グレーの中間色を許可）
                        adaptiveBlendFactor = bestAlpha * (0.7f + darknessFactor * 0.3f);

                        // 高密度用微調整
                        if (isUltraSmallCell) {
                            adaptiveBlendFactor = _powf(adaptiveBlendFactor, 0.9f);
                        }
                    }
                } else {
                    // 中・大サイズドットの処理
                    if (bestAlpha > 0.7f) {
                        if (bestRadius > 0.3f) {
                            // 中〜大サイズの暗いドットは強いブレンド
                            adaptiveBlendFactor = 0.9f + bestAlpha * 0.1f;
                        } else {
                            // 標準サイズの中程度の暗さは通常ブレンド
                            adaptiveBlendFactor = 0.85f + bestAlpha * 0.15f;
                        }
                    } else {
                        // 通常のブレンド計算（暗さの影響も考慮）
                        adaptiveBlendFactor = bestAlpha * 0.7f + darknessFactor * bestAlpha * 0.3f;
                    }
                }

                // 密度調整係数を追加
                const float densityBoost = 1.0f + _fmaxf(0.0f, (8.0f - cellSize) * 0.05f);
                adaptiveBlendFactor *= densityBoost;

                // 行タイプによる調整
                adaptiveBlendFactor *= !isCurrentRowOffset ? 1.1f : 1.0f;

                // 最終的なブレンド係数のクランプ
                adaptiveBlendFactor = _fminf(adaptiveBlendFactor, 1.0f);

                // ブレンド処理（常に中間色が発生できるようにする）
                result.x = _mix(result.x, bestColor.x, adaptiveBlendFactor);
                result.y = _mix(result.y, bestColor.y, adaptiveBlendFactor);
                result.z = _mix(result.z, bestColor.z, adaptiveBlendFactor);
            }
        }

        // 紙の質感処理
        if (params->paperTexture > 0.01f) {
            // テクスチャタイプごとの事前計算を最適化
            float frequencyMod, intensityMod;

            switch(params->paperTextureType) {
                case 0: // Smooth
                    frequencyMod = 0.9f;
                    intensityMod = 0.6f;
                    break;
                case 1: // Light
                    frequencyMod = 0.5f;
                    intensityMod = 1.0f;
                    break;
                default: // Heavy
                    frequencyMod = 0.3f;
                    intensityMod = 1.8f;
                    break;
            }

            // ノイズ計算の最適化
            const float xyTerm = xf * 0.3f * frequencyMod + yf * 0.27f;
            const float yxTerm = yf * 0.13f * frequencyMod + xf * 0.07f;
            float baseNoise = _sinf(xyTerm) * _cosf(yxTerm);

            // Heavy用の特殊効果 - 条件分岐を削減
            if (params->paperTextureType == 2) {
                const float specialFactor = _fabs(_sinf(xf * 1.2f + yf * 1.3f));
                baseNoise += specialFactor > 0.96f ? 0.7f : 0.0f;
            }

            // ノイズ適用
            const float noiseIntensity = params->paperTexture * 0.25f * intensityMod;
            const float noise = (baseNoise * 0.5f + 0.5f) * noiseIntensity;

            const float paperTexOffset = params->paperTexture * 0.05f;
            const float noiseDiff = noise - paperTexOffset;
            const float noiseEffect = noiseDiff * (noiseDiff < 0.0f ? 1.5f : 1.2f);

            // 色に適用
            result.x = _clampf(result.x + noiseEffect, 0.0f, 1.0f);
            result.y = _clampf(result.y + noiseEffect, 0.0f, 1.0f);
            result.z = _clampf(result.z + noiseEffect, 0.0f, 1.0f);
        }

        // デバッグモード
        if (params->showCellBoundaries == 1) {
            const float gridLineThickness = 1.0f;
            const int currentCellX = (int)(xf / cellSizeX);
            const int currentCellY = (int)(yf / cellRowSpacing);
            const float cellLeft = currentCellX * cellSizeX;
            const float cellTop = currentCellY * cellRowSpacing;
            const float rowOffset = ((currentCellY & 1) != 0) ? cellSizeX * zigzagFactor : 0.0f;

            // 境界チェック
            if (_fabs(yf - cellTop) < gridLineThickness ||
                _fabs(yf - (cellTop + cellSizeY)) < gridLineThickness ||
                _fabs(xf - (cellLeft + rowOffset)) < gridLineThickness ||
                _fabs(xf - (cellLeft + rowOffset + cellSizeX)) < gridLineThickness) {
                result = to_float4(0.0f, 1.0f, 0.0f, 1.0f);
            }
            else {
                const float centerX = currentCellX * cellSizeX + rowOffset + cellSizeX * 0.5f;
                const float centerY = currentCellY * cellRowSpacing + cellSizeY * 0.5f;

                if (_fabs(xf - centerX) < 2.0f && _fabs(yf - centerY) < 2.0f) {
                    result = to_float4(0.0f, 0.0f, 1.0f, 1.0f); // 中心点
                }
            }
        }

        _tex2DVec4Write(dst, x, y, result);
    }
}
]]

-- CMYKモード処理用のカーネル
CmykKernel = [[
__KERNEL__ void CmykKernel(__CONSTANTREF__ HalftoneParams *params, __TEXTURE2D__ src, __TEXTURE2D_WRITE__ dst)
{
    DEFINE_KERNEL_ITERATORS_XY(x, y);

    if (x < params->srcSize[0] && y < params->srcSize[1])
    {
        // 基本設定 スクリーン線数からドットサイズを計算
        float cellSize = 1000.0f / _fmaxf(0.1f, params->screenDensity);

        // 現在のピクセルの正規化座標
        float xNorm = (float)x / (float)params->srcSize[0];
        float yNorm = (float)y / (float)params->srcSize[1];
        float2 pixelUV = to_float2(xNorm, yNorm);

        // 現在のピクセルの色を取得
        float4 pixelColor = _tex2DVecN(src, pixelUV.x, pixelUV.y, 15);

        // デフォルト値として背景色を設定
        float4 result = to_float4(
            params->paperColor[0],
            params->paperColor[1],
            params->paperColor[2],
            params->paperColor[3]
        );

        // 事前計算
        float xf = (float)x;
        float yf = (float)y;

        // 各チャンネル（CMYK）ごとに処理
        float angles[4] = {18.4f, 71.6f, 0.0f, 45.0f}; // C、M、Y、Kの角度
        float3 colors[3] = {
            to_float3(0.0f, 0.85f, 0.85f), // シアン（より濃いめ）
            to_float3(0.85f, 0.0f, 0.85f), // マゼンタ（より濃いめ）
            to_float3(0.85f, 0.85f, 0.0f)  // イエロー（より濃いめ）
        };

        // サイズ係数を計算
        float cellSizes[4];
        for (int i = 0; i < 4; i++) {
            cellSizes[i] = cellSize;
            if (i == 1) cellSizes[i] *= 1.05f;      // マゼンタ
            else if (i == 2) cellSizes[i] *= 0.95f; // イエロー
        }

        // 基本オフセットとレジストレーションエラー
        float2 offsets[4];
        for (int i = 0; i < 4; i++) {
            offsets[i] = to_float2(0.0f, 0.0f);
        }
        offsets[1].x = cellSizes[1] * 0.25f;
        offsets[2].y = cellSizes[2] * 0.25f;
        offsets[3].x = cellSizes[3] * 0.125f;
        offsets[3].y = cellSizes[3] * 0.125f;

        // レジストレーションエラーを計算（最適化）
        if (params->regError > 0.01f) {
            float regScale = params->regError * cellSize * 0.1f;
            offsets[0].x += regScale * 0.53f;
            offsets[0].y += regScale * 0.23f;
            offsets[1].x -= regScale * 0.33f;
            offsets[1].y += regScale * 0.41f;
            offsets[2].x += regScale * 0.17f;
            offsets[2].y -= regScale * 0.37f;
        }

        // 各チャンネルの影響度
        float channelMask[4] = {0.0f, 0.0f, 0.0f, 0.0f};
        float4 channelColors[4];
        bool hasChannelInfluence[4] = {false, false, false, false};

        // CMYKの各チャンネルごとの処理
        for (int channel = 0; channel < 4; channel++) {
            float angle = angles[channel] * 0.01745329f; // ラジアンに変換
            float cosAngle = _cosf(angle);
            float sinAngle = _sinf(angle);

            // 回転とオフセットを適用
            float rotX = xf * cosAngle - yf * sinAngle + offsets[channel].x;
            float rotY = xf * sinAngle + yf * cosAngle + offsets[channel].y;

            // 最も近いセルの中心を見つける
            int cellIdX = (int)(rotX / cellSizes[channel]);
            int cellIdY = (int)(rotY / cellSizes[channel]);

            // 周囲のセルをチェック - 検索範囲を最適化
            for (int dy = -1; dy <= 1; dy++) {
                for (int dx = -1; dx <= 1; dx++) {
                    // 対角セルの場合は効率化（対角セルは距離が遠いので75%スキップ）
                    if (abs(dx) + abs(dy) == 2) {
                        if (_fabs(_sinf(xf * 12.34f + yf * 56.78f)) > 0.5f) {
                            continue;
                        }
                    }

                    int checkX = cellIdX + dx;
                    int checkY = cellIdY + dy;

                    // 奇数行は水平方向にオフセット
                    float offsetX = ((checkY % 2) != 0) ? 0.5f : 0.0f;

                    // セル中心座標
                    float cellCenterX = (checkX + offsetX) * cellSizes[channel];
                    float cellCenterY = checkY * cellSizes[channel] + cellSizes[channel] * 0.5f;

                    // 特別なセルパターン調整（K版のみ）
                    if (channel == 3) {
                        bool isOddCell = ((checkX + checkY) % 2 != 0);
                        float adjustY = isOddCell ? 0.075f : -0.075f;
                        cellCenterY += cellSizes[channel] * adjustY;

                        // 市松模様補正
                        if ((checkY % 2) != 0 && (checkX % 2) == 0) {
                            cellCenterY += cellSizes[channel] * 0.075f;
                        } else if ((checkY % 2) == 0 && (checkX % 2) != 0) {
                            cellCenterY -= cellSizes[channel] * 0.075f;
                        }
                    }

                    // 現在のピクセルからセル中心への距離
                    float distX = rotX - cellCenterX;
                    float distY = rotY - cellCenterY;
                    float dist = _sqrtf(distX*distX + distY*distY);

                    // 早期脱出条件を強化（性能改善）
                    if (dist > cellSizes[channel] * 0.75f) continue;

                    // セル中心の画像上の座標に変換
                    float invX = cellCenterX * cosAngle + cellCenterY * sinAngle - offsets[channel].x;
                    float invY = -cellCenterX * sinAngle + cellCenterY * cosAngle - offsets[channel].y;

                    // 正規化座標
                    float centerUVx = invX * (1.0f / (float)params->srcSize[0]);
                    float centerUVy = invY * (1.0f / (float)params->srcSize[1]);

                    // テクスチャ範囲内かチェック
                    if (centerUVx >= 0.0f && centerUVx <= 1.0f && centerUVy >= 0.0f && centerUVy <= 1.0f) {
                        // セル中心の色
                        float4 cellColor = _tex2DVecN(src, centerUVx, centerUVy, 15);

                        // チャンネル値計算 - UCR/GCR処理を適用
                        float channelValue = 0.0f;

                        // CMY版の場合
                        if (channel < 3) {
                            channelValue = channel == 0 ? (1.0f - cellColor.x) :
                                          (channel == 1 ? (1.0f - cellColor.y) : (1.0f - cellColor.z));

                            // UCR処理
                            if (params->ucrAmount > 0.0f) {
                                float minVal = _fminf(_fminf(1.0f-cellColor.x, 1.0f-cellColor.y), 1.0f-cellColor.z);
                                channelValue -= minVal * params->ucrAmount;
                                channelValue = _fmaxf(0.0f, channelValue);
                            }
                        } else {
                            // K版の場合
                            channelValue = 1.0f - _fmaxf(_fmaxf(cellColor.x, cellColor.y), cellColor.z);

                            // UCR強化
                            if (params->ucrAmount > 0.0f) {
                                float minVal = _fminf(_fminf(1.0f-cellColor.x, 1.0f-cellColor.y), 1.0f-cellColor.z);
                                channelValue = _fminf(1.0f, channelValue + minVal * params->ucrAmount * 0.7f);
                            }
                        }

                        // コントラスト調整
                        channelValue = _clampf((channelValue - 0.5f) * params->contrast + 0.5f, 0.0f, 1.0f);

                        // ドット半径計算（最適化）
                        float radius = 0.5f * channelValue;
                        radius = _fmaxf(radius, 0.01f);

                        // ドットゲイン効果（条件分岐削減）
                        radius *= (1.0f + params->dotGain * 0.3f);

                        // セル半径と距離を比較
                        float normDist = dist / cellSizes[channel];

                        // アンチエイリアス処理
                        float edge = radius;
                        float aaWidth = 0.7f / cellSizes[channel] * params->aaStrength;
                        float t = _clampf((normDist - edge + aaWidth) / _fmaxf(aaWidth, 0.0001f), 0.0f, 1.0f);
                        float alpha = 1.0f - (t * t * (3.0f - 2.0f * t)); // smoothstep

                        // 影響度の更新
                        if (alpha > 0.01f && alpha > channelMask[channel]) {
                            channelMask[channel] = alpha;
                            hasChannelInfluence[channel] = true;

                            // 色の設定
                            if (channel < 3) {
                                if (params->useOriginalColor == 1) {
                                    // 元の色を基に、該当チャンネルだけ削除
                                    // 紙の色ではなく純粋な黒または他のチャンネル値を使用
                                    channelColors[channel] = cellColor;
                                    if (channel == 0) channelColors[channel].x = 0.0f; // 紙の色に関係なく0に
                                    else if (channel == 1) channelColors[channel].y = 0.0f; // 紙の色に関係なく0に
                                    else channelColors[channel].z = 0.0f; // 紙の色に関係なく0に
                                } else {
                                    // プロセスカラーも紙の色に影響されない固定値
                                    channelColors[channel] = to_float4(colors[channel].x, colors[channel].y, colors[channel].z, 1.0f);
                                }
                            } else {
                                // K版は常に純粋な黒（紙の色に関係なく）
                                channelColors[channel] = to_float4(0.0f, 0.0f, 0.0f, 1.0f);
                            }
                        }
                    }
                }
            }
        }

        // CMY版の適用（最適化）
        float4 cmyResult;
        // 紙の色の代わりに純粋な白から始める（インク色用）
        cmyResult = to_float4(1.0f, 1.0f, 1.0f, 1.0f);

        float totalMask = 0.0f;

        // マスクの合計を先に計算
        for (int i = 0; i < 3; i++) {
            if (hasChannelInfluence[i] && channelMask[i] > 0.0f) {
                totalMask += channelMask[i];
            }
        }

        // 単純化したブレンド処理
        for (int i = 0; i < 3; i++) {
            if (hasChannelInfluence[i] && channelMask[i] > 0.0f) {
                float factor = channelMask[i];

                if (factor > 0.5f) {
                    // 最小値で合成（よりダークになるように）
                    cmyResult.x = _fminf(cmyResult.x, channelColors[i].x);
                    cmyResult.y = _fminf(cmyResult.y, channelColors[i].y);
                    cmyResult.z = _fminf(cmyResult.z, channelColors[i].z);
                } else {
                    // エッジ部分はブレンド
                    float blendFactor = factor * 2.5f;
                    cmyResult.x = _mix(cmyResult.x, _fminf(cmyResult.x, channelColors[i].x), blendFactor);
                    cmyResult.y = _mix(cmyResult.y, _fminf(cmyResult.y, channelColors[i].y), blendFactor);
                    cmyResult.z = _mix(cmyResult.z, _fminf(cmyResult.z, channelColors[i].z), blendFactor);
                }
            }
        }

        // 全体の濃度調整（最適化）
        if (totalMask > 0.0f) {
            float darkening = _fminf(totalMask / 3.0f * 0.2f, 0.2f);
            float brightnessFactor = 1.0f - darkening;
            cmyResult.x *= brightnessFactor;
            cmyResult.y *= brightnessFactor;
            cmyResult.z *= brightnessFactor;
        }

        // K版の適用
        float4 inkResult = cmyResult;  // inkResultはインク色のみを計算
        if (hasChannelInfluence[3] && channelMask[3] > 0.0f) {
            if (channelMask[3] > 0.5f) {
                // 中心部分は黒で上書き
                inkResult = to_float4(0.0f, 0.0f, 0.0f, 1.0f);
            } else {
                // エッジブレンド
                float blendFactor = channelMask[3] * 2.0f;
                inkResult = _mix(cmyResult, to_float4(0.0f, 0.0f, 0.0f, 1.0f), blendFactor);
            }
        }

        // インク色と紙の色を合成（インク部分のマスクを計算）
        float inkMask = 0.0f;
        for (int i = 0; i < 4; i++) {
            if (hasChannelInfluence[i]) {
                inkMask = _fmaxf(inkMask, channelMask[i]);
            }
        }

        // インク色と紙の色（またはオリジナル背景）をブレンド
        if (inkMask > 0.001f) {
            result = _mix(result, inkResult, inkMask);
        } else {
            // インクの影響がない場合はそのまま背景色
        }

        // 紙の質感適用（効率化）
        if (params->paperTexture > 0.01f) {
            float noise = 0.0f;
            float intensityMod = 1.0f;
            float frequencyMod = 1.0f;

            // 紙のタイプに応じたパラメータ設定
            if (params->paperTextureType == 0) { // Smooth
                frequencyMod = 0.9f;
                intensityMod = 0.6f;
            }
            else if (params->paperTextureType == 1) { // Light
                frequencyMod = 0.5f;
                intensityMod = 1.0f;
            }
            else { // Heavy
                frequencyMod = 0.3f;
                intensityMod = 1.8f;
            }

            // 共通の効率的なノイズ計算
            float baseNoise = _sinf(xf * 0.3f * frequencyMod + yf * 0.27f) *
                             _cosf(yf * 0.13f * frequencyMod + xf * 0.07f);

            // Heavy Texture用に追加の粒状感
            if (params->paperTextureType == 2 &&
                _fabs(_sinf(xf * 1.2f + yf * 1.3f)) > 0.96f) {
                baseNoise += 0.7f;
            }

            noise = (baseNoise * 0.5f + 0.5f) * params->paperTexture * 0.25f * intensityMod;

            // コントラスト調整（分岐を減らす）
            float noiseEffect = noise - params->paperTexture * 0.05f;
            noiseEffect *= (noise < 0.0f) ? 1.5f : 1.2f;

            // 色に適用
            result.x = _clampf(result.x + noiseEffect, 0.0f, 1.0f);
            result.y = _clampf(result.y + noiseEffect, 0.0f, 1.0f);
            result.z = _clampf(result.z + noiseEffect, 0.0f, 1.0f);
        }

        _tex2DVec4Write(dst, x, y, result);
    }
}
]]

function Create()
    local groupID = 0

    InUseCMYKMode = self:AddInput("CMYK Mode", "UseCMYKMode", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Integer = true,
        INP_Default = 0.0,
        INPS_StatusText = "Enables CMYK-style halftone separation",
    })

    InScreenDensity = self:AddInput("Screen Density", "ScreenDensity", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 150.0,
        INP_MinAllowed = 0.001,
        INP_MaxAllowed = 600.0,
        INPID_PreviewControl = "RangeControl",
        INP_Integer = false,
        INPS_StatusText = "Controls the density of the halftone pattern in CMYK mode",
    })

    InContrast = self:AddInput("Contrast", "Contrast", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 1.0,
        INP_MinAllowed = 0.1,
        INP_MaxAllowed = 15.0,
        INPS_StatusText = "Adjusts the contrast of the halftone pattern",
    })

    InUseOriginalColor = self:AddInput("Use Original Color", "UseOriginalColor", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Default = 0.0,
        INPS_StatusText = "Preserves original colors instead of black and white",
    })

    InAAStrength = self:AddInput("AA Strength", "AAStrength", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.3,
        INP_MinAllowed = 0.0,
        INP_MaxAllowed = 5.0,
        INPS_StatusText = "Controls the strength of anti-aliasing on dot edges",
    })

    InUseSubSamplingAA = self:AddInput("Use Subsampling AA", "UseSubSamplingAA", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Integer = true,
        INP_Default = 1,
        INPS_StatusText = "Enable subsampling anti-aliasing for high-quality edges",
    })

    InSubSampleCount = self:AddInput("Subsample Count", "SubSampleCount", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ComboControl",
        INP_Integer = true,
        INP_Default = 2,
        { CCS_AddString = "4 samples (2x2)" },
        { CCS_AddString = "9 samples (3x3)" },
        { CCS_AddString = "16 samples (4x4)" },
        INPS_StatusText = "Number of subsamples for high-quality AA",
    })

    InDotGain = self:AddInput("Dot Gain", "DotGain", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.08,
        INP_MinAllowed = -0.5,
        INP_MaxAllowed = 0.5,
        INPS_StatusText = "Simulates ink spread on paper",
    })

    InRegError = self:AddInput("Registration Error", "RegError", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.2,
        INP_MinAllowed = 0.0,
        INP_MaxAllowed = 1.0,
        INPS_StatusText = "Simulates misalignment between color plates",
    })

    InUcrAmount = self:AddInput("UCR Amount", "UcrAmount", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.5,
        INP_MinAllowed = 0.0,
        INP_MaxAllowed = 1.0,
        INPS_StatusText = "Controls Under Color Removal in CMYK mode",
    })

    self:BeginControlNest("Paper", "Paper", true);

    InPaperTexture = self:AddInput("Paper Texture", "PaperTexture", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.1,
        INP_MinAllowed = 0.0,
        INP_MaxAllowed = 1.0,
        INPS_StatusText = "Adds simulated paper texture to the output",
    })

    InPaperType = self:AddInput("Paper Type", "PaperType", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ComboControl",
        INP_Default = 0,
        INP_Integer = true,
        { CCS_AddString = "Smooth" },
        { CCS_AddString = "Light Texture" },
        { CCS_AddString = "Heavy Texture" },
        INPS_StatusText = "Selects the type of paper texture pattern",
    })

    InPaperColorPreset = self:AddInput("Paper Color Preset", "PaperColorPreset", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ComboControl",
        INP_Default = 0,
        INP_Integer = true,
        INP_DoNotifyChanged = true,
        { CCS_AddString = "Custom" },
        { CCS_AddString = "Pure White" },
        { CCS_AddString = "Warm White" },
        { CCS_AddString = "Cool White" },
        { CCS_AddString = "Natural White" },
        { CCS_AddString = "Cream" },
        { CCS_AddString = "Ivory" },
        { CCS_AddString = "Light Gray" },
        { CCS_AddString = "Newspaper" },
        { CCS_AddString = "Vintage" },
        { CCS_AddString = "Kraft" },
        { CCS_AddString = "Recycled" },
        { CCS_AddString = "Light Blue" },
        { CCS_AddString = "Light Green" },
        { CCS_AddString = "Light Pink" },
        { CCS_AddString = "Light Yellow" },
        INPS_StatusText = "Select from common paper color presets",
    })

    groupID = groupID + 1
    InPaperColorRed = self:AddInput("Paper Color Red", "PaperColorRed", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupID,
        IC_ControlID       = 0, -- Red ID
        INPS_StatusText    = "Sets the paper color (background)",
    })

    InPaperColorGreen = self:AddInput("Paper Color Green", "PaperColorGreen", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupID,
        IC_ControlID       = 1, -- Green ID
        INPS_StatusText    = "Sets the paper color (background)",
    })

    InPaperColorBlue = self:AddInput("Paper Color Blue", "PaperColorBlue", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupID,
        IC_ControlID       = 2, -- Blue ID
        INPS_StatusText    = "Sets the paper color (background)",
    })

    InPaperColorAlpha = self:AddInput("Paper Color Alpha", "PaperColorAlpha", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupID,
        IC_ControlID       = 3, -- Alpha ID
        INPS_StatusText    = "Sets the paper color (background)",
    })
    self:EndControlNest()


    InShowCellBoundaries = self:AddInput("Show Cell Boundaries", "ShowCellBoundaries", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Integer = true,
        INP_Default = 0.0,
        INPS_StatusText = "Debug: Show cell boundaries with green lines",
    })

    InImage = self:AddInput("Input Image", "Image", {
        LINKID_DataType = "Image",
        LINK_Main = 1,
        INPS_StatusText = "Input image to be processed",
    })
end

function Process(req)
    local contrast = InContrast:GetValue(req).Value
    local useOriginalColor = InUseOriginalColor:GetValue(req).Value
    local useCMYKMode = InUseCMYKMode:GetValue(req).Value
    local aaStrength = InAAStrength:GetValue(req).Value
    local useSubSamplingAA = InUseSubSamplingAA:GetValue(req).Value
    local subSampleCountOption = InSubSampleCount:GetValue(req).Value
    local screenDensity = InScreenDensity:GetValue(req).Value
    local dotGain = InDotGain:GetValue(req).Value
    local regError = InRegError:GetValue(req).Value
    local ucrAmount = InUcrAmount:GetValue(req).Value
    local paperTexture = InPaperTexture:GetValue(req).Value
    local paperType = InPaperType:GetValue(req).Value
    local paperColor = {
        InPaperColorRed:GetValue(req).Value,
        InPaperColorGreen:GetValue(req).Value,
        InPaperColorBlue:GetValue(req).Value,
        InPaperColorAlpha:GetValue(req).Value,
    }

    -- サブサンプル数の計算
    local subSampleCount
    if subSampleCountOption == 0 then
        subSampleCount = 4  -- 2x2
    elseif subSampleCountOption == 1 then
        subSampleCount = 9  -- 3x3
    else
        subSampleCount = 16 -- 4x4
    end

    local img = InImage:GetValue(req)
    local out

    if img then
        out = Image({ IMG_Like = img })

        -- CMYKモードかどうかによってカーネルを選択
        local kernelName, kernelCode
        if useCMYKMode > 0.5 then
            kernelName = "CmykKernel"
            kernelCode = CmykKernel
        else
            kernelName = "HalftoneKernel"
            kernelCode = HalftoneKernel
        end

        local node = DVIPComputeNode(req, kernelName, kernelCode, "HalftoneParams", HalftoneParams)

        if node then
            -- create image
            local params = node:GetParamBlock(HalftoneParams)

            -- 基本パラメータ設定
            params.contrast = contrast
            params.screenDensity = screenDensity
            params.srcSize[0] = out.DataWindow:Width()
            params.srcSize[1] = out.DataWindow:Height()
            params.useOriginalColor = useOriginalColor > 0.5 and 1 or 0
            params.useCMYKMode = useCMYKMode > 0.5 and 1 or 0
            params.dotAngle = 0.0
            params.aaStrength = aaStrength
            params.useSubSamplingAA = useSubSamplingAA > 0.5 and 1 or 0
            params.subSampleCount = subSampleCount
            params.dotGain = dotGain
            params.regError = regError
            params.ucrAmount = ucrAmount
            params.paperTexture = paperTexture
            params.paperTextureType = paperType
            params.paperColor[0] = paperColor[1] -- R
            params.paperColor[1] = paperColor[2] -- G
            params.paperColor[2] = paperColor[3] -- B
            params.paperColor[3] = paperColor[4] -- A
            params.showCellBoundaries = InShowCellBoundaries:GetValue(req).Value > 0.5 and 1 or 0

            node:SetParamBlock(params)

            node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR, TEX_ADDRESS_MODE_CLAMP, TEX_NORMALIZED_COORDS_TRUE)
            node:AddInput("src", img)
            node:AddOutput("dst", out)

            success = node:RunSession(req)
        else
            out = nil
        end
    end

    OutImage:Set(req, out)
end

function NotifyChanged(inp, param, time)
    if inp == InPaperColorPreset then
        -- 紙の色プリセットが選択された場合
        local presetIndex = math.floor(param.Value + 0.5)

        -- プリセット値の設定
        local r, g, b = 1.0, 1.0, 1.0 -- デフォルト値（白）

        if presetIndex == 1 then      -- Pure White
            r, g, b = 1.00, 1.00, 1.00
        elseif presetIndex == 2 then  -- Warm White
            r, g, b = 1.00, 0.98, 0.94
        elseif presetIndex == 3 then  -- Cool White
            r, g, b = 0.97, 0.97, 1.00
        elseif presetIndex == 4 then  -- Natural White
            r, g, b = 0.98, 0.98, 0.96
        elseif presetIndex == 5 then  -- Cream
            r, g, b = 0.97, 0.95, 0.86
        elseif presetIndex == 6 then  -- Ivory
            r, g, b = 1.00, 0.97, 0.90
        elseif presetIndex == 7 then  -- Light Gray
            r, g, b = 0.90, 0.90, 0.90
        elseif presetIndex == 8 then  -- Newspaper
            r, g, b = 0.93, 0.91, 0.83
        elseif presetIndex == 9 then  -- Vintage
            r, g, b = 0.96, 0.92, 0.80
        elseif presetIndex == 10 then -- Kraft
            r, g, b = 0.85, 0.75, 0.58
        elseif presetIndex == 11 then -- Recycled
            r, g, b = 0.87, 0.87, 0.82
        elseif presetIndex == 12 then -- Light Blue
            r, g, b = 0.90, 0.95, 1.00
        elseif presetIndex == 13 then -- Light Green
            r, g, b = 0.90, 0.98, 0.90
        elseif presetIndex == 14 then -- Light Pink
            r, g, b = 1.00, 0.90, 0.93
        elseif presetIndex == 15 then -- Light Yellow
            r, g, b = 1.00, 1.00, 0.88
        end

        -- カラーコントロールに値をセット
        if presetIndex > 0 then
            InPaperColorRed:SetSource(Number(r), time)
            InPaperColorGreen:SetSource(Number(g), time)
            InPaperColorBlue:SetSource(Number(b), time)
        end
    end

    return true
end
