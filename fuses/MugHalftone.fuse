FuRegisterClass("MugHalftone", CT_SourceTool, {
    REGS_Category          = "Fuses\\Mug",
    REGS_OpIconString      = "MHT",
    REGS_OpDescription     = "Mug Halftone",
    REGS_HelpTopic         = "https://x.com/MugLab3", --This can be a URL
    REGS_URL               = "https://www.youtube.com/@MugLabVideoEditing",
    -- REGS_IconID            = "Icons.Tools.Icons.Example", -- This can be Inline as an array of Values
    REG_OpNoMask           = false,
    REG_NoObjMatCtrls      = false,
    REG_NoMotionBlurCtrls  = false,
    REG_Source_GlobalCtrls = true,
    REG_Source_SizeCtrls   = true,
    REG_Source_AspectCtrls = true,
    REG_Source_DepthCtrls  = true,
    REG_Version            = 0.1,
})

-- パラメーター構造体
HalftoneParams = [[
  int srcSize[2];        // ソース画像のサイズ
  float contrast;        // コントラスト調整（1.0がデフォルト）
  int useOriginalColor;  // 元の色を使用するかどうか（0=白黒、1=カラー）
  int useOriginalBackground; // 背景も元の色にするかどうか（0=紙の色、1=元の色）
  int useCMYKMode;       // CMYKモードを使用するかどうか（0=標準ハーフトーン、1=CMYKスタイル）
  float dotAngle;        // ドットの角度（CMYK モードでのみ使用）
  float aaStrength;      // アンチエイリアス強度（0.0=無効、1.0=強い）
  float dotGain;         // ドットゲイン効果の強さ（0.0-1.0）
  float regError;        // 色版ずれの程度（0.0-1.0）
  float ucrAmount;       // UCR/GCR適用量（0.0-1.0）
  float paperTexture;    // 紙の質感強度（0.0-1.0）
  int paperTextureType;  // 紙の種類（0=なめらか、1=わずかな繊維、2=強い繊維）
  float screenDensity;   // スクリーンの密度
  float paperColor[4];   // 紙の色（背景色）[R,G,B,A]
  int showCellBoundaries; // セル境界を表示（デバッグ用）
]]

-- 標準ハーフトーンカーネル
HalftoneKernel = [[
__KERNEL__ void HalftoneKernel(__CONSTANTREF__ HalftoneParams *params, __TEXTURE2D__ src, __TEXTURE2D_WRITE__ dst)
{
    DEFINE_KERNEL_ITERATORS_XY(x, y);

    // 六角形パターンの方向ベクトル（定数）
    // 偶数行用の隣接セル相対位置
    const int hexNeighborsEven[6][2] = {
        {-1, 0}, {1, 0},   // 左右
        {-1, -1}, {0, -1}, // 左上、右上
        {-1, 1}, {0, 1}    // 左下、右下
    };

    // 奇数行用の隣接セル相対位置
    const int hexNeighborsOdd[6][2] = {
        {-1, 0}, {1, 0},  // 左右
        {0, -1}, {1, -1}, // 左上、右上
        {0, 1}, {1, 1}    // 左下、右下
    };

    if (x < params->srcSize[0] && y < params->srcSize[1])
    {
        // 定数の事前計算
        const float SIN60 = 0.866025f; // √3/2
        const float MAX_DOT_RADIUS = 0.433f;

        // 基本ドットサイズ設定 - 事前計算の拡充
        float cellSize = 1000.0f / params->screenDensity;
        float cellSizeX = cellSize;
        float cellSizeY = cellSize * SIN60;
        float cellRowSpacing = MAX_DOT_RADIUS * 2.0f * cellSizeX * 0.88f;
        float zigzagFactor = 0.5f;

        // 平方根計算コストを下げるための閾値の二乗
        float centerThresholdSq = 0.75f;
        float distThresholdBaseSq = 0.625f * 0.625f;
        float distThresholdAltSq = 0.645f * 0.645f;
        float verticalBoostFactor = 1.1025f; // 1.05^2

        // ドット形状の高密度時補正係数
        float highDensityFactor = _fmaxf(1.0f, _fminf(1.5f, 200.0f / params->screenDensity));

        // 高密度補正のAA調整値
        float aaDensityFactor = _fminf(1.0f + (200.0f / params->screenDensity) * 0.15f, 1.3f);
        float aaWidthBase = params->aaStrength > 0.001f ?
                          _fmaxf(0.5f / cellSizeX * params->aaStrength * aaDensityFactor, 0.005f) :
                          0.0f;

        // 座標正規化
        float xf = (float)x;
        float yf = (float)y;
        float xNorm = xf / (float)params->srcSize[0];
        float yNorm = yf / (float)params->srcSize[1];
        float4 pixelColor = _tex2DVecN(src, xNorm, yNorm, 15);

        // デフォルト値として背景色を設定
        float4 result = params->useOriginalBackground == 1 ?
                      pixelColor :
                      to_float4(params->paperColor[0], params->paperColor[1], params->paperColor[2], params->paperColor[3]);

        // セルのグリッド計算 - 行間を縮小して上下に重なるように (整数演算を維持)
        int cellIdX = (int)(xf / cellSizeX);
        int cellIdY = (int)(yf / cellRowSpacing);

        // 現在の行がオフセットされているかをチェック (ビット演算で最適化)
        bool isCurrentRowOffset = ((cellIdY & 1) != 0);

        // テクスチャサイズの逆数を事前計算 (除算を乗算に変換)
        float invSrcSizeX = 1.0f / (float)params->srcSize[0];
        float invSrcSizeY = 1.0f / (float)params->srcSize[1];

        // 効率的なスコアリング用の変数を事前に準備
        float bestAlpha = 0.0f;
        float bestLuma = 1.0f;
        float4 bestColor = result;
        bool hasInfluence = false;
        float bestScore = -1.0f;

        // dotGain補正 - 高密度時はより強めに
        float densityBasedGain = params->dotGain * (1.0f + (8.0f - _fminf(cellSize, 8.0f)) * 0.04f);
        float dotGainFactor = 1.0f + densityBasedGain * 0.3f;

        // 小セル時のブースト - 高密度時は補正値を増加
        float smallCellBoost = cellSize < 12.0f ?
                              (1.0f + (12.0f - cellSize) * (_fminf(0.06f, 0.03f * highDensityFactor))) :
                              1.0f;

        // 中心セルを最初にチェック - 最も重要なセル
        {
            float rowOffsetX = isCurrentRowOffset ? cellSizeX * zigzagFactor : 0.0f;
            float cellCenterX = cellIdX * cellSizeX + rowOffsetX + cellSizeX * 0.5f;
            float cellCenterY = cellIdY * cellRowSpacing + cellSizeY * 0.5f;

            // 距離計算 (正規化した形で計算)
            float distX = xf - cellCenterX;
            float distY = yf - cellCenterY;

            // 高密度時の歪み補正 - XY比を調整
            if (cellSize < 10.0f) {
                // Y方向の圧縮を少し緩和（六角形特性に合わせる）
                distY *= _fmaxf(0.8f, 1.0f - (10.0f - cellSize) * 0.02f);
            }

            float distXNorm = distX / cellSizeX;
            float distYNorm = distY / cellSizeY;
            float normDistSq = distXNorm*distXNorm + distYNorm*distYNorm;

            // 高密度時の六角形形状への補正
            if (cellSize < 8.0f) {
                // 方向による補正係数
                float dirFactor = _fabs(distXNorm) / (_fabs(distYNorm) + 0.001f);

                // 六角形に近づくよう方向による調整
                if (dirFactor > 1.5f) {
                    // X方向優勢の場合、水平方向に引き伸ばす
                    normDistSq *= _fmaxf(0.85f, 1.0f - (8.0f - cellSize) * 0.02f);
                } else if (dirFactor < 0.65f) {
                    // Y方向優勢の場合、垂直方向に引き伸ばす
                    normDistSq *= _fmaxf(0.90f, 1.0f - (8.0f - cellSize) * 0.015f);
                }
            }

            // 早期脱出で効率化
            if (normDistSq <= centerThresholdSq) {
                float centerUVx = cellCenterX * invSrcSizeX;
                float centerUVy = cellCenterY * invSrcSizeY;

                // テクスチャ範囲チェックを一度に実行
                if (centerUVx >= 0.0f && centerUVx <= 1.0f &&
                    centerUVy >= 0.0f && centerUVy <= 1.0f)
                {
                    float4 cellColor = _tex2DVecN(src, centerUVx, centerUVy, 15);

                    // 輝度とコントラスト計算 (輝度計算を1回に)
                    float cellLuma = cellColor.x * 0.3f + cellColor.y * 0.59f + cellColor.z * 0.11f;
                    cellLuma = _clampf((cellLuma - 0.5f) * params->contrast + 0.5f, 0.0f, 1.0f);

                    // 効率的なドット半径計算 - 高密度時の形状補正
                    float radius = MAX_DOT_RADIUS * (1.0f - cellLuma);
                    radius = _fmaxf(radius, 0.01f);

                    // 高密度時は小さな暗いドットでも見えるように最小値を調整
                    if (cellSize < 6.0f && cellLuma < 0.4f) {
                        radius = _fmaxf(radius, 0.08f * (1.0f - cellSize / 6.0f));
                    }

                    // 条件分岐を削減し、計算を一括化
                    if (cellLuma < 0.3f) {
                        radius += (0.3f - cellLuma) * 0.15f;
                    }

                    radius *= smallCellBoost * dotGainFactor;

                    // アンチエイリアス処理 (条件分岐を削減)
                    float normDist = _sqrtf(normDistSq);  // √が必要なのはここだけ
                    float alpha;

                    if (params->aaStrength <= 0.001f) {
                        alpha = (normDist <= radius) ? 1.0f : 0.0f;
                    } else {
                        // 高密度時はAAの範囲を広げる（特に小さなドット）
                        float t = _clampf((normDist - radius + aaWidthBase) /
                                         _fmaxf(aaWidthBase, 0.0001f), 0.0f, 1.0f);
                        // より六角形に近いAAカーブ
                        alpha = 1.0f - (t * t * (1.0f + 0.25f * t));
                    }

                    // 最適化されたセル評価
                    if (alpha > 0.01f) {
                        float currentDotLuma = params->useOriginalColor == 1 ?
                                             cellLuma : 0.0f;

                        // スコア計算を簡略化
                        float lumaScore = (1.0f - currentDotLuma) * 5.0f;
                        float alphaScore = alpha * alpha * 1.2f; // powf()を乗算で置換
                        float score = lumaScore + alphaScore;

                        bestScore = score;
                        bestAlpha = alpha;
                        bestLuma = currentDotLuma;
                        bestColor = params->useOriginalColor == 1 ? cellColor : to_float4(0.0f, 0.0f, 0.0f, 1.0f);
                        hasInfluence = true;
                    }
                }
            }
        }

        // ルックアップテーブルを効率的に使うための処理
        const int (*hexNeighbors)[2] = isCurrentRowOffset ?
                              hexNeighborsOdd :
                              hexNeighborsEven;

        // 効率化のため固定ループを展開
        #pragma unroll
        for (int i = 0; i < 6; i++) {
            int dx = hexNeighbors[i][0];
            int dy = hexNeighbors[i][1];

            int checkX = cellIdX + dx;
            int checkY = cellIdY + dy;

            // 行オフセット計算 (整数演算と条件分岐の最適化)
            bool isCheckRowOffset = ((checkY & 1) != 0);
            float rowOffsetX = isCheckRowOffset ? cellSizeX * zigzagFactor : 0.0f;

            // セル中心計算
            float cellCenterX = checkX * cellSizeX + rowOffsetX + cellSizeX * 0.5f;
            float cellCenterY = checkY * cellRowSpacing + cellSizeY * 0.5f;

            // 距離計算
            float distX = xf - cellCenterX;
            float distY = yf - cellCenterY;

            // 高密度時の歪み補正 - XY比を調整
            if (cellSize < 10.0f) {
                // Y方向の圧縮を少し緩和（六角形特性に合わせる）
                distY *= _fmaxf(0.8f, 1.0f - (10.0f - cellSize) * 0.02f);
            }

            float distXNorm = distX / cellSizeX;
            float distYNorm = distY / cellSizeY;
            float normDistSq = distXNorm*distXNorm + distYNorm*distYNorm;

            // 高密度時の六角形形状への補正
            if (cellSize < 8.0f) {
                // 方向による補正係数
                float dirFactor = _fabs(distXNorm) / (_fabs(distYNorm) + 0.001f);

                // 六角形に近づくよう方向による調整
                if (dirFactor > 1.5f) {
                    // X方向優勢の場合、水平方向に引き伸ばす
                    normDistSq *= _fmaxf(0.85f, 1.0f - (8.0f - cellSize) * 0.02f);
                } else if (dirFactor < 0.65f) {
                    // Y方向優勢の場合、垂直方向に引き伸ばす
                    normDistSq *= _fmaxf(0.90f, 1.0f - (8.0f - cellSize) * 0.015f);
                }
            }

            // 距離判定を最適化 (平方根を回避)
            float distThresholdSq = (isCurrentRowOffset == isCheckRowOffset) ?
                                  distThresholdBaseSq :
                                  distThresholdAltSq;

            // 垂直方向の強化 (条件分岐を減らす)
            if (dy != 0) {
                distThresholdSq *= verticalBoostFactor;
            }

            // 高密度時は探索範囲を広げる
            if (cellSize < 8.0f) {
                distThresholdSq *= (1.0f + (8.0f - cellSize) * 0.03f);
            }

            // 最適化された早期脱出
            if (normDistSq > distThresholdSq) continue;

            // テクスチャ座標計算 (乗算で最適化)
            float centerUVx = cellCenterX * invSrcSizeX;
            float centerUVy = cellCenterY * invSrcSizeY;

            // 有効範囲チェック (範囲チェックを一括化)
            if (centerUVx >= 0.0f && centerUVx <= 1.0f &&
                centerUVy >= 0.0f && centerUVy <= 1.0f)
            {
                float4 cellColor = _tex2DVecN(src, centerUVx, centerUVy, 15);

                // 輝度計算の統合
                float cellLuma = cellColor.x * 0.3f + cellColor.y * 0.59f + cellColor.z * 0.11f;
                cellLuma = _clampf((cellLuma - 0.5f) * params->contrast + 0.5f, 0.0f, 1.0f);

                // ドット半径計算 - 高密度時の形状補正
                float radius = MAX_DOT_RADIUS * (1.0f - cellLuma);
                radius = _fmaxf(radius, 0.01f);

                // 高密度時は小さな暗いドットでも見えるように最小値を調整
                if (cellSize < 6.0f && cellLuma < 0.4f) {
                    radius = _fmaxf(radius, 0.08f * (1.0f - cellSize / 6.0f));
                }

                // 条件分岐を最小化
                if (cellLuma < 0.3f) {
                    radius += (0.3f - cellLuma) * 0.15f;
                }

                radius *= smallCellBoost * dotGainFactor;

                // 距離計算と必要な場合にのみ平方根を使用
                float normDist = _sqrtf(normDistSq);
                float alpha;

                if (params->aaStrength <= 0.001f) {
                    alpha = (normDist <= radius) ? 1.0f : 0.0f;
                } else {
                    // 高密度時はAAの範囲を広げる（より自然なドット形状に）
                    float t = _clampf((normDist - radius + aaWidthBase) /
                                     _fmaxf(aaWidthBase, 0.0001f), 0.0f, 1.0f);
                    // 六角形に近いAAカーブ
                    alpha = 1.0f - (t * t * (1.0f + 0.25f * t));
                }

                // アルファが十分な場合のみスコア計算
                if (alpha > 0.01f) {
                    float currentDotLuma = params->useOriginalColor == 1 ?
                                         cellLuma : 0.0f;

                    // 最適化されたボーナス計算
                    float dirBonus = (!isCurrentRowOffset && dy != 0) ? 0.3f : 0.0f;
                    float rowTypeBonus = (isCurrentRowOffset == isCheckRowOffset) ? 0.2f : 0.0f;

                    // 効率的なスコア計算
                    float lumaScore = (1.0f - currentDotLuma) * 5.0f;
                    float alphaPower = isCurrentRowOffset ? 2.0f : 2.2f;
                    float alphaScore = alpha * alpha; // 2乗で近似
                    if (alphaPower > 2.0f) {
                        alphaScore *= alpha * 0.2f; // 近似的なpow
                    }

                    // 高密度時は暗い部分を少し強調
                    if (cellSize < 8.0f && currentDotLuma < 0.3f) {
                        lumaScore *= (1.0f + (0.3f - currentDotLuma) * 0.5f);
                    }

                    float score = lumaScore + alphaScore + dirBonus + rowTypeBonus;

                    // スコア比較を最適化
                    if (score > bestScore) {
                        bestScore = score;
                        bestAlpha = alpha;
                        bestLuma = currentDotLuma;
                        bestColor = params->useOriginalColor == 1 ? cellColor : to_float4(0.0f, 0.0f, 0.0f, 1.0f);
                        hasInfluence = true;
                    }
                }
            }
        }

        // 最適なドットを効率的に適用
        if (hasInfluence) {
            // 計算の最小化
            float bgLuma = result.x * 0.3f + result.y * 0.59f + result.z * 0.11f;
            float darknessFactor = 1.0f - bestLuma;

            // 高密度時は行タイプによる強化をさらに強める
            float densityBoost = 1.0f + _fmaxf(0.0f, (8.0f - cellSize) * 0.05f);
            float rowTypeEnhancement = isCurrentRowOffset ?
                                     2.0f * densityBoost :
                                     2.25f * densityBoost;

            darknessFactor = _fminf(darknessFactor * rowTypeEnhancement, 1.0f);

            // 強化されたブレンド係数
            float enhancedBlend = bestAlpha + darknessFactor * (1.0f - bestAlpha);

            // 条件分岐を効率化
            if (!isCurrentRowOffset) {
                enhancedBlend = _fminf(enhancedBlend * 1.1f, 1.0f);
            }

            // 高密度時はエッジをシャープにするためにブレンドをより強く
            if (cellSize < 6.0f) {
                enhancedBlend = _powf(enhancedBlend, 0.8f); // より強いブレンド効果
            }

            // 簡略化されたブレンドロジック
            float blendFactor;
            if (bestAlpha > 0.7f) {
                // 高アルファの場合は直接上書き
                result = bestColor;
            }
            else if (bestLuma < bgLuma || bestAlpha > 0.3f) {
                // ブレンド係数の計算を簡略化
                blendFactor = _fmaxf(bestAlpha * 1.5f, enhancedBlend);
                blendFactor = _fminf(blendFactor, 1.0f);

                // 効率的なブレンド
                result.x = _mix(result.x, bestColor.x, blendFactor);
                result.y = _mix(result.y, bestColor.y, blendFactor);
                result.z = _mix(result.z, bestColor.z, blendFactor);
            }
            // else - 影響が低い場合は何もしない
        }

        // 紙の質感処理の最適化
        if (params->paperTexture > 0.01f) {
            // パラメータのルックアップテーブル化
            float intensityMod, frequencyMod;
            if (params->paperTextureType == 0) { // Smooth
                frequencyMod = 0.9f;
                intensityMod = 0.6f;
            }
            else if (params->paperTextureType == 1) { // Light
                frequencyMod = 0.5f;
                intensityMod = 1.0f;
            }
            else { // Heavy
                frequencyMod = 0.3f;
                intensityMod = 1.8f;
            }

            // 簡略化されたノイズ計算 (sin/cosの回数削減)
            float xyTerm = xf * 0.3f * frequencyMod + yf * 0.27f;
            float yxTerm = yf * 0.13f * frequencyMod + xf * 0.07f;
            float baseNoise = _sinf(xyTerm) * _cosf(yxTerm);

            // 特殊効果を条件付きで適用
            if (params->paperTextureType == 2 &&
                _fabs(_sinf(xf * 1.2f + yf * 1.3f)) > 0.96f) {
                baseNoise += 0.7f;
            }

            // 効率的なノイズ強度計算
            float noiseIntensity = params->paperTexture * 0.25f * intensityMod;
            float noise = (baseNoise * 0.5f + 0.5f) * noiseIntensity;

            // 簡略化されたコントラスト計算
            float noiseEffect = noise - params->paperTexture * 0.05f;
            noiseEffect *= (noise < 0.0f) ? 1.5f : 1.2f;

            // インラインのクランプ
            result.x = result.x + noiseEffect;
            result.y = result.y + noiseEffect;
            result.z = result.z + noiseEffect;

            // 効率的なクランプ (0〜1の範囲に)
            result.x = result.x < 0.0f ? 0.0f : (result.x > 1.0f ? 1.0f : result.x);
            result.y = result.y < 0.0f ? 0.0f : (result.y > 1.0f ? 1.0f : result.y);
            result.z = result.z < 0.0f ? 0.0f : (result.z > 1.0f ? 1.0f : result.z);
        }

        // デバッグモードの効率化 - デバッグ時のみ実行
        if (params->showCellBoundaries == 1) {
            // セルのグリッドライン描画 (変数の再利用)
            float gridLineThickness = 1.0f;
            int currentCellX = (int)(xf / cellSizeX);
            int currentCellY = (int)(yf / cellRowSpacing);
            float cellLeft = currentCellX * cellSizeX;
            float cellTop = currentCellY * cellRowSpacing;
            float rowOffset = ((currentCellY & 1) != 0) ? cellSizeX * zigzagFactor : 0.0f;

            // 境界チェックを最適化
            bool onBoundary = false;

            // 水平方向と垂直方向の境界チェックを一括処理
            if (_fabs(yf - cellTop) < gridLineThickness ||
                _fabs(yf - (cellTop + cellSizeY)) < gridLineThickness ||
                _fabs(xf - (cellLeft + rowOffset)) < gridLineThickness ||
                _fabs(xf - (cellLeft + rowOffset + cellSizeX)) < gridLineThickness) {
                onBoundary = true;
            }

            // 境界線描画を簡略化
            if (onBoundary) {
                result = to_float4(0.0f, 1.0f, 0.0f, 1.0f);
            }
            else {
                // ドット半径表示の最適化
                float centerX = currentCellX * cellSizeX + rowOffset + cellSizeX * 0.5f;
                float centerY = currentCellY * cellRowSpacing + cellSizeY * 0.5f;

                if (_fabs(xf - centerX) < 2.0f && _fabs(yf - centerY) < 2.0f) {
                    result = to_float4(0.0f, 0.0f, 1.0f, 1.0f); // 中心点
                }
            }
        }

        _tex2DVec4Write(dst, x, y, result);
    }
}
]]

-- CMYKモード処理用のカーネル
-- 最適化されたCMYKモード処理用カーネル
CmykKernel = [[
__KERNEL__ void CmykKernel(__CONSTANTREF__ HalftoneParams *params, __TEXTURE2D__ src, __TEXTURE2D_WRITE__ dst)
{
    DEFINE_KERNEL_ITERATORS_XY(x, y);

    if (x < params->srcSize[0] && y < params->srcSize[1])
    {
        // 基本設定 スクリーン線数からドットサイズを計算
        float cellSize = 1000.0f / _fmaxf(0.1f, params->screenDensity);

        // 現在のピクセルの正規化座標
        float xNorm = (float)x / (float)params->srcSize[0];
        float yNorm = (float)y / (float)params->srcSize[1];
        float2 pixelUV = to_float2(xNorm, yNorm);

        // 現在のピクセルの色を取得
        float4 pixelColor = _tex2DVecN(src, pixelUV.x, pixelUV.y, 15);

        // デフォルト値として背景色を設定
        float4 result;
        if (params->useOriginalBackground == 1) {
            result = pixelColor;
        } else {
            // 配列から float4 を構築
            result = to_float4(
                params->paperColor[0],  // R
                params->paperColor[1],  // G
                params->paperColor[2],  // B
                params->paperColor[3]   // A
            );
        }


        // 事前計算
        float xf = (float)x;
        float yf = (float)y;

        // 各チャンネル（CMYK）ごとに処理
        float angles[4] = {18.4f, 71.6f, 0.0f, 45.0f}; // C、M、Y、Kの角度
        float3 colors[3] = {
            to_float3(0.0f, 0.85f, 0.85f), // シアン（より濃いめ）
            to_float3(0.85f, 0.0f, 0.85f), // マゼンタ（より濃いめ）
            to_float3(0.85f, 0.85f, 0.0f)  // イエロー（より濃いめ）
        };

        // サイズ係数を計算
        float cellSizes[4];
        for (int i = 0; i < 4; i++) {
            cellSizes[i] = cellSize;
            if (i == 1) cellSizes[i] *= 1.05f;      // マゼンタ
            else if (i == 2) cellSizes[i] *= 0.95f; // イエロー
        }

        // 基本オフセットとレジストレーションエラー
        float2 offsets[4];
        for (int i = 0; i < 4; i++) {
            offsets[i] = to_float2(0.0f, 0.0f);
        }
        offsets[1].x = cellSizes[1] * 0.25f;
        offsets[2].y = cellSizes[2] * 0.25f;
        offsets[3].x = cellSizes[3] * 0.125f;
        offsets[3].y = cellSizes[3] * 0.125f;

        // レジストレーションエラーを計算（最適化）
        if (params->regError > 0.01f) {
            float regScale = params->regError * cellSize * 0.1f;
            offsets[0].x += regScale * 0.53f;
            offsets[0].y += regScale * 0.23f;
            offsets[1].x -= regScale * 0.33f;
            offsets[1].y += regScale * 0.41f;
            offsets[2].x += regScale * 0.17f;
            offsets[2].y -= regScale * 0.37f;
        }

        // 各チャンネルの影響度
        float channelMask[4] = {0.0f, 0.0f, 0.0f, 0.0f};
        float4 channelColors[4];
        bool hasChannelInfluence[4] = {false, false, false, false};

        // CMYKの各チャンネルごとの処理
        for (int channel = 0; channel < 4; channel++) {
            float angle = angles[channel] * 0.01745329f; // ラジアンに変換
            float cosAngle = _cosf(angle);
            float sinAngle = _sinf(angle);

            // 回転とオフセットを適用
            float rotX = xf * cosAngle - yf * sinAngle + offsets[channel].x;
            float rotY = xf * sinAngle + yf * cosAngle + offsets[channel].y;

            // 最も近いセルの中心を見つける
            int cellIdX = (int)(rotX / cellSizes[channel]);
            int cellIdY = (int)(rotY / cellSizes[channel]);

            // 周囲のセルをチェック - 検索範囲を最適化
            for (int dy = -1; dy <= 1; dy++) {
                for (int dx = -1; dx <= 1; dx++) {
                    // 対角セルの場合は効率化（対角セルは距離が遠いので75%スキップ）
                    if (abs(dx) + abs(dy) == 2) {
                        if (_fabs(_sinf(xf * 12.34f + yf * 56.78f)) > 0.5f) {
                            continue;
                        }
                    }

                    int checkX = cellIdX + dx;
                    int checkY = cellIdY + dy;

                    // 奇数行は水平方向にオフセット
                    float offsetX = ((checkY % 2) != 0) ? 0.5f : 0.0f;

                    // セル中心座標
                    float cellCenterX = (checkX + offsetX) * cellSizes[channel];
                    float cellCenterY = checkY * cellSizes[channel] + cellSizes[channel] * 0.5f;

                    // 特別なセルパターン調整（K版のみ）
                    if (channel == 3) {
                        bool isOddCell = ((checkX + checkY) % 2 != 0);
                        float adjustY = isOddCell ? 0.075f : -0.075f;
                        cellCenterY += cellSizes[channel] * adjustY;

                        // 市松模様補正
                        if ((checkY % 2) != 0 && (checkX % 2) == 0) {
                            cellCenterY += cellSizes[channel] * 0.075f;
                        } else if ((checkY % 2) == 0 && (checkX % 2) != 0) {
                            cellCenterY -= cellSizes[channel] * 0.075f;
                        }
                    }

                    // 現在のピクセルからセル中心への距離
                    float distX = rotX - cellCenterX;
                    float distY = rotY - cellCenterY;
                    float dist = _sqrtf(distX*distX + distY*distY);

                    // 早期脱出条件を強化（性能改善）
                    if (dist > cellSizes[channel] * 0.75f) continue;

                    // セル中心の画像上の座標に変換
                    float invX = cellCenterX * cosAngle + cellCenterY * sinAngle - offsets[channel].x;
                    float invY = -cellCenterX * sinAngle + cellCenterY * cosAngle - offsets[channel].y;

                    // 正規化座標
                    float centerUVx = invX * (1.0f / (float)params->srcSize[0]);
                    float centerUVy = invY * (1.0f / (float)params->srcSize[1]);

                    // テクスチャ範囲内かチェック
                    if (centerUVx >= 0.0f && centerUVx <= 1.0f && centerUVy >= 0.0f && centerUVy <= 1.0f) {
                        // セル中心の色
                        float4 cellColor = _tex2DVecN(src, centerUVx, centerUVy, 15);

                        // チャンネル値計算 - UCR/GCR処理を適用
                        float channelValue = 0.0f;

                        // CMY版の場合
                        if (channel < 3) {
                            channelValue = channel == 0 ? (1.0f - cellColor.x) :
                                          (channel == 1 ? (1.0f - cellColor.y) : (1.0f - cellColor.z));

                            // UCR処理
                            if (params->ucrAmount > 0.0f) {
                                float minVal = _fminf(_fminf(1.0f-cellColor.x, 1.0f-cellColor.y), 1.0f-cellColor.z);
                                channelValue -= minVal * params->ucrAmount;
                                channelValue = _fmaxf(0.0f, channelValue);
                            }
                        } else {
                            // K版の場合
                            channelValue = 1.0f - _fmaxf(_fmaxf(cellColor.x, cellColor.y), cellColor.z);

                            // UCR強化
                            if (params->ucrAmount > 0.0f) {
                                float minVal = _fminf(_fminf(1.0f-cellColor.x, 1.0f-cellColor.y), 1.0f-cellColor.z);
                                channelValue = _fminf(1.0f, channelValue + minVal * params->ucrAmount * 0.7f);
                            }
                        }

                        // コントラスト調整
                        channelValue = _clampf((channelValue - 0.5f) * params->contrast + 0.5f, 0.0f, 1.0f);

                        // ドット半径計算（最適化）
                        float radius = 0.5f * channelValue;
                        radius = _fmaxf(radius, 0.01f);

                        // ドットゲイン効果（条件分岐削減）
                        radius *= (1.0f + params->dotGain * 0.3f);

                        // セル半径と距離を比較
                        float normDist = dist / cellSizes[channel];

                        // アンチエイリアス処理
                        float edge = radius;
                        float aaWidth = 0.7f / cellSizes[channel] * params->aaStrength;
                        float t = _clampf((normDist - edge + aaWidth) / _fmaxf(aaWidth, 0.0001f), 0.0f, 1.0f);
                        float alpha = 1.0f - (t * t * (3.0f - 2.0f * t)); // smoothstep

                        // 影響度の更新
                        if (alpha > 0.01f && alpha > channelMask[channel]) {
                            channelMask[channel] = alpha;
                            hasChannelInfluence[channel] = true;

                            // 色の設定
                            if (channel < 3) {
                                if (params->useOriginalColor == 1) {
                                    // 元の色を基に、該当チャンネルだけ削除
                                    // 紙の色ではなく純粋な黒または他のチャンネル値を使用
                                    channelColors[channel] = cellColor;
                                    if (channel == 0) channelColors[channel].x = 0.0f; // 紙の色に関係なく0に
                                    else if (channel == 1) channelColors[channel].y = 0.0f; // 紙の色に関係なく0に
                                    else channelColors[channel].z = 0.0f; // 紙の色に関係なく0に
                                } else {
                                    // プロセスカラーも紙の色に影響されない固定値
                                    channelColors[channel] = to_float4(colors[channel].x, colors[channel].y, colors[channel].z, 1.0f);
                                }
                            } else {
                                // K版は常に純粋な黒（紙の色に関係なく）
                                channelColors[channel] = to_float4(0.0f, 0.0f, 0.0f, 1.0f);
                            }
                        }
                    }
                }
            }
        }

        // CMY版の適用（最適化）
        float4 cmyResult;
        if (params->useOriginalBackground == 1) {
            cmyResult = pixelColor;
        } else {
            // 紙の色の代わりに純粋な白から始める（インク色用）
            cmyResult = to_float4(1.0f, 1.0f, 1.0f, 1.0f);
        }
        float totalMask = 0.0f;

        // マスクの合計を先に計算
        for (int i = 0; i < 3; i++) {
            if (hasChannelInfluence[i] && channelMask[i] > 0.0f) {
                totalMask += channelMask[i];
            }
        }

        // 単純化したブレンド処理
        for (int i = 0; i < 3; i++) {
            if (hasChannelInfluence[i] && channelMask[i] > 0.0f) {
                float factor = channelMask[i];

                if (factor > 0.5f) {
                    // 最小値で合成（よりダークになるように）
                    cmyResult.x = _fminf(cmyResult.x, channelColors[i].x);
                    cmyResult.y = _fminf(cmyResult.y, channelColors[i].y);
                    cmyResult.z = _fminf(cmyResult.z, channelColors[i].z);
                } else {
                    // エッジ部分はブレンド
                    float blendFactor = factor * 2.5f;
                    cmyResult.x = _mix(cmyResult.x, _fminf(cmyResult.x, channelColors[i].x), blendFactor);
                    cmyResult.y = _mix(cmyResult.y, _fminf(cmyResult.y, channelColors[i].y), blendFactor);
                    cmyResult.z = _mix(cmyResult.z, _fminf(cmyResult.z, channelColors[i].z), blendFactor);
                }
            }
        }

        // 全体の濃度調整（最適化）
        if (totalMask > 0.0f) {
            float darkening = _fminf(totalMask / 3.0f * 0.2f, 0.2f);
            float brightnessFactor = 1.0f - darkening;
            cmyResult.x *= brightnessFactor;
            cmyResult.y *= brightnessFactor;
            cmyResult.z *= brightnessFactor;
        }

        // K版の適用
        float4 inkResult = cmyResult;  // inkResultはインク色のみを計算
        if (hasChannelInfluence[3] && channelMask[3] > 0.0f) {
            if (channelMask[3] > 0.5f) {
                // 中心部分は黒で上書き
                inkResult = to_float4(0.0f, 0.0f, 0.0f, 1.0f);
            } else {
                // エッジブレンド
                float blendFactor = channelMask[3] * 2.0f;
                inkResult = _mix(cmyResult, to_float4(0.0f, 0.0f, 0.0f, 1.0f), blendFactor);
            }
        }

        // インク色と紙の色を合成（インク部分のマスクを計算）
        float inkMask = 0.0f;
        for (int i = 0; i < 4; i++) {
            if (hasChannelInfluence[i]) {
                inkMask = _fmaxf(inkMask, channelMask[i]);
            }
        }

        // インク色と紙の色（またはオリジナル背景）をブレンド
        if (inkMask > 0.001f) {
            result = _mix(result, inkResult, inkMask);
        } else {
            // インクの影響がない場合はそのまま背景色
        }

        // 紙の質感適用（効率化）
        if (params->paperTexture > 0.01f) {
            float noise = 0.0f;
            float intensityMod = 1.0f;
            float frequencyMod = 1.0f;

            // 紙のタイプに応じたパラメータ設定
            if (params->paperTextureType == 0) { // Smooth
                frequencyMod = 0.9f;
                intensityMod = 0.6f;
            }
            else if (params->paperTextureType == 1) { // Light
                frequencyMod = 0.5f;
                intensityMod = 1.0f;
            }
            else { // Heavy
                frequencyMod = 0.3f;
                intensityMod = 1.8f;
            }

            // 共通の効率的なノイズ計算
            float baseNoise = _sinf(xf * 0.3f * frequencyMod + yf * 0.27f) *
                             _cosf(yf * 0.13f * frequencyMod + xf * 0.07f);

            // Heavy Texture用に追加の粒状感
            if (params->paperTextureType == 2 &&
                _fabs(_sinf(xf * 1.2f + yf * 1.3f)) > 0.96f) {
                baseNoise += 0.7f;
            }

            noise = (baseNoise * 0.5f + 0.5f) * params->paperTexture * 0.25f * intensityMod;

            // コントラスト調整（分岐を減らす）
            float noiseEffect = noise - params->paperTexture * 0.05f;
            noiseEffect *= (noise < 0.0f) ? 1.5f : 1.2f;

            // 色に適用
            result.x = _clampf(result.x + noiseEffect, 0.0f, 1.0f);
            result.y = _clampf(result.y + noiseEffect, 0.0f, 1.0f);
            result.z = _clampf(result.z + noiseEffect, 0.0f, 1.0f);
        }

        _tex2DVec4Write(dst, x, y, result);
    }
}
]]

function Create()
    local groupID = 0

    InUseCMYKMode = self:AddInput("CMYK Mode", "UseCMYKMode", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Integer = true,
        INP_Default = 0.0,
        INPS_StatusText = "Enables CMYK-style halftone separation",
    })

    InScreenDensity = self:AddInput("Screen Density", "ScreenDensity", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 130.0,
        INP_MinAllowed = 0.001,
        INP_MaxAllowed = 600.0,
        INPID_PreviewControl = "RangeControl",
        INP_Integer = false,
        INPS_StatusText = "Controls the density of the halftone pattern in CMYK mode",
    })

    InContrast = self:AddInput("Contrast", "Contrast", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 1.0,
        INP_MinAllowed = 0.1,
        INP_MaxAllowed = 15.0,
        INPS_StatusText = "Adjusts the contrast of the halftone pattern",
    })

    InUseOriginalColor = self:AddInput("Use Original Color", "UseOriginalColor", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Default = 0.0,
        INPS_StatusText = "Preserves original colors instead of black and white",
    })

    InUseOriginalBackground = self:AddInput("Color Background", "UseOriginalBackground", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Default = 0.0,
        INPS_StatusText = "Uses original image colors for background instead of white",
    })

    InAAStrength = self:AddInput("AA Strength", "AAStrength", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.3,
        INP_MinAllowed = 0.0,
        INP_MaxAllowed = 10.0,
        INPS_StatusText = "Controls the strength of anti-aliasing on dot edges",
    })

    InDotGain = self:AddInput("Dot Gain", "DotGain", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.3,
        INP_MinAllowed = 0.0,
        INP_MaxAllowed = 1.0,
        INPS_StatusText = "Simulates ink spread on paper",
    })

    InRegError = self:AddInput("Registration Error", "RegError", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.2,
        INP_MinAllowed = 0.0,
        INP_MaxAllowed = 1.0,
        INPS_StatusText = "Simulates misalignment between color plates",
    })

    InUcrAmount = self:AddInput("UCR Amount", "UcrAmount", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.5,
        INP_MinAllowed = 0.0,
        INP_MaxAllowed = 1.0,
        INPS_StatusText = "Controls Under Color Removal in CMYK mode",
    })

    self:BeginControlNest("Paper", "Paper", true);

    InPaperTexture = self:AddInput("Paper Texture", "PaperTexture", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.1,
        INP_MinAllowed = 0.0,
        INP_MaxAllowed = 1.0,
        INPS_StatusText = "Adds simulated paper texture to the output",
    })

    InPaperType = self:AddInput("Paper Type", "PaperType", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ComboControl",
        INP_Default = 0,
        INP_Integer = true,
        { CCS_AddString = "Smooth" },
        { CCS_AddString = "Light Texture" },
        { CCS_AddString = "Heavy Texture" },
        INPS_StatusText = "Selects the type of paper texture pattern",
    })

    InPaperColorPreset = self:AddInput("Paper Color Preset", "PaperColorPreset", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ComboControl",
        INP_Default = 0,
        INP_Integer = true,
        INP_DoNotifyChanged = true,
        { CCS_AddString = "Custom" },
        { CCS_AddString = "Pure White" },
        { CCS_AddString = "Warm White" },
        { CCS_AddString = "Cool White" },
        { CCS_AddString = "Natural White" },
        { CCS_AddString = "Cream" },
        { CCS_AddString = "Ivory" },
        { CCS_AddString = "Light Gray" },
        { CCS_AddString = "Newspaper" },
        { CCS_AddString = "Vintage" },
        { CCS_AddString = "Kraft" },
        { CCS_AddString = "Recycled" },
        { CCS_AddString = "Light Blue" },
        { CCS_AddString = "Light Green" },
        { CCS_AddString = "Light Pink" },
        { CCS_AddString = "Light Yellow" },
        INPS_StatusText = "Select from common paper color presets",
    })

    groupID = groupID + 1
    InPaperColorRed = self:AddInput("Paper Color Red", "PaperColorRed", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupID,
        IC_ControlID       = 0, -- Red ID
        INPS_StatusText    = "Sets the paper color (background)",
    })

    InPaperColorGreen = self:AddInput("Paper Color Green", "PaperColorGreen", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupID,
        IC_ControlID       = 1, -- Green ID
        INPS_StatusText    = "Sets the paper color (background)",
    })

    InPaperColorBlue = self:AddInput("Paper Color Blue", "PaperColorBlue", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupID,
        IC_ControlID       = 2, -- Blue ID
        INPS_StatusText    = "Sets the paper color (background)",
    })

    InPaperColorAlpha = self:AddInput("Paper Color Alpha", "PaperColorAlpha", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupID,
        IC_ControlID       = 3, -- Alpha ID
        INPS_StatusText    = "Sets the paper color (background)",
    })
    self:EndControlNest()


    InShowCellBoundaries = self:AddInput("Show Cell Boundaries", "ShowCellBoundaries", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Integer = true,
        INP_Default = 0.0,
        INPS_StatusText = "Debug: Show cell boundaries with green lines",
    })

    InImage = self:AddInput("Input Image", "Image", {
        LINKID_DataType = "Image",
        LINK_Main = 1,
        INPS_StatusText = "Input image to be processed",
    })
end

function Process(req)
    local contrast = InContrast:GetValue(req).Value
    local useOriginalColor = InUseOriginalColor:GetValue(req).Value
    local useOriginalBackground = InUseOriginalBackground:GetValue(req).Value
    local useCMYKMode = InUseCMYKMode:GetValue(req).Value
    local aaStrength = InAAStrength:GetValue(req).Value
    local screenDensity = InScreenDensity:GetValue(req).Value
    local dotGain = InDotGain:GetValue(req).Value
    local regError = InRegError:GetValue(req).Value
    local ucrAmount = InUcrAmount:GetValue(req).Value
    local paperTexture = InPaperTexture:GetValue(req).Value
    local paperType = InPaperType:GetValue(req).Value
    local paperColor = {
        InPaperColorRed:GetValue(req).Value,
        InPaperColorGreen:GetValue(req).Value,
        InPaperColorBlue:GetValue(req).Value,
        InPaperColorAlpha:GetValue(req).Value,
    }



    local img = InImage:GetValue(req)
    local out

    if img then
        out = Image({ IMG_Like = img })

        -- CMYKモードかどうかによってカーネルを選択
        local kernelName, kernelCode
        if useCMYKMode > 0.5 then
            kernelName = "CmykKernel"
            kernelCode = CmykKernel
        else
            kernelName = "HalftoneKernel"
            kernelCode = HalftoneKernel
        end

        local node = DVIPComputeNode(req, kernelName, kernelCode, "HalftoneParams", HalftoneParams)

        if node then
            -- create image
            local params = node:GetParamBlock(HalftoneParams)

            -- 基本パラメータ設定
            params.contrast = contrast
            params.screenDensity = screenDensity
            params.srcSize[0] = out.DataWindow:Width()
            params.srcSize[1] = out.DataWindow:Height()
            params.useOriginalColor = useOriginalColor > 0.5 and 1 or 0
            params.useOriginalBackground = useOriginalBackground > 0.5 and 1 or 0
            params.useCMYKMode = useCMYKMode > 0.5 and 1 or 0
            params.dotAngle = 0.0
            params.aaStrength = aaStrength
            params.dotGain = dotGain
            params.regError = regError
            params.ucrAmount = ucrAmount
            params.paperTexture = paperTexture
            params.paperTextureType = paperType
            params.paperColor[0] = paperColor[1] -- R
            params.paperColor[1] = paperColor[2] -- G
            params.paperColor[2] = paperColor[3] -- B
            params.paperColor[3] = paperColor[4] -- A
            params.showCellBoundaries = InShowCellBoundaries:GetValue(req).Value > 0.5 and 1 or 0

            node:SetParamBlock(params)

            node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR, TEX_ADDRESS_MODE_CLAMP, TEX_NORMALIZED_COORDS_TRUE)
            node:AddInput("src", img)
            node:AddOutput("dst", out)

            success = node:RunSession(req)
        else
            out = nil
        end
    end

    OutImage:Set(req, out)
end

function NotifyChanged(inp, param, time)
    if inp == InUseOriginalBackground then
        -- オリジナル背景を使用する場合は紙の色設定を無効化
        local useOrigBg = (param.Value > 0.5)
        InPaperColorRed:SetAttrs({ INPS_Disabled = useOrigBg })
        InPaperColorGreen:SetAttrs({ INPS_Disabled = useOrigBg })
        InPaperColorBlue:SetAttrs({ INPS_Disabled = useOrigBg })
        InPaperColorAlpha:SetAttrs({ INPS_Disabled = useOrigBg })
        InPaperColorPreset:SetAttrs({ INPS_Disabled = useOrigBg })
    elseif inp == InPaperColorPreset then
        -- 紙の色プリセットが選択された場合
        local presetIndex = math.floor(param.Value + 0.5)

        -- プリセット値の設定
        local r, g, b = 1.0, 1.0, 1.0 -- デフォルト値（白）

        if presetIndex == 1 then      -- Pure White
            r, g, b = 1.00, 1.00, 1.00
        elseif presetIndex == 2 then  -- Warm White
            r, g, b = 1.00, 0.98, 0.94
        elseif presetIndex == 3 then  -- Cool White
            r, g, b = 0.97, 0.97, 1.00
        elseif presetIndex == 4 then  -- Natural White
            r, g, b = 0.98, 0.98, 0.96
        elseif presetIndex == 5 then  -- Cream
            r, g, b = 0.97, 0.95, 0.86
        elseif presetIndex == 6 then  -- Ivory
            r, g, b = 1.00, 0.97, 0.90
        elseif presetIndex == 7 then  -- Light Gray
            r, g, b = 0.90, 0.90, 0.90
        elseif presetIndex == 8 then  -- Newspaper
            r, g, b = 0.93, 0.91, 0.83
        elseif presetIndex == 9 then  -- Vintage
            r, g, b = 0.96, 0.92, 0.80
        elseif presetIndex == 10 then -- Kraft
            r, g, b = 0.85, 0.75, 0.58
        elseif presetIndex == 11 then -- Recycled
            r, g, b = 0.87, 0.87, 0.82
        elseif presetIndex == 12 then -- Light Blue
            r, g, b = 0.90, 0.95, 1.00
        elseif presetIndex == 13 then -- Light Green
            r, g, b = 0.90, 0.98, 0.90
        elseif presetIndex == 14 then -- Light Pink
            r, g, b = 1.00, 0.90, 0.93
        elseif presetIndex == 15 then -- Light Yellow
            r, g, b = 1.00, 1.00, 0.88
        end

        -- カラーコントロールに値をセット
        if presetIndex > 0 then
            InPaperColorRed:SetSource(Number(r), time)
            InPaperColorGreen:SetSource(Number(g), time)
            InPaperColorBlue:SetSource(Number(b), time)
        end
    end

    return true
end
