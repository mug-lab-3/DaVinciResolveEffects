FuRegisterClass("MugHalftone", CT_SourceTool, {
    REGS_Category          = "Fuses\\Mug",
    REGS_OpIconString      = "MHT",
    REGS_OpDescription     = "Mug Halftone",
    REGS_HelpTopic         = "https://x.com/MugLab3",    --This can be a URL
    REGS_URL               = "https://www.youtube.com/@MugLabVideoEditing",
    REGS_IconID            = "Icons.Tools.Icons.Example", -- This can be Inline as an array of Values
    REG_NoObjMatCtrls      = true,
    REG_NoMotionBlurCtrls  = true,
    REG_Source_GlobalCtrls = true,
    REG_Source_SizeCtrls   = true,
    REG_Source_AspectCtrls = true,
    REG_Source_DepthCtrls  = true,
    REG_Version            = 0.1,
})

-- パラメーター構造体
HalftoneParams = [[
  int srcSize[2];        // ソース画像のサイズ
  float dotSize;         // ドットのサイズ調整（大きいほど細かいパターン）
  float contrast;        // コントラスト調整（1.0がデフォルト）
  int useOriginalColor;  // 元の色を使用するかどうか（0=白黒、1=カラー）
  int useOriginalBackground; // 背景も元の色にするかどうか（0=紙の色、1=元の色）
  int useCMYKMode;       // CMYKモードを使用するかどうか（0=標準ハーフトーン、1=CMYKスタイル）
  float dotAngle;        // ドットの角度（CMYK モードでのみ使用）
  float aaStrength;      // アンチエイリアス強度（0.0=無効、1.0=強い）
  float dotGain;         // ドットゲイン効果の強さ（0.0-1.0）
  float regError;        // 色版ずれの程度（0.0-1.0）
  float ucrAmount;       // UCR/GCR適用量（0.0-1.0）
  float paperTexture;    // 紙の質感強度（0.0-1.0）
  int paperTextureType;  // 紙の種類（0=なめらか、1=わずかな繊維、2=強い繊維）
  float screenDensity;   // スクリーンの密度
  float paperColor[4];   // 紙の色（背景色）[R,G,B,A]
]]

-- 標準ハーフトーンカーネル
HalftoneKernel = [[
__KERNEL__ void HalftoneKernel(__CONSTANTREF__ HalftoneParams *params, __TEXTURE2D__ src, __TEXTURE2D_WRITE__ dst)
{
    DEFINE_KERNEL_ITERATORS_XY(x, y);

    if (x < params->srcSize[0] && y < params->srcSize[1])
    {
        // 基本ドットサイズ設定
        float cellSize = _fmaxf(1.0f, params->dotSize);

        // 座標正規化
        float xNorm = (float)x / (float)params->srcSize[0];
        float yNorm = (float)y / (float)params->srcSize[1];
        float4 pixelColor = _tex2DVecN(src, xNorm, yNorm, 15);

        // デフォルト値として背景色を設定
        float4 result;
        if (params->useOriginalBackground == 1) {
            result = pixelColor;
        } else {
            // 配列から float4 を構築
            result = to_float4(
                params->paperColor[0],  // R
                params->paperColor[1],  // G
                params->paperColor[2],  // B
                params->paperColor[3]   // A
            );
        }

        // ドット計算用変数
        float dotMask = 0.0f;
        float4 dotColor = to_float4(0.0f, 0.0f, 0.0f, 1.0f);
        bool hasInfluence = false;

        // 45度回転座標系
        float angle = 45.0f * 0.01745329f;
        float cosAngle = _cosf(angle);
        float sinAngle = _sinf(angle);
        float xf = (float)x;
        float yf = (float)y;
        float rotX = xf * cosAngle - yf * sinAngle;
        float rotY = xf * sinAngle + yf * cosAngle;

        // セル特定
        int cellIdX = (int)(rotX / cellSize);
        int cellIdY = (int)(rotY / cellSize);

        // 周囲の検索範囲を対称化して修正
        for (int dy = -1; dy <= 1; dy++) {
            for (int dx = -1; dx <= 1; dx++) {
                int checkX = cellIdX + dx;
                int checkY = cellIdY + dy;

                // 奇数行オフセット
                float offsetX = ((checkY % 2) != 0) ? 0.5f : 0.0f;

                // 特殊オフセット計算
                bool isOddCell = ((checkX + checkY) % 2 != 0);
                float specialOffsetY = isOddCell ? 0.075f : -0.075f;

                // 市松模様補正
                if ((checkY % 2) != 0 && (checkX % 2) == 0) {
                    specialOffsetY += 0.075f;
                } else if ((checkY % 2) == 0 && (checkX % 2) != 0) {
                    specialOffsetY -= 0.075f;
                }

                // セル中心計算
                float cellCenterX = (checkX + offsetX) * cellSize;
                float cellCenterY = checkY * cellSize + cellSize * 0.5f + specialOffsetY * cellSize;

                // 距離計算
                float distX = rotX - cellCenterX;
                float distY = rotY - cellCenterY;
                float dist = _sqrtf(distX*distX + distY*distY);

                // 早期脱出: 距離が大きすぎる場合
                if (dist > cellSize * 0.8f) continue;

                // 画像上の逆変換座標
                float invX = cellCenterX * cosAngle + cellCenterY * sinAngle;
                float invY = -cellCenterX * sinAngle + cellCenterY * cosAngle;
                float centerUVx = invX * (1.0f / (float)params->srcSize[0]);
                float centerUVy = invY * (1.0f / (float)params->srcSize[1]);

                // 有効範囲チェック
                if (centerUVx >= 0.0f && centerUVx <= 1.0f && centerUVy >= 0.0f && centerUVy <= 1.0f) {
                    float4 cellColor = _tex2DVecN(src, centerUVx, centerUVy, 15);

                    // 輝度計算
                    float cellLuma = cellColor.x * 0.3f + cellColor.y * 0.59f + cellColor.z * 0.11f;
                    cellLuma = _clampf((cellLuma - 0.5f) * params->contrast + 0.5f, 0.0f, 1.0f);

                    // ドット半径計算
                    float radius = 0.45f * (1.0f - cellLuma);
                    radius = _fmaxf(radius, 0.01f);

                    // 暗部補正
                    if (cellLuma < 0.3f) {
                        radius += (0.3f - cellLuma) * 0.1f;
                    }

                    // ドットゲイン適用
                    if (params->dotGain > 0.0f) {
                        radius *= (1.0f + params->dotGain * 0.2f);
                    }

                    // アンチエイリアス処理
                    float normDist = dist / cellSize;
                    float aaWidth = 0.7f / cellSize * params->aaStrength;
                    float t = _clampf((normDist - radius + aaWidth) / _fmaxf(aaWidth, 0.0001f), 0.0f, 1.0f);
                    float alpha = 1.0f - (t * t * (3.0f - 2.0f * t));

                    // 影響度が高い場合のみ更新
                    if (alpha > 0.01f && alpha > dotMask) {
                        dotMask = alpha;
                        dotColor = params->useOriginalColor == 1 ? cellColor : to_float4(0.0f, 0.0f, 0.0f, 1.0f);
                        hasInfluence = true;
                    }
                }
            }
        }

        // ドット適用
        if (hasInfluence) {
            if (dotMask > 0.5f) {
                // 中心部分処理
                if (params->useOriginalColor == 1) {
                    // 輝度比較（暗い場合のみ適用）
                    float resultLuma = result.x * 0.3f + result.y * 0.59f + result.z * 0.11f;
                    float dotLuma = dotColor.x * 0.3f + dotColor.y * 0.59f + dotColor.z * 0.11f;
                    if (dotLuma < resultLuma) {
                        result = dotColor;
                    }
                } else {
                    // 黒ドットは常に適用
                    result = dotColor;
                }
            } else {
                // エッジ部分処理
                float blendFactor = dotMask * 2.0f;
                float4 blendedColor;
                blendedColor.x = _mix(result.x, dotColor.x, blendFactor);
                blendedColor.y = _mix(result.y, dotColor.y, blendFactor);
                blendedColor.z = _mix(result.z, dotColor.z, blendFactor);

                // 輝度比較（暗くなる場合のみ適用）
                float resultLuma = result.x * 0.3f + result.y * 0.59f + result.z * 0.11f;
                float blendedLuma = blendedColor.x * 0.3f + blendedColor.y * 0.59f + blendedColor.z * 0.11f;
                if (blendedLuma < resultLuma) {
                    result = blendedColor;
                }
            }
        }

        // 紙の質感適用（簡略化）
        if (params->paperTexture > 0.0f) {
            float noise = _sinf(xf * 0.1f + yf * 0.3f) * _cosf(xf * 0.05f);
            noise = (noise * 0.5f + 0.5f) * params->paperTexture * 0.1f;
            result.x = _clampf(result.x + noise, 0.0f, 1.0f);
            result.y = _clampf(result.y + noise, 0.0f, 1.0f);
            result.z = _clampf(result.z + noise, 0.0f, 1.0f);
        }

        _tex2DVec4Write(dst, x, y, result);
    }
}
]]


-- CMYKモード処理用のカーネル
-- 最適化されたCMYKモード処理用カーネル
CmykKernel = [[
__KERNEL__ void CmykKernel(__CONSTANTREF__ HalftoneParams *params, __TEXTURE2D__ src, __TEXTURE2D_WRITE__ dst)
{
    DEFINE_KERNEL_ITERATORS_XY(x, y);

    if (x < params->srcSize[0] && y < params->srcSize[1])
    {
        // 基本設定 スクリーン線数からドットサイズを計算
        float cellSize = 1000.0f / _fmaxf(0.1f, params->screenDensity);

        // 現在のピクセルの正規化座標
        float xNorm = (float)x / (float)params->srcSize[0];
        float yNorm = (float)y / (float)params->srcSize[1];
        float2 pixelUV = to_float2(xNorm, yNorm);

        // 現在のピクセルの色を取得
        float4 pixelColor = _tex2DVecN(src, pixelUV.x, pixelUV.y, 15);

        // デフォルト値として背景色を設定
        float4 result;
        if (params->useOriginalBackground == 1) {
            result = pixelColor;
        } else {
            // 配列から float4 を構築
            result = to_float4(
                params->paperColor[0],  // R
                params->paperColor[1],  // G
                params->paperColor[2],  // B
                params->paperColor[3]   // A
            );
        }

        // 事前計算
        float xf = (float)x;
        float yf = (float)y;

        // 各チャンネル（CMYK）ごとに処理
        float angles[4] = {18.4f, 71.6f, 0.0f, 45.0f}; // C、M、Y、Kの角度
        float3 colors[3] = {
            to_float3(0.0f, 0.85f, 0.85f), // シアン（より濃いめ）
            to_float3(0.85f, 0.0f, 0.85f), // マゼンタ（より濃いめ）
            to_float3(0.85f, 0.85f, 0.0f)  // イエロー（より濃いめ）
        };

        // サイズ係数を計算
        float cellSizes[4];
        for (int i = 0; i < 4; i++) {
            cellSizes[i] = cellSize;
            if (i == 1) cellSizes[i] *= 1.05f;      // マゼンタ
            else if (i == 2) cellSizes[i] *= 0.95f; // イエロー
        }

        // 基本オフセットとレジストレーションエラー
        float2 offsets[4];
        for (int i = 0; i < 4; i++) {
            offsets[i] = to_float2(0.0f, 0.0f);
        }
        offsets[1].x = cellSizes[1] * 0.25f;
        offsets[2].y = cellSizes[2] * 0.25f;
        offsets[3].x = cellSizes[3] * 0.125f;
        offsets[3].y = cellSizes[3] * 0.125f;

        // レジストレーションエラーを計算（最適化）
        if (params->regError > 0.01f) {
            float regScale = params->regError * cellSize * 0.1f;
            offsets[0].x += regScale * 0.53f;
            offsets[0].y += regScale * 0.23f;
            offsets[1].x -= regScale * 0.33f;
            offsets[1].y += regScale * 0.41f;
            offsets[2].x += regScale * 0.17f;
            offsets[2].y -= regScale * 0.37f;
        }

        // 各チャンネルの影響度
        float channelMask[4] = {0.0f, 0.0f, 0.0f, 0.0f};
        float4 channelColors[4];
        bool hasChannelInfluence[4] = {false, false, false, false};

        // CMYKの各チャンネルごとの処理
        for (int channel = 0; channel < 4; channel++) {
            float angle = angles[channel] * 0.01745329f; // ラジアンに変換
            float cosAngle = _cosf(angle);
            float sinAngle = _sinf(angle);

            // 回転とオフセットを適用
            float rotX = xf * cosAngle - yf * sinAngle + offsets[channel].x;
            float rotY = xf * sinAngle + yf * cosAngle + offsets[channel].y;

            // 最も近いセルの中心を見つける
            int cellIdX = (int)(rotX / cellSizes[channel]);
            int cellIdY = (int)(rotY / cellSizes[channel]);

            // 周囲のセルをチェック - 検索範囲を最適化
            for (int dy = -1; dy <= 1; dy++) {
                for (int dx = -1; dx <= 1; dx++) {
                    // 対角セルの場合は効率化（対角セルは距離が遠いので75%スキップ）
                    if (abs(dx) + abs(dy) == 2) {
                        if (_fabs(_sinf(xf * 12.34f + yf * 56.78f)) > 0.5f) {
                            continue;
                        }
                    }

                    int checkX = cellIdX + dx;
                    int checkY = cellIdY + dy;

                    // 奇数行は水平方向にオフセット
                    float offsetX = ((checkY % 2) != 0) ? 0.5f : 0.0f;

                    // セル中心座標
                    float cellCenterX = (checkX + offsetX) * cellSizes[channel];
                    float cellCenterY = checkY * cellSizes[channel] + cellSizes[channel] * 0.5f;

                    // 特別なセルパターン調整（K版のみ）
                    if (channel == 3) {
                        bool isOddCell = ((checkX + checkY) % 2 != 0);
                        float adjustY = isOddCell ? 0.075f : -0.075f;
                        cellCenterY += cellSizes[channel] * adjustY;

                        // 市松模様補正
                        if ((checkY % 2) != 0 && (checkX % 2) == 0) {
                            cellCenterY += cellSizes[channel] * 0.075f;
                        } else if ((checkY % 2) == 0 && (checkX % 2) != 0) {
                            cellCenterY -= cellSizes[channel] * 0.075f;
                        }
                    }

                    // 現在のピクセルからセル中心への距離
                    float distX = rotX - cellCenterX;
                    float distY = rotY - cellCenterY;
                    float dist = _sqrtf(distX*distX + distY*distY);

                    // 早期脱出条件を強化（性能改善）
                    if (dist > cellSizes[channel] * 0.75f) continue;

                    // セル中心の画像上の座標に変換
                    float invX = cellCenterX * cosAngle + cellCenterY * sinAngle - offsets[channel].x;
                    float invY = -cellCenterX * sinAngle + cellCenterY * cosAngle - offsets[channel].y;

                    // 正規化座標
                    float centerUVx = invX * (1.0f / (float)params->srcSize[0]);
                    float centerUVy = invY * (1.0f / (float)params->srcSize[1]);

                    // テクスチャ範囲内かチェック
                    if (centerUVx >= 0.0f && centerUVx <= 1.0f && centerUVy >= 0.0f && centerUVy <= 1.0f) {
                        // セル中心の色
                        float4 cellColor = _tex2DVecN(src, centerUVx, centerUVy, 15);

                        // チャンネル値計算 - UCR/GCR処理を適用
                        float channelValue = 0.0f;

                        // CMY版の場合
                        if (channel < 3) {
                            channelValue = channel == 0 ? (1.0f - cellColor.x) :
                                          (channel == 1 ? (1.0f - cellColor.y) : (1.0f - cellColor.z));

                            // UCR処理
                            if (params->ucrAmount > 0.0f) {
                                float minVal = _fminf(_fminf(1.0f-cellColor.x, 1.0f-cellColor.y), 1.0f-cellColor.z);
                                channelValue -= minVal * params->ucrAmount;
                                channelValue = _fmaxf(0.0f, channelValue);
                            }
                        } else {
                            // K版の場合
                            channelValue = 1.0f - _fmaxf(_fmaxf(cellColor.x, cellColor.y), cellColor.z);

                            // UCR強化
                            if (params->ucrAmount > 0.0f) {
                                float minVal = _fminf(_fminf(1.0f-cellColor.x, 1.0f-cellColor.y), 1.0f-cellColor.z);
                                channelValue = _fminf(1.0f, channelValue + minVal * params->ucrAmount * 0.7f);
                            }
                        }

                        // コントラスト調整
                        channelValue = _clampf((channelValue - 0.5f) * params->contrast + 0.5f, 0.0f, 1.0f);

                        // ドット半径計算（最適化）
                        float radius = 0.5f * channelValue;
                        radius = _fmaxf(radius, 0.01f);

                        // ドットゲイン効果（条件分岐削減）
                        radius *= (1.0f + params->dotGain * 0.3f);

                        // セル半径と距離を比較
                        float normDist = dist / cellSizes[channel];

                        // アンチエイリアス処理
                        float edge = radius;
                        float aaWidth = 0.7f / cellSizes[channel] * params->aaStrength;
                        float t = _clampf((normDist - edge + aaWidth) / _fmaxf(aaWidth, 0.0001f), 0.0f, 1.0f);
                        float alpha = 1.0f - (t * t * (3.0f - 2.0f * t)); // smoothstep

                        // 影響度の更新
                        if (alpha > 0.01f && alpha > channelMask[channel]) {
                            channelMask[channel] = alpha;
                            hasChannelInfluence[channel] = true;

                            // 色の設定
                            if (channel < 3) {
                                if (params->useOriginalColor == 1) {
                                    // 元の色を基に、該当チャンネルだけ削除
                                    channelColors[channel] = cellColor;
                                    if (channel == 0) channelColors[channel].x = 0.0f;
                                    else if (channel == 1) channelColors[channel].y = 0.0f;
                                    else channelColors[channel].z = 0.0f;
                                } else {
                                    // プロセスカラー
                                    channelColors[channel] = to_float4(colors[channel].x, colors[channel].y, colors[channel].z, 1.0f);
                                }
                            } else {
                                // K版は黒
                                channelColors[channel] = to_float4(0.0f, 0.0f, 0.0f, 1.0f);
                            }
                        }
                    }
                }
            }
        }

        // CMY版の適用（最適化）
        float4 cmyResult = result;
        float totalMask = 0.0f;

        // マスクの合計を先に計算
        for (int i = 0; i < 3; i++) {
            if (hasChannelInfluence[i] && channelMask[i] > 0.0f) {
                totalMask += channelMask[i];
            }
        }

        // 単純化したブレンド処理
        for (int i = 0; i < 3; i++) {
            if (hasChannelInfluence[i] && channelMask[i] > 0.0f) {
                float factor = channelMask[i];

                if (factor > 0.5f) {
                    // 最小値で合成（よりダークになるように）
                    cmyResult.x = _fminf(cmyResult.x, channelColors[i].x);
                    cmyResult.y = _fminf(cmyResult.y, channelColors[i].y);
                    cmyResult.z = _fminf(cmyResult.z, channelColors[i].z);
                } else {
                    // エッジ部分はブレンド
                    float blendFactor = factor * 2.5f;
                    cmyResult.x = _mix(cmyResult.x, _fminf(cmyResult.x, channelColors[i].x), blendFactor);
                    cmyResult.y = _mix(cmyResult.y, _fminf(cmyResult.y, channelColors[i].y), blendFactor);
                    cmyResult.z = _mix(cmyResult.z, _fminf(cmyResult.z, channelColors[i].z), blendFactor);
                }
            }
        }

        // 全体の濃度調整（最適化）
        if (totalMask > 0.0f) {
            float darkening = _fminf(totalMask / 3.0f * 0.2f, 0.2f);
            float brightnessFactor = 1.0f - darkening;
            cmyResult.x *= brightnessFactor;
            cmyResult.y *= brightnessFactor;
            cmyResult.z *= brightnessFactor;
        }

        // K版の適用
        result = cmyResult;
        if (hasChannelInfluence[3] && channelMask[3] > 0.0f) {
            if (channelMask[3] > 0.5f) {
                // 中心部分は黒で上書き
                result = to_float4(0.0f, 0.0f, 0.0f, 1.0f);
            } else {
                // エッジブレンド
                float blendFactor = channelMask[3] * 2.0f;
                result = _mix(cmyResult, to_float4(0.0f, 0.0f, 0.0f, 1.0f), blendFactor);
            }
        }

        // 紙の質感適用（効率化）
        if (params->paperTexture > 0.01f) {
            float noise = 0.0f;
            float intensityMod = 1.0f;
            float frequencyMod = 1.0f;

            // 紙のタイプに応じたパラメータ設定
            if (params->paperTextureType == 0) { // Smooth
                frequencyMod = 0.9f;
                intensityMod = 0.6f;
            }
            else if (params->paperTextureType == 1) { // Light
                frequencyMod = 0.5f;
                intensityMod = 1.0f;
            }
            else { // Heavy
                frequencyMod = 0.3f;
                intensityMod = 1.8f;
            }

            // 共通の効率的なノイズ計算
            float baseNoise = _sinf(xf * 0.3f * frequencyMod + yf * 0.27f) *
                             _cosf(yf * 0.13f * frequencyMod + xf * 0.07f);

            // Heavy Texture用に追加の粒状感
            if (params->paperTextureType == 2 &&
                _fabs(_sinf(xf * 1.2f + yf * 1.3f)) > 0.96f) {
                baseNoise += 0.7f;
            }

            noise = (baseNoise * 0.5f + 0.5f) * params->paperTexture * 0.25f * intensityMod;

            // コントラスト調整（分岐を減らす）
            float noiseEffect = noise - params->paperTexture * 0.05f;
            noiseEffect *= (noise < 0.0f) ? 1.5f : 1.2f;

            // 色に適用
            result.x = _clampf(result.x + noiseEffect, 0.0f, 1.0f);
            result.y = _clampf(result.y + noiseEffect, 0.0f, 1.0f);
            result.z = _clampf(result.z + noiseEffect, 0.0f, 1.0f);
        }

        _tex2DVec4Write(dst, x, y, result);
    }
}
]]

function Create()
    local groupID = 0

    InUseCMYKMode = self:AddInput("CMYK Mode", "UseCMYKMode", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Integer = true,
        INP_Default = 0.0,
        INP_DoNotifyChanged = true,
        INPS_StatusText = "Enables CMYK-style halftone separation",
    })

    InDotSize = self:AddInput("Dot Size", "DotSize", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 15.0,
        INP_MinAllowed = 1.0,
        INP_MaxAllowed = 500.0,
        INPS_StatusText = "Controls the size of halftone dots in standard mode",
    })

    InScreenDensity = self:AddInput("Screen Density", "ScreenDensity", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 130.0,
        INP_MinAllowed = 0.001,
        INP_MaxAllowed = 600.0,
        INPID_PreviewControl = "RangeControl",
        INP_Integer = false,
        INPS_StatusText = "Controls the density of the halftone pattern in CMYK mode",
    })

    InContrast = self:AddInput("Contrast", "Contrast", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 1.0,
        INP_MinAllowed = 0.1,
        INP_MaxAllowed = 15.0,
        INPS_StatusText = "Adjusts the contrast of the halftone pattern",
    })

    InUseOriginalColor = self:AddInput("Use Original Color", "UseOriginalColor", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Default = 0.0,
        INPS_StatusText = "Preserves original colors instead of black and white",
    })

    InUseOriginalBackground = self:AddInput("Color Background", "UseOriginalBackground", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Default = 0.0,
        INPS_StatusText = "Uses original image colors for background instead of white",
    })

    InAAStrength = self:AddInput("AA Strength", "AAStrength", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.3,
        INP_MinAllowed = 0.0,
        INP_MaxAllowed = 10.0,
        INPS_StatusText = "Controls the strength of anti-aliasing on dot edges",
    })

    InDotGain = self:AddInput("Dot Gain", "DotGain", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.3,
        INP_MinAllowed = 0.0,
        INP_MaxAllowed = 1.0,
        INPS_StatusText = "Simulates ink spread on paper",
    })

    InRegError = self:AddInput("Registration Error", "RegError", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.2,
        INP_MinAllowed = 0.0,
        INP_MaxAllowed = 1.0,
        INPS_StatusText = "Simulates misalignment between color plates",
    })

    InUcrAmount = self:AddInput("UCR Amount", "UcrAmount", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.5,
        INP_MinAllowed = 0.0,
        INP_MaxAllowed = 1.0,
        INPS_StatusText = "Controls Under Color Removal in CMYK mode",
    })

    self:BeginControlNest("Paper", "Paper", true);

    InPaperTexture = self:AddInput("Paper Texture", "PaperTexture", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.1,
        INP_MinAllowed = 0.0,
        INP_MaxAllowed = 1.0,
        INPS_StatusText = "Adds simulated paper texture to the output",
    })

    InPaperType = self:AddInput("Paper Type", "PaperType", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ComboControl",
        INP_Default = 0,
        INP_Integer = true,
        { CCS_AddString = "Smooth" },
        { CCS_AddString = "Light Texture" },
        { CCS_AddString = "Heavy Texture" },
        INPS_StatusText = "Selects the type of paper texture pattern",
    })

    groupID = groupID + 1
    InPaperColorRed = self:AddInput("Paper Color Red", "PaperColorRed", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupID,
        IC_ControlID       = 0, -- Red ID
        INPS_StatusText    = "Sets the paper color (background)",
    })

    InPaperColorGreen = self:AddInput("Paper Color Green", "PaperColorGreen", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupID,
        IC_ControlID       = 1, -- Green ID
        INPS_StatusText    = "Sets the paper color (background)",
    })

    InPaperColorBlue = self:AddInput("Paper Color Blue", "PaperColorBlue", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupID,
        IC_ControlID       = 2, -- Blue ID
        INPS_StatusText    = "Sets the paper color (background)",
    })

    InPaperColorAlpha = self:AddInput("Paper Color Alpha", "PaperColorAlpha", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupID,
        IC_ControlID       = 3, -- Alpha ID
        INPS_StatusText    = "Sets the paper color (background)",
    })
    self:EndControlNest()

    InImage = self:AddInput("Input Image", "Image", {
        LINKID_DataType = "Image",
        LINK_Main = 1,
        INPS_StatusText = "Input image to be processed",
    })
end

function Process(req)
    local dotSize = InDotSize:GetValue(req).Value
    local contrast = InContrast:GetValue(req).Value
    local useOriginalColor = InUseOriginalColor:GetValue(req).Value
    local useOriginalBackground = InUseOriginalBackground:GetValue(req).Value
    local useCMYKMode = InUseCMYKMode:GetValue(req).Value
    local aaStrength = InAAStrength:GetValue(req).Value
    local screenDensity = InScreenDensity:GetValue(req).Value
    local dotGain = InDotGain:GetValue(req).Value
    local regError = InRegError:GetValue(req).Value
    local ucrAmount = InUcrAmount:GetValue(req).Value
    local paperTexture = InPaperTexture:GetValue(req).Value
    local paperType = InPaperType:GetValue(req).Value
    local paperColor = {
        InPaperColorRed:GetValue(req).Value,
        InPaperColorGreen:GetValue(req).Value,
        InPaperColorBlue:GetValue(req).Value,
        InPaperColorAlpha:GetValue(req).Value,
    }


    local img = InImage:GetValue(req)
    local out

    if img then
        out = Image({ IMG_Like = img })

        -- CMYKモードかどうかによってカーネルを選択
        local kernelName, kernelCode
        if useCMYKMode > 0.5 then
            kernelName = "CmykKernel"
            kernelCode = CmykKernel
        else
            kernelName = "HalftoneKernel"
            kernelCode = HalftoneKernel
        end

        local node = DVIPComputeNode(req, kernelName, kernelCode, "HalftoneParams", HalftoneParams)

        if node then
            -- create image
            local params = node:GetParamBlock(HalftoneParams)

            -- 基本パラメータ設定
            params.contrast = contrast
            params.dotSize = dotSize
            params.screenDensity = screenDensity
            params.srcSize[0] = out.DataWindow:Width()
            params.srcSize[1] = out.DataWindow:Height()
            params.useOriginalColor = useOriginalColor > 0.5 and 1 or 0
            params.useOriginalBackground = useOriginalBackground > 0.5 and 1 or 0
            params.useCMYKMode = useCMYKMode > 0.5 and 1 or 0
            params.dotAngle = 0.0
            params.aaStrength = aaStrength
            params.dotGain = dotGain
            params.regError = regError
            params.ucrAmount = ucrAmount
            params.paperTexture = paperTexture
            params.paperTextureType = paperType
            params.paperColor[0] = paperColor[1] -- R
            params.paperColor[1] = paperColor[2] -- G
            params.paperColor[2] = paperColor[3] -- B
            params.paperColor[3] = paperColor[4] -- A

            node:SetParamBlock(params)

            node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR, TEX_ADDRESS_MODE_CLAMP, TEX_NORMALIZED_COORDS_TRUE)
            node:AddInput("src", img)
            node:AddOutput("dst", out)

            success = node:RunSession(req)
        else
            out = nil
        end
    end

    OutImage:Set(req, out)
end

-- NotifyChanged 関数を追加して、CMYK モード切り替え時にドットサイズを無効化
function NotifyChanged(inp, param, time)
    if inp == InUseCMYKMode then
        -- CMYK モードが有効な場合、Dot Size を無効化
        local cmykMode = (param.Value > 0.5)
        -- Halftone Mode
        InDotSize:SetAttrs({
            INPS_Disabled = cmykMode,
            IC_Visible = not cmykMode,
        })
        -- CYMMK Mode
        InScreenDensity:SetAttrs({
            INPS_Disabled = not cmykMode,
            IC_Visible = cmykMode,
        })
    elseif inp == InUseOriginalBackground then
        -- オリジナル背景を使用する場合は紙の色設定を無効化
        local useOrigBg = (param.Value > 0.5)
        InPaperColor:SetAttrs({
            INPS_Disabled = useOrigBg,
        })
    end

    return true
end
