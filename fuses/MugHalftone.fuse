FuRegisterClass("MugHalftone", CT_SourceTool, {
    REGS_Category          = "Fuses\\Mug",
    REGS_OpIconString      = "MHT",
    REGS_OpDescription     = "Mug Halftone",
    REGS_HelpTopic         = "https://x.com/MugLab3", --This can be a URL
    REGS_URL               = "https://www.youtube.com/@MugLabVideoEditing",
    -- REGS_IconID            = "Icons.Tools.Icons.Example", -- This can be Inline as an array of Values
    REG_OpNoMask           = false,
    REG_NoObjMatCtrls      = false,
    REG_NoMotionBlurCtrls  = false,
    REG_Source_GlobalCtrls = true,
    REG_Source_SizeCtrls   = true,
    REG_Source_AspectCtrls = true,
    REG_Source_DepthCtrls  = true,
    REG_Version            = 0.1,
})

-- パラメーター構造体
HalftoneParams = [[
  int srcSize[2];        // ソース画像のサイズ
  float contrast;        // コントラスト調整（1.0がデフォルト）
  int useOriginalColor;  // 元の色を使用するかどうか（0=白黒、1=カラー）
  int useOriginalBackground; // 背景も元の色にするかどうか（0=紙の色、1=元の色）
  int useCMYKMode;       // CMYKモードを使用するかどうか（0=標準ハーフトーン、1=CMYKスタイル）
  float dotAngle;        // ドットの角度（CMYK モードでのみ使用）
  float aaStrength;      // アンチエイリアス強度（0.0=無効、1.0=強い）
  float dotGain;         // ドットゲイン効果の強さ（0.0-1.0）
  float regError;        // 色版ずれの程度（0.0-1.0）
  float ucrAmount;       // UCR/GCR適用量（0.0-1.0）
  float paperTexture;    // 紙の質感強度（0.0-1.0）
  int paperTextureType;  // 紙の種類（0=なめらか、1=わずかな繊維、2=強い繊維）
  float screenDensity;   // スクリーンの密度
  float paperColor[4];   // 紙の色（背景色）[R,G,B,A]
  int showCellBoundaries; // セル境界を表示（デバッグ用）
]]

-- 標準ハーフトーンカーネル
-- 標準ハーフトーンカーネル
HalftoneKernel = [[
__KERNEL__ void HalftoneKernel(__CONSTANTREF__ HalftoneParams *params, __TEXTURE2D__ src, __TEXTURE2D_WRITE__ dst)
{
    DEFINE_KERNEL_ITERATORS_XY(x, y);

    if (x < params->srcSize[0] && y < params->srcSize[1])
    {
        // 基本ドットサイズ設定 - Screen Densityを使用して計算
        float cellSize;
        cellSize = 1000.0f / params->screenDensity;

        // 六角形パターン用の設定
        float cellSizeX = cellSize;
        float cellSizeY = cellSize * 0.866025f; // √3/2 = 0.866025

        // ドットが外接するように行間を計算
        float maxDotRadius = 0.433f; // 最大ドット半径（黒いエリア）
        float dotDiameter = maxDotRadius * 2.0f * cellSizeX; // ドットの直径（最大時）
        float targetDistanceY = dotDiameter; // ドットの中心間の目標距離（外接するため）
        float cellRowSpacing = targetDistanceY * 0.88f; // 行間隔をドットの直径に設定

        float zigzagFactor = 0.5f;

        // 座標正規化
        float xNorm = (float)x / (float)params->srcSize[0];
        float yNorm = (float)y / (float)params->srcSize[1];
        float4 pixelColor = _tex2DVecN(src, xNorm, yNorm, 15);

        // デフォルト値として背景色を設定
        float4 result;
        if (params->useOriginalBackground == 1) {
            result = pixelColor;
        } else {
            // 配列から float4 を構築
            result = to_float4(
                params->paperColor[0],  // R
                params->paperColor[1],  // G
                params->paperColor[2],  // B
                params->paperColor[3]   // A
            );
        }

        float xf = (float)x;
        float yf = (float)y;

        // セルのグリッド計算 - 行間を縮小して上下に重なるように
        int cellIdX = (int)(xf / cellSizeX);
        int cellIdY = (int)(yf / cellRowSpacing); // cellSizeYではなくcellRowSpacingを使用

        // 現在の行がオフセットされているかをチェック
        bool isCurrentRowOffset = ((cellIdY % 2) != 0);

        // 六角形に特化した探索リストを定義（行タイプごとに最適化）
        // 六角形パターンの方向ベクトル
        const int hexNeighborsCount = 6;
        int hexNeighborsEven[6][2] = {
            {-1, 0}, {1, 0},  // 左右
            {-1, -1}, {0, -1}, // 左上、右上
            {-1, 1}, {0, 1}   // 左下、右下
        };

        int hexNeighborsOdd[6][2] = {
            {-1, 0}, {1, 0},  // 左右
            {0, -1}, {1, -1}, // 左上、右上
            {0, 1}, {1, 1}    // 左下、右下
        };

        // bestAlpha, bestLuma, bestColor, bestScore は従来通り
        float bestAlpha = 0.0f;
        float bestLuma = 1.0f;
        float4 bestColor = result;
        bool hasInfluence = false;
        float bestScore = -1.0f;

        // 中心セルを最初にチェック - これが最も重要
        {
            // 中心セルの計算
            float rowOffsetX = isCurrentRowOffset ? cellSizeX * zigzagFactor : 0.0f;
            float cellCenterX = cellIdX * cellSizeX + rowOffsetX + cellSizeX * 0.5f;
            float cellCenterY = cellIdY * cellRowSpacing + cellSizeY * 0.5f;

            // 距離計算
            float distX = xf - cellCenterX;
            float distY = yf - cellCenterY;
            float distXNorm = distX / cellSizeX;
            float distYNorm = distY / cellSizeY;
            float normDistSq = distXNorm*distXNorm + distYNorm*distYNorm;

            if (normDistSq <= 0.75f) { // 中心セルの影響範囲は少し広めに
                float centerUVx = cellCenterX / (float)params->srcSize[0];
                float centerUVy = cellCenterY / (float)params->srcSize[1];

                if (centerUVx >= 0.0f && centerUVx <= 1.0f && centerUVy >= 0.0f && centerUVy <= 1.0f) {
                    float4 cellColor = _tex2DVecN(src, centerUVx, centerUVy, 15);
                    float cellLuma = cellColor.x * 0.3f + cellColor.y * 0.59f + cellColor.z * 0.11f;
                    cellLuma = _clampf((cellLuma - 0.5f) * params->contrast + 0.5f, 0.0f, 1.0f);

                    // ドット半径計算 - 標準的な方法
                    float radius = maxDotRadius * (1.0f - cellLuma);
                    radius = _fmaxf(radius, 0.01f);

                    // 通常の調整を適用
                    if (cellLuma < 0.3f) {
                        radius += (0.3f - cellLuma) * 0.15f;
                    }
                    if (cellSize < 12.0f) {
                        radius *= (1.0f + (12.0f - cellSize) * 0.03f);
                    }
                    if (params->dotGain > 0.0f) {
                        radius *= (1.0f + params->dotGain * 0.3f);
                    }

                    // アンチエイリアス処理
                    float normDist = _sqrtf(normDistSq);
                    float alpha;

                    if (params->aaStrength <= 0.001f) {
                        alpha = (normDist <= radius) ? 1.0f : 0.0f;
                    } else {
                        float aaWidth = _fmaxf(0.5f / cellSizeX * params->aaStrength, 0.005f);
                        float t = _clampf((normDist - radius + aaWidth) / _fmaxf(aaWidth, 0.0001f), 0.0f, 1.0f);
                        alpha = 1.0f - (t * t * (3.0f - 2.0f * t));
                    }

                    // 中心セル評価
                    if (alpha > 0.01f) {
                        float currentDotLuma = params->useOriginalColor == 1 ?
                                            (cellColor.x * 0.3f + cellColor.y * 0.59f + cellColor.z * 0.11f) : 0.0f;

                        // 中心セルには特別なボーナス
                        float centrality = 1.2f;
                        float lumaScore = (1.0f - currentDotLuma) * 5.0f;
                        float alphaScore = _powf(alpha, 2.0f) * centrality;
                        float score = lumaScore + alphaScore;

                        bestScore = score;
                        bestAlpha = alpha;
                        bestLuma = currentDotLuma;
                        bestColor = params->useOriginalColor == 1 ? cellColor : to_float4(0.0f, 0.0f, 0.0f, 1.0f);
                        hasInfluence = true;
                    }
                }
            }
        }

        // 次に、六角形パターンの周辺セルをチェック - 行タイプに応じた最適なパターン
        for (int i = 0; i < hexNeighborsCount; i++) {
            // 行タイプに応じて正しい探索パターンを選択
            int dx = isCurrentRowOffset ? hexNeighborsOdd[i][0] : hexNeighborsEven[i][0];
            int dy = isCurrentRowOffset ? hexNeighborsOdd[i][1] : hexNeighborsEven[i][1];

            int checkX = cellIdX + dx;
            int checkY = cellIdY + dy;

            // 行に応じたオフセット計算 - オフセットあり(奇数)行は左にずらす
            bool isCheckRowOffset = ((checkY % 2) != 0);
            float rowOffsetX = isCheckRowOffset ? cellSizeX * zigzagFactor : 0.0f;

            // セル中心計算 - 六角形パターンに合わせた正確な位置
            float cellCenterX = checkX * cellSizeX + rowOffsetX + cellSizeX * 0.5f;
            float cellCenterY = checkY * cellRowSpacing + cellSizeY * 0.5f;

            // 距離計算 - 行タイプに応じた調整
            float distX = xf - cellCenterX;
            float distY = yf - cellCenterY;

            // 楕円形状にするための正規化距離
            float distXNorm = distX / cellSizeX;
            float distYNorm = distY / cellSizeY;
            float normDistSq = distXNorm*distXNorm + distYNorm*distYNorm;

            // 距離閾値 - 行によって少し異なる値を使用
            float distThreshold = isCurrentRowOffset == isCheckRowOffset ? 0.625f : 0.645f;

            // 特に上下方向のセルの場合は閾値を調整（六角形の特性に合わせる）
            if (abs(dy) > 0) {
                distThreshold *= 1.05f;  // 垂直方向の接続を強化
            }

            // 早期脱出 - 閾値以上の距離の場合はスキップ
            if (normDistSq > distThreshold) continue;

            // テクスチャ座標計算
            float centerUVx = cellCenterX / (float)params->srcSize[0];
            float centerUVy = cellCenterY / (float)params->srcSize[1];

            // 有効範囲チェック
            if (centerUVx >= 0.0f && centerUVx <= 1.0f && centerUVy >= 0.0f && centerUVy <= 1.0f) {
                float4 cellColor = _tex2DVecN(src, centerUVx, centerUVy, 15);

                // 輝度計算
                float cellLuma = cellColor.x * 0.3f + cellColor.y * 0.59f + cellColor.z * 0.11f;
                cellLuma = _clampf((cellLuma - 0.5f) * params->contrast + 0.5f, 0.0f, 1.0f);

                // ドット半径計算 - 外接するように調整
                float radius = maxDotRadius * (1.0f - cellLuma);
                radius = _fmaxf(radius, 0.01f);

                // 通常の調整
                if (cellLuma < 0.3f) {
                    radius += (0.3f - cellLuma) * 0.15f;
                }
                if (cellSize < 12.0f) {
                    radius *= (1.0f + (12.0f - cellSize) * 0.03f);
                }
                if (params->dotGain > 0.0f) {
                    radius *= (1.0f + params->dotGain * 0.3f);
                }

                // アンチエイリアス処理
                float normDist = _sqrtf(normDistSq);
                float alpha;

                if (params->aaStrength <= 0.001f) {
                    alpha = (normDist <= radius) ? 1.0f : 0.0f;
                } else {
                    float aaWidth = _fmaxf(0.5f / cellSizeX * params->aaStrength, 0.005f);
                    float t = _clampf((normDist - radius + aaWidth) / _fmaxf(aaWidth, 0.0001f), 0.0f, 1.0f);
                    alpha = 1.0f - (t * t * (3.0f - 2.0f * t));
                }

                if (alpha > 0.01f) {
                    // ドットの輝度を計算
                    float currentDotLuma;
                    if (params->useOriginalColor == 1) {
                        currentDotLuma = cellColor.x * 0.3f + cellColor.y * 0.59f + cellColor.z * 0.11f;
                    } else {
                        currentDotLuma = 0.0f;
                    }

                    // 行タイプ特性と方向を考慮したスコア計算
                    float lumaDiffWeight = 5.0f;

                    // 周辺セルの方向性に基づいた重み付け - 特に非オフセット行の垂直方向を強化
                    float dirBonus = 0.0f;
                    if (!isCurrentRowOffset && abs(dy) > 0) {
                        dirBonus = 0.3f;  // 垂直方向への接続を強化
                    }

                    // 同じ行タイプの場合はさらにボーナス
                    float rowTypeBonus = (isCurrentRowOffset == isCheckRowOffset) ? 0.2f : 0.0f;

                    // 輝度差のスコア（暗いほど大きな正の値）
                    float lumaScore = (1.0f - currentDotLuma) * lumaDiffWeight;

                    // アルファベースのスコア
                    float alphaPower = isCurrentRowOffset ? 2.0f : 2.2f; // 非オフセット行はアルファ影響強化
                    float alphaScore = _powf(alpha, alphaPower);

                    // 総合スコア
                    float score = lumaScore + alphaScore + dirBonus + rowTypeBonus;

                    // スコアが高い場合は更新
                    if (score > bestScore) {
                        bestScore = score;
                        bestAlpha = alpha;
                        bestLuma = currentDotLuma;
                        bestColor = params->useOriginalColor == 1 ? cellColor : to_float4(0.0f, 0.0f, 0.0f, 1.0f);
                        hasInfluence = true;
                    }
                }
            }
        }

        // 最適なドットを直接適用（すでに最良のものを選んでいる）
        if (hasInfluence) {
            // 既存背景の輝度を計算
            float bgLuma = result.x * 0.3f + result.y * 0.59f + result.z * 0.11f;

            // 暗いドットほど強い影響度を持つよう調整 - 行タイプごとに最適化
            float darknessFactor = 1.0f - bestLuma;

            // 非オフセット行はより強い影響が必要
            float rowTypeEnhancement = isCurrentRowOffset ? 2.0f : 2.25f;
            darknessFactor = _fminf(darknessFactor * rowTypeEnhancement, 1.0f);

            // 強化されたブレンド係数
            float enhancedBlend = bestAlpha + darknessFactor * (1.0f - bestAlpha);

            // 非オフセット行はブレンドをさらに強化
            if (!isCurrentRowOffset) {
                enhancedBlend = _fminf(enhancedBlend * 1.1f, 1.0f);
            }

            // 常に暗いドットを優先
            if (bestAlpha > 0.7f) {
                // 中心部分は完全に上書き
                result = bestColor;
            }
            else if (bestLuma < bgLuma || bestAlpha > 0.3f) {
                // エッジ部分は暗さとアルファを考慮してブレンド
                float blendFactor = _fmaxf(bestAlpha * 1.5f, enhancedBlend);
                blendFactor = _fminf(blendFactor, 1.0f); // 最大1に制限

                float4 blendedColor;
                blendedColor.x = _mix(result.x, bestColor.x, blendFactor);
                blendedColor.y = _mix(result.y, bestColor.y, blendFactor);
                blendedColor.z = _mix(result.z, bestColor.z, blendFactor);

                result = blendedColor;
            }
        }

        // 紙の質感適用
        if (params->paperTexture > 0.0f) {
            float noise = 0.0f;
            float intensityMod = 1.0f;
            float frequencyMod = 1.0f;

            // 紙のタイプに応じたパラメータ設定
            if (params->paperTextureType == 0) { // Smooth
                frequencyMod = 0.9f;
                intensityMod = 0.6f;
            }
            else if (params->paperTextureType == 1) { // Light
                frequencyMod = 0.5f;
                intensityMod = 1.0f;
            }
            else { // Heavy
                frequencyMod = 0.3f;
                intensityMod = 1.8f;
            }

            // 共通の効率的なノイズ計算
            float baseNoise = _sinf(xf * 0.3f * frequencyMod + yf * 0.27f) *
                             _cosf(yf * 0.13f * frequencyMod + xf * 0.07f);

            // Heavy Texture用に追加の粒状感
            if (params->paperTextureType == 2 &&
                _fabs(_sinf(xf * 1.2f + yf * 1.3f)) > 0.96f) {
                baseNoise += 0.7f;
            }

            noise = (baseNoise * 0.5f + 0.5f) * params->paperTexture * 0.25f * intensityMod;

            // コントラスト調整
            float noiseEffect = noise - params->paperTexture * 0.05f;
            noiseEffect *= (noise < 0.0f) ? 1.5f : 1.2f;

            // 色に適用
            result.x = _clampf(result.x + noiseEffect, 0.0f, 1.0f);
            result.y = _clampf(result.y + noiseEffect, 0.0f, 1.0f);
            result.z = _clampf(result.z + noiseEffect, 0.0f, 1.0f);
        }

        // セル境界線の描画（デバッグ用）- 行間縮小した六角形パターンに対応
        if (params->showCellBoundaries == 1) {
            // セルのグリッドライン描画
            float gridLineThickness = 1.0f;

            // 現在のピクセルが属するセルの座標 - 行間縮小対応
            int currentCellX = (int)(xf / cellSizeX);
            int currentCellY = (int)(yf / cellRowSpacing); // cellRowSpacingを使用

            // 現在のセルの左上隅の座標 - 行間縮小対応
            float cellLeft = currentCellX * cellSizeX;
            float cellTop = currentCellY * cellRowSpacing; // cellRowSpacingを使用

            // 現在の行に応じたオフセット
            float rowOffset = ((currentCellY % 2) != 0) ? cellSizeX * zigzagFactor : 0.0f;

            // セルの境界線かどうかをチェック
            bool onBoundary = false;

            // 水平方向の境界 - セルの実際の高さ（cellSizeY）を使用
            if (_fabs(yf - cellTop) < gridLineThickness ||
                _fabs(yf - (cellTop + cellSizeY)) < gridLineThickness) {
                onBoundary = true;
            }

            // 垂直方向の境界
            if (_fabs(xf - (cellLeft + rowOffset)) < gridLineThickness ||
                _fabs(xf - (cellLeft + rowOffset + cellSizeX)) < gridLineThickness) {
                onBoundary = true;
            }

            // 境界線を緑色で描画
            if (onBoundary) {
                // 元の色と緑色をブレンド（半透明な境界線）
                result = to_float4(0.0f, 1.0f, 0.0f, 1.0f);
            }

            // 最大ドットサイズを赤い点線で表示（オプション）
            for (int dy = -1; dy <= 1; dy++) {
                for (int dx = -1; dx <= 1; dx++) {
                    // 対角セルをスキップ（効率化）
                    if (abs(dx) + abs(dy) == 2) continue;

                    int checkX = currentCellX + dx;
                    int checkY = currentCellY + dy;

                    float checkRowOffsetX = ((checkY % 2) != 0) ? cellSizeX * zigzagFactor : 0.0f;
                    float cellCenterX = checkX * cellSizeX + checkRowOffsetX + cellSizeX * 0.5f;
                    float cellCenterY = checkY * cellRowSpacing + cellSizeY * 0.5f; // cellRowSpacingを使用

                    // 最大ドットサイズの範囲を示す赤い円
                    float distX = xf - cellCenterX;
                    float distY = yf - cellCenterY;
                    float distXNorm = distX / cellSizeX;
                    float distYNorm = distY / cellSizeY;
                    float normDistSq = distXNorm*distXNorm + distYNorm*distYNorm;
                    float normDist = _sqrtf(normDistSq);

                    // 最大ドット半径の0.433に近い位置を赤色で示す（点線風に）
                    float maxRadius = 0.433f; // 最大ドット半径
                    if (_fabs(normDist - maxRadius) < 0.01f) {
                        // 点線パターン
                        if ((int)(xf * 0.5f + yf * 0.5f) % 4 < 2) {
                            result = to_float4(1.0f, 0.0f, 0.0f, 1.0f);
                        }
                    }
                }
            }

            // セルの中心点を青い点で表示（オプション）
            float centerX = currentCellX * cellSizeX + rowOffset + cellSizeX * 0.5f;
            float centerY = currentCellY * cellRowSpacing + cellSizeY * 0.5f;

            if (_fabs(xf - centerX) < 2.0f && _fabs(yf - centerY) < 2.0f) {
                result = to_float4(0.0f, 0.0f, 1.0f, 1.0f); // 青色でセル中心を示す
            }
        }

        _tex2DVec4Write(dst, x, y, result);
    }
}
]]

-- CMYKモード処理用のカーネル
-- 最適化されたCMYKモード処理用カーネル
CmykKernel = [[
__KERNEL__ void CmykKernel(__CONSTANTREF__ HalftoneParams *params, __TEXTURE2D__ src, __TEXTURE2D_WRITE__ dst)
{
    DEFINE_KERNEL_ITERATORS_XY(x, y);

    if (x < params->srcSize[0] && y < params->srcSize[1])
    {
        // 基本設定 スクリーン線数からドットサイズを計算
        float cellSize = 1000.0f / _fmaxf(0.1f, params->screenDensity);

        // 現在のピクセルの正規化座標
        float xNorm = (float)x / (float)params->srcSize[0];
        float yNorm = (float)y / (float)params->srcSize[1];
        float2 pixelUV = to_float2(xNorm, yNorm);

        // 現在のピクセルの色を取得
        float4 pixelColor = _tex2DVecN(src, pixelUV.x, pixelUV.y, 15);

        // デフォルト値として背景色を設定
        float4 result;
        if (params->useOriginalBackground == 1) {
            result = pixelColor;
        } else {
            // 配列から float4 を構築
            result = to_float4(
                params->paperColor[0],  // R
                params->paperColor[1],  // G
                params->paperColor[2],  // B
                params->paperColor[3]   // A
            );
        }


        // 事前計算
        float xf = (float)x;
        float yf = (float)y;

        // 各チャンネル（CMYK）ごとに処理
        float angles[4] = {18.4f, 71.6f, 0.0f, 45.0f}; // C、M、Y、Kの角度
        float3 colors[3] = {
            to_float3(0.0f, 0.85f, 0.85f), // シアン（より濃いめ）
            to_float3(0.85f, 0.0f, 0.85f), // マゼンタ（より濃いめ）
            to_float3(0.85f, 0.85f, 0.0f)  // イエロー（より濃いめ）
        };

        // サイズ係数を計算
        float cellSizes[4];
        for (int i = 0; i < 4; i++) {
            cellSizes[i] = cellSize;
            if (i == 1) cellSizes[i] *= 1.05f;      // マゼンタ
            else if (i == 2) cellSizes[i] *= 0.95f; // イエロー
        }

        // 基本オフセットとレジストレーションエラー
        float2 offsets[4];
        for (int i = 0; i < 4; i++) {
            offsets[i] = to_float2(0.0f, 0.0f);
        }
        offsets[1].x = cellSizes[1] * 0.25f;
        offsets[2].y = cellSizes[2] * 0.25f;
        offsets[3].x = cellSizes[3] * 0.125f;
        offsets[3].y = cellSizes[3] * 0.125f;

        // レジストレーションエラーを計算（最適化）
        if (params->regError > 0.01f) {
            float regScale = params->regError * cellSize * 0.1f;
            offsets[0].x += regScale * 0.53f;
            offsets[0].y += regScale * 0.23f;
            offsets[1].x -= regScale * 0.33f;
            offsets[1].y += regScale * 0.41f;
            offsets[2].x += regScale * 0.17f;
            offsets[2].y -= regScale * 0.37f;
        }

        // 各チャンネルの影響度
        float channelMask[4] = {0.0f, 0.0f, 0.0f, 0.0f};
        float4 channelColors[4];
        bool hasChannelInfluence[4] = {false, false, false, false};

        // CMYKの各チャンネルごとの処理
        for (int channel = 0; channel < 4; channel++) {
            float angle = angles[channel] * 0.01745329f; // ラジアンに変換
            float cosAngle = _cosf(angle);
            float sinAngle = _sinf(angle);

            // 回転とオフセットを適用
            float rotX = xf * cosAngle - yf * sinAngle + offsets[channel].x;
            float rotY = xf * sinAngle + yf * cosAngle + offsets[channel].y;

            // 最も近いセルの中心を見つける
            int cellIdX = (int)(rotX / cellSizes[channel]);
            int cellIdY = (int)(rotY / cellSizes[channel]);

            // 周囲のセルをチェック - 検索範囲を最適化
            for (int dy = -1; dy <= 1; dy++) {
                for (int dx = -1; dx <= 1; dx++) {
                    // 対角セルの場合は効率化（対角セルは距離が遠いので75%スキップ）
                    if (abs(dx) + abs(dy) == 2) {
                        if (_fabs(_sinf(xf * 12.34f + yf * 56.78f)) > 0.5f) {
                            continue;
                        }
                    }

                    int checkX = cellIdX + dx;
                    int checkY = cellIdY + dy;

                    // 奇数行は水平方向にオフセット
                    float offsetX = ((checkY % 2) != 0) ? 0.5f : 0.0f;

                    // セル中心座標
                    float cellCenterX = (checkX + offsetX) * cellSizes[channel];
                    float cellCenterY = checkY * cellSizes[channel] + cellSizes[channel] * 0.5f;

                    // 特別なセルパターン調整（K版のみ）
                    if (channel == 3) {
                        bool isOddCell = ((checkX + checkY) % 2 != 0);
                        float adjustY = isOddCell ? 0.075f : -0.075f;
                        cellCenterY += cellSizes[channel] * adjustY;

                        // 市松模様補正
                        if ((checkY % 2) != 0 && (checkX % 2) == 0) {
                            cellCenterY += cellSizes[channel] * 0.075f;
                        } else if ((checkY % 2) == 0 && (checkX % 2) != 0) {
                            cellCenterY -= cellSizes[channel] * 0.075f;
                        }
                    }

                    // 現在のピクセルからセル中心への距離
                    float distX = rotX - cellCenterX;
                    float distY = rotY - cellCenterY;
                    float dist = _sqrtf(distX*distX + distY*distY);

                    // 早期脱出条件を強化（性能改善）
                    if (dist > cellSizes[channel] * 0.75f) continue;

                    // セル中心の画像上の座標に変換
                    float invX = cellCenterX * cosAngle + cellCenterY * sinAngle - offsets[channel].x;
                    float invY = -cellCenterX * sinAngle + cellCenterY * cosAngle - offsets[channel].y;

                    // 正規化座標
                    float centerUVx = invX * (1.0f / (float)params->srcSize[0]);
                    float centerUVy = invY * (1.0f / (float)params->srcSize[1]);

                    // テクスチャ範囲内かチェック
                    if (centerUVx >= 0.0f && centerUVx <= 1.0f && centerUVy >= 0.0f && centerUVy <= 1.0f) {
                        // セル中心の色
                        float4 cellColor = _tex2DVecN(src, centerUVx, centerUVy, 15);

                        // チャンネル値計算 - UCR/GCR処理を適用
                        float channelValue = 0.0f;

                        // CMY版の場合
                        if (channel < 3) {
                            channelValue = channel == 0 ? (1.0f - cellColor.x) :
                                          (channel == 1 ? (1.0f - cellColor.y) : (1.0f - cellColor.z));

                            // UCR処理
                            if (params->ucrAmount > 0.0f) {
                                float minVal = _fminf(_fminf(1.0f-cellColor.x, 1.0f-cellColor.y), 1.0f-cellColor.z);
                                channelValue -= minVal * params->ucrAmount;
                                channelValue = _fmaxf(0.0f, channelValue);
                            }
                        } else {
                            // K版の場合
                            channelValue = 1.0f - _fmaxf(_fmaxf(cellColor.x, cellColor.y), cellColor.z);

                            // UCR強化
                            if (params->ucrAmount > 0.0f) {
                                float minVal = _fminf(_fminf(1.0f-cellColor.x, 1.0f-cellColor.y), 1.0f-cellColor.z);
                                channelValue = _fminf(1.0f, channelValue + minVal * params->ucrAmount * 0.7f);
                            }
                        }

                        // コントラスト調整
                        channelValue = _clampf((channelValue - 0.5f) * params->contrast + 0.5f, 0.0f, 1.0f);

                        // ドット半径計算（最適化）
                        float radius = 0.5f * channelValue;
                        radius = _fmaxf(radius, 0.01f);

                        // ドットゲイン効果（条件分岐削減）
                        radius *= (1.0f + params->dotGain * 0.3f);

                        // セル半径と距離を比較
                        float normDist = dist / cellSizes[channel];

                        // アンチエイリアス処理
                        float edge = radius;
                        float aaWidth = 0.7f / cellSizes[channel] * params->aaStrength;
                        float t = _clampf((normDist - edge + aaWidth) / _fmaxf(aaWidth, 0.0001f), 0.0f, 1.0f);
                        float alpha = 1.0f - (t * t * (3.0f - 2.0f * t)); // smoothstep

                        // 影響度の更新
                        if (alpha > 0.01f && alpha > channelMask[channel]) {
                            channelMask[channel] = alpha;
                            hasChannelInfluence[channel] = true;

                            // 色の設定
                            if (channel < 3) {
                                if (params->useOriginalColor == 1) {
                                    // 元の色を基に、該当チャンネルだけ削除
                                    // 紙の色ではなく純粋な黒または他のチャンネル値を使用
                                    channelColors[channel] = cellColor;
                                    if (channel == 0) channelColors[channel].x = 0.0f; // 紙の色に関係なく0に
                                    else if (channel == 1) channelColors[channel].y = 0.0f; // 紙の色に関係なく0に
                                    else channelColors[channel].z = 0.0f; // 紙の色に関係なく0に
                                } else {
                                    // プロセスカラーも紙の色に影響されない固定値
                                    channelColors[channel] = to_float4(colors[channel].x, colors[channel].y, colors[channel].z, 1.0f);
                                }
                            } else {
                                // K版は常に純粋な黒（紙の色に関係なく）
                                channelColors[channel] = to_float4(0.0f, 0.0f, 0.0f, 1.0f);
                            }
                        }
                    }
                }
            }
        }

        // CMY版の適用（最適化）
        float4 cmyResult;
        if (params->useOriginalBackground == 1) {
            cmyResult = pixelColor;
        } else {
            // 紙の色の代わりに純粋な白から始める（インク色用）
            cmyResult = to_float4(1.0f, 1.0f, 1.0f, 1.0f);
        }
        float totalMask = 0.0f;

        // マスクの合計を先に計算
        for (int i = 0; i < 3; i++) {
            if (hasChannelInfluence[i] && channelMask[i] > 0.0f) {
                totalMask += channelMask[i];
            }
        }

        // 単純化したブレンド処理
        for (int i = 0; i < 3; i++) {
            if (hasChannelInfluence[i] && channelMask[i] > 0.0f) {
                float factor = channelMask[i];

                if (factor > 0.5f) {
                    // 最小値で合成（よりダークになるように）
                    cmyResult.x = _fminf(cmyResult.x, channelColors[i].x);
                    cmyResult.y = _fminf(cmyResult.y, channelColors[i].y);
                    cmyResult.z = _fminf(cmyResult.z, channelColors[i].z);
                } else {
                    // エッジ部分はブレンド
                    float blendFactor = factor * 2.5f;
                    cmyResult.x = _mix(cmyResult.x, _fminf(cmyResult.x, channelColors[i].x), blendFactor);
                    cmyResult.y = _mix(cmyResult.y, _fminf(cmyResult.y, channelColors[i].y), blendFactor);
                    cmyResult.z = _mix(cmyResult.z, _fminf(cmyResult.z, channelColors[i].z), blendFactor);
                }
            }
        }

        // 全体の濃度調整（最適化）
        if (totalMask > 0.0f) {
            float darkening = _fminf(totalMask / 3.0f * 0.2f, 0.2f);
            float brightnessFactor = 1.0f - darkening;
            cmyResult.x *= brightnessFactor;
            cmyResult.y *= brightnessFactor;
            cmyResult.z *= brightnessFactor;
        }

        // K版の適用
        float4 inkResult = cmyResult;  // inkResultはインク色のみを計算
        if (hasChannelInfluence[3] && channelMask[3] > 0.0f) {
            if (channelMask[3] > 0.5f) {
                // 中心部分は黒で上書き
                inkResult = to_float4(0.0f, 0.0f, 0.0f, 1.0f);
            } else {
                // エッジブレンド
                float blendFactor = channelMask[3] * 2.0f;
                inkResult = _mix(cmyResult, to_float4(0.0f, 0.0f, 0.0f, 1.0f), blendFactor);
            }
        }

        // インク色と紙の色を合成（インク部分のマスクを計算）
        float inkMask = 0.0f;
        for (int i = 0; i < 4; i++) {
            if (hasChannelInfluence[i]) {
                inkMask = _fmaxf(inkMask, channelMask[i]);
            }
        }

        // インク色と紙の色（またはオリジナル背景）をブレンド
        if (inkMask > 0.001f) {
            result = _mix(result, inkResult, inkMask);
        } else {
            // インクの影響がない場合はそのまま背景色
        }

        // 紙の質感適用（効率化）
        if (params->paperTexture > 0.01f) {
            float noise = 0.0f;
            float intensityMod = 1.0f;
            float frequencyMod = 1.0f;

            // 紙のタイプに応じたパラメータ設定
            if (params->paperTextureType == 0) { // Smooth
                frequencyMod = 0.9f;
                intensityMod = 0.6f;
            }
            else if (params->paperTextureType == 1) { // Light
                frequencyMod = 0.5f;
                intensityMod = 1.0f;
            }
            else { // Heavy
                frequencyMod = 0.3f;
                intensityMod = 1.8f;
            }

            // 共通の効率的なノイズ計算
            float baseNoise = _sinf(xf * 0.3f * frequencyMod + yf * 0.27f) *
                             _cosf(yf * 0.13f * frequencyMod + xf * 0.07f);

            // Heavy Texture用に追加の粒状感
            if (params->paperTextureType == 2 &&
                _fabs(_sinf(xf * 1.2f + yf * 1.3f)) > 0.96f) {
                baseNoise += 0.7f;
            }

            noise = (baseNoise * 0.5f + 0.5f) * params->paperTexture * 0.25f * intensityMod;

            // コントラスト調整（分岐を減らす）
            float noiseEffect = noise - params->paperTexture * 0.05f;
            noiseEffect *= (noise < 0.0f) ? 1.5f : 1.2f;

            // 色に適用
            result.x = _clampf(result.x + noiseEffect, 0.0f, 1.0f);
            result.y = _clampf(result.y + noiseEffect, 0.0f, 1.0f);
            result.z = _clampf(result.z + noiseEffect, 0.0f, 1.0f);
        }

        _tex2DVec4Write(dst, x, y, result);
    }
}
]]

function Create()
    local groupID = 0

    InUseCMYKMode = self:AddInput("CMYK Mode", "UseCMYKMode", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Integer = true,
        INP_Default = 0.0,
        INPS_StatusText = "Enables CMYK-style halftone separation",
    })

    InScreenDensity = self:AddInput("Screen Density", "ScreenDensity", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 130.0,
        INP_MinAllowed = 0.001,
        INP_MaxAllowed = 600.0,
        INPID_PreviewControl = "RangeControl",
        INP_Integer = false,
        INPS_StatusText = "Controls the density of the halftone pattern in CMYK mode",
    })

    InContrast = self:AddInput("Contrast", "Contrast", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 1.0,
        INP_MinAllowed = 0.1,
        INP_MaxAllowed = 15.0,
        INPS_StatusText = "Adjusts the contrast of the halftone pattern",
    })

    InUseOriginalColor = self:AddInput("Use Original Color", "UseOriginalColor", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Default = 0.0,
        INPS_StatusText = "Preserves original colors instead of black and white",
    })

    InUseOriginalBackground = self:AddInput("Color Background", "UseOriginalBackground", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Default = 0.0,
        INPS_StatusText = "Uses original image colors for background instead of white",
    })

    InAAStrength = self:AddInput("AA Strength", "AAStrength", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.3,
        INP_MinAllowed = 0.0,
        INP_MaxAllowed = 10.0,
        INPS_StatusText = "Controls the strength of anti-aliasing on dot edges",
    })

    InDotGain = self:AddInput("Dot Gain", "DotGain", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.3,
        INP_MinAllowed = 0.0,
        INP_MaxAllowed = 1.0,
        INPS_StatusText = "Simulates ink spread on paper",
    })

    InRegError = self:AddInput("Registration Error", "RegError", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.2,
        INP_MinAllowed = 0.0,
        INP_MaxAllowed = 1.0,
        INPS_StatusText = "Simulates misalignment between color plates",
    })

    InUcrAmount = self:AddInput("UCR Amount", "UcrAmount", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.5,
        INP_MinAllowed = 0.0,
        INP_MaxAllowed = 1.0,
        INPS_StatusText = "Controls Under Color Removal in CMYK mode",
    })

    self:BeginControlNest("Paper", "Paper", true);

    InPaperTexture = self:AddInput("Paper Texture", "PaperTexture", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.1,
        INP_MinAllowed = 0.0,
        INP_MaxAllowed = 1.0,
        INPS_StatusText = "Adds simulated paper texture to the output",
    })

    InPaperType = self:AddInput("Paper Type", "PaperType", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ComboControl",
        INP_Default = 0,
        INP_Integer = true,
        { CCS_AddString = "Smooth" },
        { CCS_AddString = "Light Texture" },
        { CCS_AddString = "Heavy Texture" },
        INPS_StatusText = "Selects the type of paper texture pattern",
    })

    InPaperColorPreset = self:AddInput("Paper Color Preset", "PaperColorPreset", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ComboControl",
        INP_Default = 0,
        INP_Integer = true,
        INP_DoNotifyChanged = true,
        { CCS_AddString = "Custom" },
        { CCS_AddString = "Pure White" },
        { CCS_AddString = "Warm White" },
        { CCS_AddString = "Cool White" },
        { CCS_AddString = "Natural White" },
        { CCS_AddString = "Cream" },
        { CCS_AddString = "Ivory" },
        { CCS_AddString = "Light Gray" },
        { CCS_AddString = "Newspaper" },
        { CCS_AddString = "Vintage" },
        { CCS_AddString = "Kraft" },
        { CCS_AddString = "Recycled" },
        { CCS_AddString = "Light Blue" },
        { CCS_AddString = "Light Green" },
        { CCS_AddString = "Light Pink" },
        { CCS_AddString = "Light Yellow" },
        INPS_StatusText = "Select from common paper color presets",
    })

    groupID = groupID + 1
    InPaperColorRed = self:AddInput("Paper Color Red", "PaperColorRed", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupID,
        IC_ControlID       = 0, -- Red ID
        INPS_StatusText    = "Sets the paper color (background)",
    })

    InPaperColorGreen = self:AddInput("Paper Color Green", "PaperColorGreen", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupID,
        IC_ControlID       = 1, -- Green ID
        INPS_StatusText    = "Sets the paper color (background)",
    })

    InPaperColorBlue = self:AddInput("Paper Color Blue", "PaperColorBlue", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupID,
        IC_ControlID       = 2, -- Blue ID
        INPS_StatusText    = "Sets the paper color (background)",
    })

    InPaperColorAlpha = self:AddInput("Paper Color Alpha", "PaperColorAlpha", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupID,
        IC_ControlID       = 3, -- Alpha ID
        INPS_StatusText    = "Sets the paper color (background)",
    })
    self:EndControlNest()


    InShowCellBoundaries = self:AddInput("Show Cell Boundaries", "ShowCellBoundaries", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Integer = true,
        INP_Default = 0.0,
        INPS_StatusText = "Debug: Show cell boundaries with green lines",
    })

    InImage = self:AddInput("Input Image", "Image", {
        LINKID_DataType = "Image",
        LINK_Main = 1,
        INPS_StatusText = "Input image to be processed",
    })
end

function Process(req)
    local contrast = InContrast:GetValue(req).Value
    local useOriginalColor = InUseOriginalColor:GetValue(req).Value
    local useOriginalBackground = InUseOriginalBackground:GetValue(req).Value
    local useCMYKMode = InUseCMYKMode:GetValue(req).Value
    local aaStrength = InAAStrength:GetValue(req).Value
    local screenDensity = InScreenDensity:GetValue(req).Value
    local dotGain = InDotGain:GetValue(req).Value
    local regError = InRegError:GetValue(req).Value
    local ucrAmount = InUcrAmount:GetValue(req).Value
    local paperTexture = InPaperTexture:GetValue(req).Value
    local paperType = InPaperType:GetValue(req).Value
    local paperColor = {
        InPaperColorRed:GetValue(req).Value,
        InPaperColorGreen:GetValue(req).Value,
        InPaperColorBlue:GetValue(req).Value,
        InPaperColorAlpha:GetValue(req).Value,
    }



    local img = InImage:GetValue(req)
    local out

    if img then
        out = Image({ IMG_Like = img })

        -- CMYKモードかどうかによってカーネルを選択
        local kernelName, kernelCode
        if useCMYKMode > 0.5 then
            kernelName = "CmykKernel"
            kernelCode = CmykKernel
        else
            kernelName = "HalftoneKernel"
            kernelCode = HalftoneKernel
        end

        local node = DVIPComputeNode(req, kernelName, kernelCode, "HalftoneParams", HalftoneParams)

        if node then
            -- create image
            local params = node:GetParamBlock(HalftoneParams)

            -- 基本パラメータ設定
            params.contrast = contrast
            params.screenDensity = screenDensity
            params.srcSize[0] = out.DataWindow:Width()
            params.srcSize[1] = out.DataWindow:Height()
            params.useOriginalColor = useOriginalColor > 0.5 and 1 or 0
            params.useOriginalBackground = useOriginalBackground > 0.5 and 1 or 0
            params.useCMYKMode = useCMYKMode > 0.5 and 1 or 0
            params.dotAngle = 0.0
            params.aaStrength = aaStrength
            params.dotGain = dotGain
            params.regError = regError
            params.ucrAmount = ucrAmount
            params.paperTexture = paperTexture
            params.paperTextureType = paperType
            params.paperColor[0] = paperColor[1] -- R
            params.paperColor[1] = paperColor[2] -- G
            params.paperColor[2] = paperColor[3] -- B
            params.paperColor[3] = paperColor[4] -- A
            params.showCellBoundaries = InShowCellBoundaries:GetValue(req).Value > 0.5 and 1 or 0

            node:SetParamBlock(params)

            node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR, TEX_ADDRESS_MODE_CLAMP, TEX_NORMALIZED_COORDS_TRUE)
            node:AddInput("src", img)
            node:AddOutput("dst", out)

            success = node:RunSession(req)
        else
            out = nil
        end
    end

    OutImage:Set(req, out)
end

function NotifyChanged(inp, param, time)
    if inp == InUseOriginalBackground then
        -- オリジナル背景を使用する場合は紙の色設定を無効化
        local useOrigBg = (param.Value > 0.5)
        InPaperColorRed:SetAttrs({ INPS_Disabled = useOrigBg })
        InPaperColorGreen:SetAttrs({ INPS_Disabled = useOrigBg })
        InPaperColorBlue:SetAttrs({ INPS_Disabled = useOrigBg })
        InPaperColorAlpha:SetAttrs({ INPS_Disabled = useOrigBg })
        InPaperColorPreset:SetAttrs({ INPS_Disabled = useOrigBg })
    elseif inp == InPaperColorPreset then
        -- 紙の色プリセットが選択された場合
        local presetIndex = math.floor(param.Value + 0.5)

        -- プリセット値の設定
        local r, g, b = 1.0, 1.0, 1.0 -- デフォルト値（白）

        if presetIndex == 1 then      -- Pure White
            r, g, b = 1.00, 1.00, 1.00
        elseif presetIndex == 2 then  -- Warm White
            r, g, b = 1.00, 0.98, 0.94
        elseif presetIndex == 3 then  -- Cool White
            r, g, b = 0.97, 0.97, 1.00
        elseif presetIndex == 4 then  -- Natural White
            r, g, b = 0.98, 0.98, 0.96
        elseif presetIndex == 5 then  -- Cream
            r, g, b = 0.97, 0.95, 0.86
        elseif presetIndex == 6 then  -- Ivory
            r, g, b = 1.00, 0.97, 0.90
        elseif presetIndex == 7 then  -- Light Gray
            r, g, b = 0.90, 0.90, 0.90
        elseif presetIndex == 8 then  -- Newspaper
            r, g, b = 0.93, 0.91, 0.83
        elseif presetIndex == 9 then  -- Vintage
            r, g, b = 0.96, 0.92, 0.80
        elseif presetIndex == 10 then -- Kraft
            r, g, b = 0.85, 0.75, 0.58
        elseif presetIndex == 11 then -- Recycled
            r, g, b = 0.87, 0.87, 0.82
        elseif presetIndex == 12 then -- Light Blue
            r, g, b = 0.90, 0.95, 1.00
        elseif presetIndex == 13 then -- Light Green
            r, g, b = 0.90, 0.98, 0.90
        elseif presetIndex == 14 then -- Light Pink
            r, g, b = 1.00, 0.90, 0.93
        elseif presetIndex == 15 then -- Light Yellow
            r, g, b = 1.00, 1.00, 0.88
        end

        -- カラーコントロールに値をセット
        if presetIndex > 0 then
            InPaperColorRed:SetSource(Number(r), time)
            InPaperColorGreen:SetSource(Number(g), time)
            InPaperColorBlue:SetSource(Number(b), time)
        end
    end

    return true
end
