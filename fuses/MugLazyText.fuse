--[[--
Mug Lazy Text
--]] --

--******************************************************************************************************
FuRegisterClass("MugLazyText", CT_Tool, {
    REGS_Name             = "Mug Lazy Text",
    REGS_Category         = "Fuses\\Mug",
    REGS_OpIconString     = "MLT",
    REGS_OpDescription    = "Mug Lazy Text",
    REGS_HelpTopic        = "https://x.com/MugLab3",     --This can be a URL
    REGS_URL              = "https://www.youtube.com/@MugLabVideoEditing",
    REGS_IconID           = "Icons.Tools.Icons.Example", -- This can be Inline as an array of Values
    REG_OpNoMask          = false,
    REG_NoBlendCtrls      = false,
    REG_NoObjMatCtrls     = true,
    REG_NoMotionBlurCtrls = true,
    REG_Fuse_NoEdit       = false,
    REG_Fuse_NoReload     = false,
    REG_SupportsDoD       = true,
    REG_NoPreCalcProcess  = false,
    REG_Version           = 1.1,
})

local TypeInHighlight = {
    New = function(range, font, mainColor, outline)
        return {
            RangeType = range.RangeType,
            Range = {
                Low = range.Low,
                High = range.High,
            },
            SpecificStrings = range.SpecificStrings,
            Font = {
                UseMainFont = font.useMainFont,
                Name = font.Name,
                Style = font.Style,
                Size = font.Size,
                SpaceSize = font.SpaceSize,
                Tracking = font.Tracking,
            },
            ColorTarget = mainColor.ColorTarget,
            MainColor = {
                R = mainColor.R,
                G = mainColor.G,
                B = mainColor.B,
                A = mainColor.A,
            },
            Outline = {
                UseMainOutline = outline.UseMainOutline,
                Type = outline.Type,
                Num = outline.Num,
                Thickness = outline.Thickness,
                Color1 = {
                    R = outline.Color1.R,
                    G = outline.Color1.G,
                    B = outline.Color1.B,
                    A = outline.Color1.A,
                },
                Color2 = {
                    R = outline.Color2.R,
                    G = outline.Color2.G,
                    B = outline.Color2.B,
                    A = outline.Color2.A,
                },
            }
        }
    end
}

local function createHighlightControl(num, groupId)
    local highlightControlID = groupId
    InHighlight = {}

    self:AddControlPage("Highlight")
    for i = 1, num do
        local id = "Highlight" .. i
        local name = "Highlight " .. i
        self:BeginControlNest(name, id, true);

        local rangeType = self:AddInput("Range Type", "RangeType" .. id, {
            LINKID_DataType    = "Number",
            INPID_InputControl = "MultiButtonControl",
            INP_Default        = 0,
            { MBTNC_AddButton = "Manual",           MBTNCD_ButtonWidth = 1 / 2, },
            { MBTNC_AddButton = "Specific Strings", MBTNCD_ButtonWidth = 1 / 2, },
            INP_Integer = true,
            INP_DoNotifyChanged = true,
        })

        highlightControlID = highlightControlID + 1
        local rangeLow = self:AddInput("Low", "RangeLow" .. id, {
            LINKID_DataType = "Number",
            INPID_InputControl = "RangeControl",
            INP_Default = 0.0,
            INP_MinAllowed = 0,
            -- INP_MaxAllowed = 0,
            IC_ControlGroup = highlightControlID,
            IC_ControlID = 0,
            INP_Integer = true,
        })
        local rangeHigh = self:AddInput("High", "RangeHigh" .. id, {
            LINKID_DataType = "Number",
            INPID_InputControl = "RangeControl",
            INP_Default = 0.0,
            INP_MinAllowed = 0,
            -- INP_MaxAllowed = 0,
            IC_ControlGroup = highlightControlID,
            IC_ControlID = 1,
            INP_Integer = true,
        })

        local specificStrings = self:AddInput("Specific Strings", "SpecificStrings" .. id, {
            LINKID_DataType     = "Text",
            INPID_InputControl  = "TextEditControl",
            TEC_Lines           = 8,
            INP_DoNotifyChanged = true,
        })

        local useMainFont = self:AddInput("Use main font settings", "UseMainFont" .. id, {
            LINKID_DataType = "Number",
            INPID_InputControl = "CheckboxControl",
            INP_Integer = true,
            INP_Default = 1,
            INP_MinAllowed = 0,
            INP_MaxAllowed = 1,
            INP_DoNotifyChanged = true,
        })

        highlightControlID = highlightControlID + 1
        local font = self:AddInput("Font", "Font" .. id, {
            LINKID_DataType     = "Text",
            INPID_InputControl  = "FontFileControl",
            IC_ControlGroup     = highlightControlID,
            IC_ControlID        = 0,
            INP_Level           = 1,
            INP_DoNotifyChanged = true,
        })

        local fontStyle = self:AddInput("Font Style", "FontStyle" .. id, {
            LINKID_DataType     = "Text",
            INPID_InputControl  = "FontFileControl",
            IC_ControlGroup     = highlightControlID,
            IC_ControlID        = 1,
            INP_Level           = 1,
            INP_DoNotifyChanged = true,
        })

        local size = self:AddInput("Size", "Size" .. id, {
            LINKID_DataType    = "Number",
            INPID_InputControl = "SliderControl",
            INP_MinScale       = 0.0,
            INP_MaxScale       = 0.5,
            INP_Default        = 0.08,
        })

        local spaceSize = self:AddInput("Space Size", "SpaceSize" .. id, {
            LINKID_DataType    = "Number",
            INPID_InputControl = "SliderControl",
            INP_MinScale       = 0.0,
            INP_MaxScale       = 10.0,
            INP_Default        = 1.0,
            IC_Visible         = true,
        })

        local tracking = self:AddInput("Tracking", "Tracking" .. id, {
            LINKID_DataType    = "Number",
            INPID_InputControl = "SliderControl",
            INP_MinScale       = -1.0,
            INP_MaxScale       = 2.0,
            INP_MinAllowed     = -4.0,
            INP_MaxAllowed     = 5.0,
            INP_Default        = 1.0,
        })

        highlightControlID = highlightControlID + 1
        local mainColorR = self:AddInput("Red", "MainColorRed" .. id, {
            LINKID_DataType    = "Number",
            INPID_InputControl = "ColorControl",
            INP_MinScale       = 0.0,
            INP_MaxScale       = 1.0,
            INP_Default        = 1.0,
            ICS_Name           = "Color",
            CLRC_ShowWheel     = false,
            IC_ControlGroup    = highlightControlID,
            IC_ControlID       = 0, -- Red ID
        })
        local mainColorG = self:AddInput("Green", "MainColorGreen" .. id, {
            LINKID_DataType    = "Number",
            INPID_InputControl = "ColorControl",
            INP_MinScale       = 0.0,
            INP_MaxScale       = 1.0,
            INP_Default        = 0.0,
            IC_ControlGroup    = highlightControlID,
            IC_ControlID       = 1, -- Green ID
        })
        local mainColorB = self:AddInput("Blue", "MainColorBlue" .. id, {
            LINKID_DataType    = "Number",
            INPID_InputControl = "ColorControl",
            INP_MinScale       = 0.0,
            INP_MaxScale       = 1.0,
            INP_Default        = 1.0,
            IC_ControlGroup    = highlightControlID,
            IC_ControlID       = 2, -- Blue ID
        })
        local mainColorA = self:AddInput("Alpha", "MainColorAlpha" .. id, {
            LINKID_DataType    = "Number",
            INPID_InputControl = "ColorControl",
            INP_MinScale       = 0.0,
            INP_MaxScale       = 1.0,
            INP_Default        = 1.0,
            IC_ControlGroup    = highlightControlID,
            IC_ControlID       = 3, -- Alpha ID
        })

        local useMainOutline = self:AddInput("Use main outline settings", "UseMainOutline" .. id, {
            LINKID_DataType     = "Number",
            INPID_InputControl  = "CheckboxControl",
            INP_Integer         = true,
            INP_Default         = 1,
            ICD_Width           = 1,
            INP_MinAllowed      = 0,
            INP_MaxAllowed      = 1,
            INP_DoNotifyChanged = true,
        })

        local colorTarget = self:AddInput("Target", "ColorTarget" .. id, {
            LINKID_DataType    = "Number",
            INPID_InputControl = "MultiButtonControl",
            INP_Default        = 0,
            { MBTNC_AddButton = "Inner", MBTNCD_ButtonWidth = 1 / 2, },
            { MBTNC_AddButton = "Outer", MBTNCD_ButtonWidth = 1 / 2, },
            INP_Integer = true,
            INP_DoNotifyChanged = true,
        })

        local outlineType = self:AddInput("Type", "OutlineColorType" .. id, {
            LINKID_DataType    = "Number",
            INPID_InputControl = "MultiButtonControl",
            INP_Default        = 0,
            { MBTNC_AddButton = "Mono",    MBTNCD_ButtonWidth = 1 / 3, },
            { MBTNC_AddButton = "Comp",    MBTNCD_ButtonWidth = 1 / 3, },
            { MBTNC_AddButton = "Custom ", MBTNCD_ButtonWidth = 1 / 3, },
            INP_Integer = true,
            INP_DoNotifyChanged = true,
        })

        local outlineNum = self:AddInput("Num", "OutlineNum" .. id, {
            LINKID_DataType    = "Number",
            INPID_InputControl = "SliderControl",
            INP_MinScale       = 0,
            INP_MaxScale       = 2,
            INP_Default        = 1,
            INP_MinAllowed     = 0,
            INP_MaxAllowed     = 2,
            INP_Integer        = true,
        })

        local outlineThickness = self:AddInput("Thickness", "OutlineThickness" .. id, {
            LINKID_DataType    = "Number",
            INPID_InputControl = "SliderControl",
            INP_MinScale       = 0.0,
            INP_MaxScale       = 0.1,
            INP_Default        = 0.08,
        })

        self:BeginControlNest("Color 1", "OutlineColor1Label" .. id, true)
        highlightControlID = highlightControlID + 1
        local outlineColor1R = self:AddInput("Red", "OutlineColor1Red" .. id, {
            LINKID_DataType    = "Number",
            INPID_InputControl = "ColorControl",
            INP_MinScale       = 0.0,
            INP_MaxScale       = 1.0,
            INP_Default        = 1.0,
            ICS_Name           = "Color",
            CLRC_ShowWheel     = false,
            IC_ControlGroup    = highlightControlID,
            IC_ControlID       = 0, -- Red ID
        })
        local outlineColor1G = self:AddInput("Green", "OutlineColor1Green" .. id, {
            LINKID_DataType    = "Number",
            INPID_InputControl = "ColorControl",
            INP_MinScale       = 0.0,
            INP_MaxScale       = 1.0,
            INP_Default        = 1.0,
            IC_ControlGroup    = highlightControlID,
            IC_ControlID       = 1, -- Green ID
        })
        local outlineColor1B = self:AddInput("Blue", "OutlineColor1Blue" .. id, {
            LINKID_DataType    = "Number",
            INPID_InputControl = "ColorControl",
            INP_MinScale       = 0.0,
            INP_MaxScale       = 1.0,
            INP_Default        = 1.0,
            IC_ControlGroup    = highlightControlID,
            IC_ControlID       = 2, -- Blue ID
        })
        local outlineColor1A = self:AddInput("Alpha", "OutlineColor1Alpha" .. id, {
            LINKID_DataType    = "Number",
            INPID_InputControl = "ColorControl",
            INP_MinScale       = 0.0,
            INP_MaxScale       = 1.0,
            INP_Default        = 1.0,
            IC_ControlGroup    = highlightControlID,
            IC_ControlID       = 3, -- Alpha ID
        })
        self:EndControlNest()

        self:BeginControlNest("Color 2", "OutlineColor1Labe2" .. id, true)
        highlightControlID = highlightControlID + 1
        local outlineColor2R = self:AddInput("Red", "OutlineColor2Red" .. id, {
            LINKID_DataType    = "Number",
            INPID_InputControl = "ColorControl",
            INP_MinScale       = 0.0,
            INP_MaxScale       = 1.0,
            INP_Default        = 0.0,
            ICS_Name           = "Color",
            CLRC_ShowWheel     = false,
            IC_ControlGroup    = highlightControlID,
            IC_ControlID       = 0, -- Red ID
        })
        local outlineColor2G = self:AddInput("Green", "OutlineColor2Green" .. id, {
            LINKID_DataType    = "Number",
            INPID_InputControl = "ColorControl",
            INP_MinScale       = 0.0,
            INP_MaxScale       = 1.0,
            INP_Default        = 0.0,
            IC_ControlGroup    = highlightControlID,
            IC_ControlID       = 1, -- Green ID
        })
        local outlineColor2B = self:AddInput("Blue", "OutlineColor2Blue" .. id, {
            LINKID_DataType    = "Number",
            INPID_InputControl = "ColorControl",
            INP_MinScale       = 0.0,
            INP_MaxScale       = 1.0,
            INP_Default        = 0.0,
            IC_ControlGroup    = highlightControlID,
            IC_ControlID       = 2, -- Blue ID
        })
        local outlineColor2A = self:AddInput("Alpha", "OutlineColor2Alpha" .. id, {
            LINKID_DataType    = "Number",
            INPID_InputControl = "ColorControl",
            INP_MinScale       = 0.0,
            INP_MaxScale       = 1.0,
            INP_Default        = 1.0,
            IC_ControlGroup    = highlightControlID,
            IC_ControlID       = 3, -- Alpha ID
        })
        self:EndControlNest()

        self:EndControlNest()

        local highlightControl = TypeInHighlight.New(
            {
                RangeType = rangeType,
                Low = rangeLow,
                High = rangeHigh,
                SpecificStrings = specificStrings,
            },
            {
                useMainFont = useMainFont,
                Name = font,
                Style = fontStyle,
                Size = size,
                SpaceSize = spaceSize,
                Tracking = tracking,
            },
            {
                ColorTarget = colorTarget,
                R = mainColorR,
                G = mainColorG,
                B = mainColorB,
                A = mainColorA,
            },
            {
                UseMainOutline = useMainOutline,
                Type = outlineType,
                Num = outlineNum,
                Thickness = outlineThickness,
                Color1 = {
                    R = outlineColor1R,
                    G = outlineColor1G,
                    B = outlineColor1B,
                    A = outlineColor1A,
                },
                Color2 = {
                    R = outlineColor2R,
                    G = outlineColor2G,
                    B = outlineColor2B,
                    A = outlineColor2A,
                },
            }
        )
        table.insert(InHighlight, highlightControl)
    end

    return highlightControlID
end

function Create()
    self:AddControlPage("Controls")
    local groupId = 0;

    self:BeginControlNest("Text", "TextLabel", true);

    InText = self:AddInput("Text", "Text", {
        LINKID_DataType     = "Text",
        INPID_InputControl  = "TextEditControl",
        TEC_Lines           = 5,
        INP_DoNotifyChanged = true,
    })

    -- Font group
    groupId = groupId + 1;

    InFont = self:AddInput("Font", "Font", {
        LINKID_DataType     = "Text",
        INPID_InputControl  = "FontFileControl",
        IC_ControlGroup     = groupId,
        IC_ControlID        = 0,
        INP_Level           = 1,
        INP_DoNotifyChanged = true,
    })

    InFontStyle = self:AddInput("Font Style", "FontStyle", {
        LINKID_DataType     = "Text",
        INPID_InputControl  = "FontFileControl",
        IC_ControlGroup     = groupId,
        IC_ControlID        = 1,
        INP_Level           = 1,
        INP_DoNotifyChanged = true,
    })

    InSize = self:AddInput("Size", "Size", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "SliderControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 0.5,
        INP_Default        = 0.08,
    })

    InSpaceSize = self:AddInput("Space Size", "SpaceSize", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "SliderControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 10.0,
        INP_Default        = 1.0,
        IC_Visible         = true,
    })

    InTracking = self:AddInput("Tracking", "Tracking", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "SliderControl",
        INP_MinScale       = -1.0,
        INP_MaxScale       = 2.0,
        INP_MinAllowed     = -4.0,
        INP_MaxAllowed     = 5.0,
        INP_Default        = 1.0,
    })

    InLineSpacing = self:AddInput("Line Spacing", "LineSpacing", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "SliderControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 5.0,
        INP_MinAllowed     = 0.0,
        INP_MaxAllowed     = 20.0,
        INP_Default        = 1.0,
    })

    self:BeginControlNest("Main Color", "MainColorLabel", true);

    InColorTarget = self:AddInput("Target", "ColorTarget", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "MultiButtonControl",
        INP_Default        = 0,
        { MBTNC_AddButton = "Inner", MBTNCD_ButtonWidth = 1 / 2, },
        { MBTNC_AddButton = "Outer", MBTNCD_ButtonWidth = 1 / 2, },
        INP_Integer = true,
        INP_DoNotifyChanged = true,
    })

    groupId = groupId + 1;
    InR = self:AddInput("Red", "Red", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupId,
        IC_ControlID       = 0, -- Red ID
    })

    InG = self:AddInput("Green", "Green", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        IC_ControlGroup    = groupId,
        IC_ControlID       = 1, -- Green ID
    })

    InB = self:AddInput("Blue", "Blue", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        IC_ControlGroup    = groupId,
        IC_ControlID       = 2, -- Blue ID
    })

    InA = self:AddInput("Alpha", "Alpha", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        IC_ControlGroup    = groupId,
        IC_ControlID       = 3, -- Alpha ID
    })

    self:EndControlNest()

    self:BeginControlNest("Outline", "OutlineLabel", true);

    InOutlineColorType = self:AddInput("Type", "OutlineColorType", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "MultiButtonControl",
        INP_Default        = 0,
        { MBTNC_AddButton = "Mono",    MBTNCD_ButtonWidth = 1 / 3, },
        { MBTNC_AddButton = "Comp",    MBTNCD_ButtonWidth = 1 / 3, },
        { MBTNC_AddButton = "Custom ", MBTNCD_ButtonWidth = 1 / 3, },
        INP_Integer = true,
        INP_DoNotifyChanged = true,
    })

    InOutlineNum = self:AddInput("Num", "OutlineNum", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "SliderControl",
        INP_MinScale       = 0,
        INP_MaxScale       = 2,
        INP_Default        = 1,
        INP_MinAllowed     = 0,
        INP_MaxAllowed     = 2,
        INP_Integer        = true,
    })

    InOutlineThickness = self:AddInput("Tickness", "OutlineTickness", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "SliderControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 0.1,
        INP_Default        = 0.08,
    })


    self:BeginControlNest("Color 1", "OutlineColor1", true);
    groupId = groupId + 1;
    InR2 = self:AddInput("Red", "Red2", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupId,
        IC_ControlID       = 0, -- Red ID
    })

    InG2 = self:AddInput("Green", "Green2", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        IC_ControlGroup    = groupId,
        IC_ControlID       = 1, -- Green ID
    })

    InB2 = self:AddInput("Blue", "Blue2", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        IC_ControlGroup    = groupId,
        IC_ControlID       = 2, -- Blue ID
    })

    InA2 = self:AddInput("Alpha", "Alpha2", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        IC_ControlGroup    = groupId,
        IC_ControlID       = 3, -- Alpha ID
    })
    self:EndControlNest()

    self:BeginControlNest("Color 2", "OutlineColor2", true);

    groupId = groupId + 1;

    InR3 = self:AddInput("Red", "Red3", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 0.0,
        ICS_Name           = "Color",
        CLRC_ShowWheel     = false,
        IC_ControlGroup    = groupId,
        IC_ControlID       = 0, -- Red ID
    })

    InG3 = self:AddInput("Green", "Green3", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 0.0,
        IC_ControlGroup    = groupId,
        IC_ControlID       = 1, -- Green ID
    })

    InB3 = self:AddInput("Blue", "Blue3", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 0.0,
        IC_ControlGroup    = groupId,
        IC_ControlID       = 2, -- Blue ID
    })

    InA3 = self:AddInput("Alpha", "Alpha3", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "ColorControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 1.0,
        INP_Default        = 1.0,
        IC_ControlGroup    = groupId,
        IC_ControlID       = 3, -- Alpha ID
    })
    self:EndControlNest()

    self:EndControlNest()


    self:EndControlNest()

    ------------- Position -------------
    self:AddControlPage("Position")
    self:BeginControlNest("Position", "PositionLabel", true);

    InOffset = self:AddInput("Offset", "Offset", {
        LINKID_DataType      = "Point",
        INPID_InputControl   = "OffsetControl",
        INPID_PreviewControl = "CrosshairControl",
    })

    InJustify = self:AddInput("Justification", "Justification", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "MultiButtonControl",
        INP_Default        = 1,
        { MBTNC_AddButton = "Left",   MBTNCD_ButtonWidth = 1 / 3, },
        { MBTNC_AddButton = "Center", MBTNCD_ButtonWidth = 1 / 3, },
        { MBTNC_AddButton = "Right",  MBTNCD_ButtonWidth = 1 / 3, },
        INP_Integer = true,
    })

    InAlign = self:AddInput("Alignment", "Alignment", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "MultiButtonControl",
        INP_Default        = 1,
        { MBTNC_AddButton = "Top",    MBTNCD_ButtonWidth = 1 / 3, },
        { MBTNC_AddButton = "Center", MBTNCD_ButtonWidth = 1 / 3, },
        { MBTNC_AddButton = "Bottom", MBTNCD_ButtonWidth = 1 / 3, },
        INP_Integer = true,
    })
    self:EndControlNest()

    self:BeginControlNest("Fitting", "FittingLabel", true);
    groupId = groupId + 1;
    InFittingPaddingWidth = self:AddInput("Width", "FittingPaddingWidth", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INPID_PreviewControl = "RectangleControl",
        PC_ControlGroup = groupId,
        PC_ControlID = 0,
        INP_MaxScale = 1,
        INP_Default = 0.92,
    })
    InFittingPaddingHeight = self:AddInput("Height", "FittingPaddingHeight", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INPID_PreviewControl = "RectangleControl",
        PC_ControlGroup = groupId,
        PC_ControlID = 1,
        INP_MaxScale = 1,
        INP_Default = 0.85,
    })
    InFittingTop = self:AddInput("Top", "FittingTop", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "MultiButtonControl",
        MBTNC_Type         = "Normal",
        MBTNC_ShowName     = false,
        INP_Default        = 0,
        { MBTNC_AddButton = "↖", MBTNCD_ButtonWidth = 1 / 3, },
        { MBTNC_AddButton = "↑", MBTNCD_ButtonWidth = 1 / 3, },
        { MBTNC_AddButton = "↗", MBTNCD_ButtonWidth = 1 / 3, },
        INP_Integer = true,
        INP_External = false,
        INP_DoNotifyChanged = true,
    })
    InFittingMiddle = self:AddInput("Middle", "FittingMiddle", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "MultiButtonControl",
        MBTNC_Type         = "Normal",
        MBTNC_ShowName     = false,
        INP_Default        = 0,
        { MBTNC_AddButton = "←", MBTNCD_ButtonWidth = 1 / 3, },
        { MBTNC_AddButton = "+", MBTNCD_ButtonWidth = 1 / 3, },
        { MBTNC_AddButton = "→", MBTNCD_ButtonWidth = 1 / 3, },
        INP_Integer = true,
        INP_External = false,
        INP_DoNotifyChanged = true,
    })
    InFittingBottom = self:AddInput("Bottom", "FittingBottom", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "MultiButtonControl",
        MBTNC_Type         = "Normal",
        MBTNC_ShowName     = false,
        INP_Default        = 0,
        { MBTNC_AddButton = "↙", MBTNCD_ButtonWidth = 1 / 3, },
        { MBTNC_AddButton = "↓", MBTNCD_ButtonWidth = 1 / 3, },
        { MBTNC_AddButton = "↘", MBTNCD_ButtonWidth = 1 / 3, },
        INP_Integer = true,
        INP_External = false,
        INP_DoNotifyChanged = true,
    })
    self:EndControlNest()

    ------------- Highlight -------------
    InHighlightNum = 3
    groupId = createHighlightControl(InHighlightNum, groupId)

    ------------- Emoji -------------
    self:AddControlPage("Emoji")

    self:BeginControlNest("Emoji", "EmojiLabel", true);

    InEmojiFontEnabled = self:AddInput("Use alternative fonts for emojis", "EnableEmojiFontEnabled", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Integer = true,
        INP_Default = 1.0,
        ICD_Width = 1,
        INP_DoNotifyChanged = true,
    })

    groupId = groupId + 1;
    InEmojiFont = self:AddInput("Font", "EmojiFont", {
        LINKID_DataType     = "Text",
        INPID_InputControl  = "FontFileControl",
        IC_ControlGroup     = groupId,
        IC_ControlID        = 0,
        INP_Level           = 1,
        INP_DoNotifyChanged = true,
        IC_Visible          = true,
    })

    InEmojiFontStyle = self:AddInput("Font Style", "EmojiFontStyle", {
        LINKID_DataType     = "Text",
        INPID_InputControl  = "FontFileControl",
        IC_ControlGroup     = groupId,
        IC_ControlID        = 1,
        INP_Level           = 1,
        INP_DoNotifyChanged = true,
        IC_Visible          = true,
    })

    InEmojiSize = self:AddInput("Size", "EmojiSize", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "SliderControl",
        INP_MinScale       = 0.0,
        INP_MaxScale       = 0.5,
        INP_Default        = 0.08,
        IC_Visible         = true,
    })

    InEmojiTracking = self:AddInput("Tracking", "EmojiTracking", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "SliderControl",
        INP_MinScale       = -1.0,
        INP_MaxScale       = 2.0,
        INP_MinAllowed     = -4.0,
        INP_MaxAllowed     = 5.0,
        INP_Default        = 1.0,
        IC_Visible         = true,
    })

    InCustomEmojiOutline = self:AddInput("Match outline count with normal characters", "CustomEmojiOutline", {
        LINKID_DataType     = "Number",
        INPID_InputControl  = "CheckboxControl",
        INP_Integer         = true,
        INP_Default         = 1,
        ICD_Width           = 1,
        INP_MinAllowed      = 0,
        INP_MaxAllowed      = 1,
        INP_DoNotifyChanged = true,
    })

    InEmojiOutlineNum = self:AddInput("Outline Num", "EmojiOutlineNum", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "SliderControl",
        INP_MinScale       = 0,
        INP_MaxScale       = 2,
        INP_Default        = 0,
        INP_MinAllowed     = 0,
        INP_MaxAllowed     = 2,
        INP_Integer        = true,
    })

    self:EndControlNest()


    ------------- Debug -------------
    self:AddControlPage("Debug")

    self:BeginControlNest("Debug", "DebugLabel", true);

    InDebug = self:AddInput("Enable", "DebugEnable", {
        LINKID_DataType    = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Integer        = true,
        INP_Default        = 0,
        ICD_Width          = 1,
        INP_MinAllowed     = 0,
        INP_MaxAllowed     = 1,
    })

    self:EndControlNest()


    InImage = self:AddInput("Input", "Input", {
        LINKID_DataType = "Image",
        LINK_Main       = 1,
    })

    OutImage = self:AddOutput("Output", "Output", {
        LINKID_DataType = "Image",
        LINK_Main       = 1,
    })
end

------------------------------------------------------------
local bit = require("bit")

local UnicodeText = {
    New = function()
        return {
            Text = "",
            Unicode = {},

            ToUniCode = function(this)
                local utf16bytes = {}
                local utf32bytes = {}
                local line = 1
                local source = this.Text

                if source and (0 < #source) then
                    utf16bytes[line] = {}
                    local i = 1
                    while i <= #source do
                        local c = source:byte(i)
                        if c == 0x0A then
                            line = line + 1
                            utf16bytes[line] = {}
                            i = i + 1
                        elseif c < 0x80 then
                            table.insert(utf16bytes[line], 0)
                            table.insert(utf16bytes[line], c)
                            i = i + 1
                        elseif c < 0xE0 then
                            local c2 = source:byte(i + 1)
                            local u = bit.bor(bit.lshift(bit.band(c, 0x1F), 6), bit.band(c2, 0x3F))
                            table.insert(utf16bytes[line], bit.rshift(u, 8))
                            table.insert(utf16bytes[line], bit.band(u, 0xFF))
                            i = i + 2
                        elseif c < 0xF0 then
                            local c2 = source:byte(i + 1)
                            local c3 = source:byte(i + 2)
                            local u = bit.bor(bit.lshift(bit.band(c, 0x0F), 12), bit.lshift(bit.band(c2, 0x3F), 6),
                                bit.band(c3, 0x3F))
                            table.insert(utf16bytes[line], bit.rshift(u, 8))
                            table.insert(utf16bytes[line], bit.band(u, 0xFF))
                            i = i + 3
                        else
                            local c2 = source:byte(i + 1)
                            local c3 = source:byte(i + 2)
                            local c4 = source:byte(i + 3)
                            local u = bit.bor(bit.lshift(bit.band(c, 0x07), 18), bit.lshift(bit.band(c2, 0x3F), 12),
                                bit.lshift(bit.band(c3, 0x3F), 6), bit.band(c4, 0x3F))
                            u = u - 0x10000
                            local high = bit.bor(0xD800, bit.rshift(u, 10))
                            local low = bit.bor(0xDC00, bit.band(u, 0x3FF))
                            table.insert(utf16bytes[line], bit.rshift(high, 8))
                            table.insert(utf16bytes[line], bit.band(high, 0xFF))
                            table.insert(utf16bytes[line], bit.rshift(low, 8))
                            table.insert(utf16bytes[line], bit.band(low, 0xFF))
                            i = i + 4
                        end
                    end

                    for line = 1, #utf16bytes do
                        utf32bytes[line] = {}
                        local i = 1
                        while i <= #utf16bytes[line] do
                            local b1 = utf16bytes[line][i]
                            local b2 = utf16bytes[line][i + 1]
                            local code_unit = bit.bor(bit.lshift(b1, 8), b2)
                            if code_unit >= 0xD800 and code_unit <= 0xDBFF then
                                -- High surrogate
                                local b3 = utf16bytes[line][i + 2]
                                local b4 = utf16bytes[line][i + 3]
                                local low_surrogate = bit.bor(bit.lshift(b3, 8), b4)
                                local code_point = bit.bor(bit.lshift(bit.band(code_unit, 0x3FF), 10),
                                        bit.band(low_surrogate, 0x3FF)) +
                                    0x10000
                                table.insert(utf32bytes[line], code_point)
                                i = i + 4
                            else
                                -- Non-surrogate
                                if code_unit ~= 0xFE0F then
                                    table.insert(utf32bytes[line], code_unit)
                                end
                                i = i + 2
                            end
                        end
                    end
                end

                return utf32bytes
            end,

            SetText = function(this, text)
                this.Text = text
                this.Unicode = this.ToUniCode(this)
            end,

            GetLineNum = function(this)
                return #this.Unicode
            end,

            GetLine = function(this, line)
                if line <= this.GetLineNum(this) then
                    return this.Unicode[line]
                else
                    print(
                        string.format(
                            "Requested line number is out of range: request=%d, line=%d",
                            line,
                            this.GetLineNum(this)
                        )
                    )
                    return {}
                end
            end
        }
    end
}

local TextPosition = {
    New = function(x, y, justify, align, tracking, lineSpacing, emojiTracking)
        return {
            X = x,
            Y = y,
            Justify = justify,
            Align = align,
            Tracking = tracking,
            LineSpacing = lineSpacing,
            EmojiTracking = emojiTracking
        }
    end
}

local TextFont = {
    New = function(name, style)
        return {
            Name = name,
            Style = style,
        }
    end
}

local Highlight = {
    New = function(range, font, textColor, outlineNum, outlineThickness)
        return {
            Range = {
                Low = range.Low,
                High = range.High,
            },
            Font = {
                Name = font.Name,
                Style = font.Style,
                Size = font.Size,
                SpaceSize = font.SpaceSize,
                Tracking = font.Tracking,
            },
            TextColor = textColor,
            OutlineNum = outlineNum,
            OutlineThickness = outlineThickness,
        }
    end
}

local function rgbToHsv(r, g, b)
    local max = math.max(r, g, b)
    local min = math.min(r, g, b)
    local h, s, v = 0, 0, max

    local d = max - min
    s = max == 0 and 0 or d / max

    if max == min then
        h = 0 -- achromatic
    else
        if max == r then
            h = (g - b) / d + (g < b and 6 or 0)
        elseif max == g then
            h = (b - r) / d + 2
        elseif max == b then
            h = (r - g) / d + 4
        end
        h = h / 6
    end

    return h, s, v
end

local function hsvToRgb(h, s, v)
    local r, g, b

    local i = math.floor(h * 6)
    local f = h * 6 - i
    local p = v * (1 - s)
    local q = v * (1 - f * s)
    local t = v * (1 - (1 - f) * s)

    i = i % 6

    if i == 0 then
        r, g, b = v, t, p
    elseif i == 1 then
        r, g, b = q, v, p
    elseif i == 2 then
        r, g, b = p, v, t
    elseif i == 3 then
        r, g, b = p, q, v
    elseif i == 4 then
        r, g, b = t, p, v
    elseif i == 5 then
        r, g, b = v, p, q
    end

    return r, g, b
end

local function getLuminance(r, g, b)
    local function channelLuminance(channel)
        if channel <= 0.03928 then
            return channel / 12.92
        else
            return ((channel + 0.055) / 1.055) ^ 2.4
        end
    end

    return 0.2126 * channelLuminance(r) + 0.7152 * channelLuminance(g) + 0.0722 * channelLuminance(b)
end

local function calculateContrastRatio(color1, color2)
    local lum1 = getLuminance(color1.R, color1.G, color1.B)
    local lum2 = getLuminance(color2.R, color2.G, color2.B)

    if lum1 > lum2 then
        return (lum1 + 0.05) / (lum2 + 0.05)
    else
        return (lum2 + 0.05) / (lum1 + 0.05)
    end
end

local function adjustLuminanceForContrast(color)
    local step = 0.5
    local maxAttempts = (1 / step)

    local testColor = { R = 0, G = 0, B = 0 }
    local bestH, bestS, bestV = 0, 0, 1
    local bestContrast = 0

    for i = 0, maxAttempts do
        local newV = 1.0 - (step * i)
        if newV >= 0 and newV <= 1 then
            testColor.R, testColor.G, testColor.B = hsvToRgb(bestH, bestS, newV)
            local contrast = calculateContrastRatio(color, testColor)
            if contrast > bestContrast then
                bestContrast = contrast
                bestV = newV
            end
        end
    end
    local bestR, bestG, bestB = hsvToRgb(bestH, bestS, bestV)

    return Pixel { R = bestR, G = bestG, B = bestB, A = color.A } -- Return the color with the highest contrast found
end

local function getComplementaryColor(color)
    local h, s, v = rgbToHsv(color.R, color.G, color.B)
    h = h + 0.5
    if 1 < h then
        h = h - 1
    end
    local r, g, b = hsvToRgb(h, s, v)

    return Pixel { R = r, G = g, B = b, A = color.A } -- Return the color with the highest contrast found
end

local function getClosestContrastingColor(color)
    local targetHue, _, _ = rgbToHsv(color.R, color.G, color.B)
    local bestColor = nil
    local bestContrast = 0

    for i = 0, 360, 1 do
        local testColor = { R = 0, G = 0, B = 0 }
        testColor.R, testColor.G, testColor.B = hsvToRgb(i / 360, 1, 1)
        local contrast = calculateContrastRatio(color, testColor)
        if contrast >= 7 and (bestColor == nil or math.abs(i / 360 - targetHue) < math.abs(bestColor.Hue - targetHue)) then
            bestColor = testColor
            bestColor.Hue = i / 360
            bestContrast = contrast
        end
    end

    return bestColor
end

local TextColor = {
    New = function(baseColor, customColor1, customColor2, target, type)
        return {
            BaseColor = Pixel { R = baseColor.R, G = baseColor.G, B = baseColor.B, A = baseColor.A },
            CustomColor1 = Pixel { R = customColor1.R, G = customColor1.G, B = customColor1.B, A = customColor1.A },
            CustomColor2 = Pixel { R = customColor2.R, G = customColor2.G, B = customColor2.B, A = customColor2.A },
            Target = target,
            Type = type,

            _innerColor = nil,
            _outlineColor1 = nil,
            _outlineColor2 = nil,

            _updateColor = function(this)
                local c1, c2
                if this.Type == 0 then --Mono
                    c1 = adjustLuminanceForContrast(this.BaseColor)
                    c2 = adjustLuminanceForContrast(c1)
                elseif this.Type == 1 then --Comp
                    c1 = getComplementaryColor(this.BaseColor)
                    c2 = getComplementaryColor(c1)
                elseif this.Type == 2 then -- Custom
                    c1 = this.CustomColor1
                    c2 = this.CustomColor2
                end
                if this._innerColor == nil then
                    if this.Target == 0 then -- Inner
                        this._innerColor = this.BaseColor
                        this._outlineColor1 = c1
                        this._outlineColor2 = c2
                    elseif this.Target == 1 then -- Outer
                        this._outlineColor1 = this.BaseColor
                        this._innerColor = c1
                        this._outlineColor2 = c1
                    end
                end
            end,

            GetInnerColor = function(this)
                this._updateColor(this)
                return Pixel { R = this._innerColor.R, G = this._innerColor.G, B = this._innerColor.B, A = this._innerColor.A }
            end,

            GetOutlineColor1 = function(this)
                this._updateColor(this)
                return Pixel { R = this._outlineColor1.R, G = this._outlineColor1.G, B = this._outlineColor1.B, A = this._outlineColor1.A }
            end,

            GetOutlineColor2 = function(this)
                this._updateColor(this)
                return Pixel { R = this._outlineColor2.R, G = this._outlineColor2.G, B = this._outlineColor2.B, A = this._outlineColor2.A }
            end,
        }
    end
}

local function isEmoji(unicode)
    if 0x231A <= unicode and unicode <= 0x2B55 then
        return true
    elseif 0x1F004 <= unicode and unicode <= 0x1FAF8 then
        return true
    elseif 0xFE0F == unicode then
        return true
    end

    return false
end

local function isHighlight(characterIndex, position)
    for i = 1, #position do
        if position[i].Range.Low <= characterIndex and characterIndex <= position[i].Range.High then
            return i
        end
    end

    return -1
end

local function isSpace(unicode)
    if unicode == 0x20 then
        return true
    end

    return false
end

local function isJapaneseSpace(unicode)
    if unicode == 0x3000 then
        return true
    end

    return false
end

local DrawTextInfo = {
    New = function(range, fontName, fontStyle, baseScale, scale, spaceScale, thickness, outlineNum, tracking, color, pos,
                   offset)
        local fontSizeToResolveSize = function(fontSize)
            return fontSize * 10 * scale
        end

        local tfm = TextStyleFontMetrics(TextStyleFont(fontName, fontStyle))
        local baseHeight = (tfm.TextAscent + tfm.TextDescent + tfm.TextExternalLeading) * 10 * baseScale
        local height = fontSizeToResolveSize(tfm.TextAscent + tfm.TextDescent + tfm.TextExternalLeading)

        local mat = Matrix4()
        mat:Scale(1.0 / tfm.Scale, 1.0 / tfm.Scale, 1.0)
        mat:Scale(scale, scale, 1)
        mat:Move(pos.X, pos.Y, 0)
        mat:Move(0, -tfm.TextAscent * baseScale * 10, 0)
        mat:Move(offset.X, offset.Y, 0)

        return {
            Range = range,
            Font = fontName,
            FontStyle = fontStyle,
            Tfm = tfm,
            BaseScale = baseScale,
            Scale = scale,
            SpaceScale = spaceScale,
            Thickness = thickness,
            OutlineNum = outlineNum,
            Tracking = tracking,
            BaseHeight = baseHeight,
            Height = height,
            Ascent = tfm.TextAscent,
            Descent = fontSizeToResolveSize(tfm.TextDescent),
            ExternalLeading = fontSizeToResolveSize(tfm.TextExternalLeading),
            Color = color,
            Mat = mat,

            IsWithinRange = function(this, characterIndex)
                return this.Range.Low <= characterIndex and characterIndex <= this.Range.High
            end,
        }
    end
}

local function getLineDrawWidth(characterIndex,
                                unicodeArray,
                                mainDrawInfo,
                                emojiDrawInfo,
                                highlightDrawInfo)
    local lineWidth = 0

    for i = 1, #unicodeArray do
        -- add the kerning between this character and the previous one
        local highlightIndex = isHighlight(characterIndex + (i - 1), highlightDrawInfo)
        local currentDrawInfo
        if isEmoji(unicodeArray[i]) then
            currentDrawInfo = emojiDrawInfo
        elseif 0 <= highlightIndex then
            currentDrawInfo = highlightDrawInfo[highlightIndex]
        else
            currentDrawInfo = mainDrawInfo
        end

        -- add the width of the character
        local scale = 1
        if isSpace(unicodeArray[i]) then
            scale = currentDrawInfo.Scale * currentDrawInfo.SpaceScale
        end
        if isJapaneseSpace(unicodeArray[i]) then
            scale = currentDrawInfo.Scale * currentDrawInfo.SpaceScale * 2
        end
        local characterWidth = (currentDrawInfo.Tfm:CharacterWidth(unicodeArray[i]) * 10 * currentDrawInfo.Scale)
        characterWidth = characterWidth +
            (((currentDrawInfo.Thickness * currentDrawInfo.OutlineNum)) * currentDrawInfo.Scale)
        lineWidth = lineWidth + characterWidth

        -- Tracking
        if i < #unicodeArray then
            local offset = 0
            for n = 0, 1 do
                if isEmoji(unicodeArray[i + n]) then
                    offset = offset + (((emojiDrawInfo.Tracking - 1) * mainDrawInfo.Scale) / 2)
                elseif 0 <= isHighlight(characterIndex + (i - 1) + n, highlightDrawInfo) then
                    local index = isHighlight(characterIndex + (i - 1) + n, highlightDrawInfo)
                    offset = offset + (((highlightDrawInfo[index].Tracking - 1) * mainDrawInfo.Scale) / 2)
                else
                    offset = offset + (((mainDrawInfo.Tracking - 1) * mainDrawInfo.Scale) / 2)
                end
            end
            lineWidth = lineWidth + offset
        end
    end


    return lineWidth
end

local function getSpecRangeArray(specifigStrings, unicodeText)
    local specRangeArray = {}
    local charcterIndex = 1
    for specN = 1, specifigStrings:GetLineNum() do
        local specLine = specifigStrings:GetLine(specN)
        if (#specLine ~= 0) then
            for j = 1, unicodeText:GetLineNum() do
                local line = unicodeText:GetLine(j)
                for k = 1, #line do
                    if #specLine <= (#line - (k - 1)) then
                        local matchCount = 0
                        for specOffset = 1, #specLine do
                            if specLine[specOffset] ~= line[k + specOffset - 1] then
                                break
                            end
                            matchCount = matchCount + 1
                        end
                        if matchCount == #specLine then
                            table.insert(specRangeArray,
                                { Low = charcterIndex + (k - 1), High = charcterIndex + (k - 1) + #specLine - 1 })
                        end
                    end
                end
                charcterIndex = charcterIndex + #line
            end
            charcterIndex = 1
        end
    end

    return specRangeArray
end

local function debugRectangle(img, baseMat, offsetX, offsetY, width, height, color, debug)
    if debug == 1 then
        local baseMatTable = baseMat:GetTable()
        local baseX        = baseMatTable[13]
        local baseY        = baseMatTable[14]
        local thickness    = 0.0006

        local shape        = Shape()
        shape:AddRectangle(
            (baseX + offsetX) + thickness / 2,
            (baseX + offsetX) + width - (thickness / 2),
            (baseY + offsetY),
            ((baseY + offsetY) + height),
            0,
            8
        )

        local cs = ChannelStyle()
        cs.Color = color

        local ic = ImageChannel(img, 1)
        local fs = FillStyle()
        ic:SetStyleFill(fs)
        ic:ShapeFill(shape)
        ic:PutToImage("CM_Merge", cs)
    end
end


local function drawstring(img,
                          unicodeText,
                          position,
                          font,
                          emojiFont,
                          size,
                          spaceSize,
                          emojiSize,
                          color,
                          quality,
                          thickness,
                          outlineNum,
                          emojiOutlineNum,
                          highlight,
                          debug)
    local origSize = size
    local drawInfo = {}

    -- Main
    local mainDrawInfo = DrawTextInfo.New(
        { Low = 0, High = 0 },
        font.Name,
        font.Style,
        size,
        size,
        spaceSize,
        thickness,
        outlineNum,
        position.Tracking,
        color,
        position,
        { X = 0, Y = 0 }
    )
    table.insert(drawInfo, mainDrawInfo)

    -- Emoji
    local emojiDrawInfo = DrawTextInfo.New(
        { Low = 0, High = 0 },
        emojiFont.Name,
        emojiFont.Style,
        size,
        emojiSize,
        spaceSize,
        thickness,
        emojiOutlineNum,
        position.EmojiTracking,
        color,
        position,
        { X = 0, Y = 0 }
    )
    local emojiAscentGap = (mainDrawInfo.Ascent - emojiDrawInfo.Ascent) * 10 * size
    emojiDrawInfo.Mat:Move(0, -emojiAscentGap, 0)
    table.insert(drawInfo, emojiDrawInfo)

    -- Highlight
    local highlightDrawInfo = {}
    for i = 1, #highlight do
        local info = DrawTextInfo.New(
            highlight[i].Range,
            highlight[i].Font.Name,
            highlight[i].Font.Style,
            size,
            highlight[i].Font.Size,
            highlight[i].Font.SpaceSize,
            highlight[i].OutlineThickness,
            highlight[i].OutlineNum,
            highlight[i].Font.Tracking,
            highlight[i].TextColor,
            position,
            { X = 0, Y = 0 }
        )
        local highlightAscentGap = (mainDrawInfo.Ascent - info.Ascent) * 10 * size
        info.Mat:Move(0, -highlightAscentGap, 0)
        table.insert(highlightDrawInfo, info)
        table.insert(drawInfo, info)
    end

    -- Alignment
    local scaledLineSpacing = (position.LineSpacing - 1) * mainDrawInfo.Scale
    local boxHeight = (mainDrawInfo.Height * unicodeText:GetLineNum()) +
        (scaledLineSpacing * (unicodeText:GetLineNum() - 1))
    if position.Align == 0 then -- Top
        for i = 1, #drawInfo do
            drawInfo[i].Mat:Move(0, 0, 0)
        end
    elseif position.Align == 1 then -- Middle
        for i = 1, #drawInfo do
            drawInfo[i].Mat:Move(0, (boxHeight / 2), 0)
        end
    elseif position.Align == 2 then -- Bottom
        for i = 1, #drawInfo do
            drawInfo[i].Mat:Move(0, boxHeight, 0)
        end
    end

    local shapeNormal = Shape()
    local shapeOutline1 = Shape()
    local shapeOutline2 = Shape()
    local shapeHighlight = {}
    for i = 1, #highlight do
        table.insert(shapeHighlight, {
            Base = Shape(),
            Outline1 = Shape(),
            Outline2 = Shape()
        })
    end

    local prevLineDrawWidth = 0
    local characterIndex = 1
    for line = 1, unicodeText:GetLineNum() do
        local unicodeArray = unicodeText:GetLine(line)
        local lineWidth = getLineDrawWidth(
            characterIndex,
            unicodeArray,
            mainDrawInfo,
            emojiDrawInfo,
            highlightDrawInfo
        )

        -- Justify
        if position.Justify == 0 then -- Left
            for infoIndex = 1, #drawInfo do
                drawInfo[infoIndex].Mat:Move(-prevLineDrawWidth, 0, 0)
            end
        elseif position.Justify == 1 then -- Center
            for infoIndex = 1, #drawInfo do
                drawInfo[infoIndex].Mat:Move(-prevLineDrawWidth / 2, 0, 0)
                drawInfo[infoIndex].Mat:Move(-lineWidth / 2, 0, 0)
            end
        elseif position.Justify == 2 then -- Right
            for infoIndex = 1, #drawInfo do
                drawInfo[infoIndex].Mat:Move(-lineWidth, 0, 0)
            end
        end

        for i = 1, #unicodeArray do
            local characterCode = unicodeArray[i]

            local currentDrawInfo = {}
            if isEmoji(characterCode) then
                currentDrawInfo = emojiDrawInfo
            elseif 0 <= isHighlight(characterIndex, highlightDrawInfo) then
                local index = isHighlight(characterIndex, highlightDrawInfo)
                currentDrawInfo = highlightDrawInfo[index]
            else
                currentDrawInfo = mainDrawInfo
            end

            local width = currentDrawInfo.Tfm:CharacterWidth(characterCode) * 10 * currentDrawInfo.Scale
            width = width + (((currentDrawInfo.Thickness * currentDrawInfo.OutlineNum)) * currentDrawInfo.Scale)
            if isSpace(characterCode) then
                width = width * currentDrawInfo.SpaceScale
            end
            if isJapaneseSpace(characterCode) then
                width = width * (currentDrawInfo.SpaceScale * 2)
            end

            local halfWidth = width / 2

            -- if this is not the first character, apply kerning
            if 1 < i then
                local prevChar = unicodeArray[i - 1]
                local xOffset = currentDrawInfo.Tfm:CharacterKerning(prevChar, characterCode) * 10 *
                    currentDrawInfo.Scale
                for infoIndex = 1, #drawInfo do
                    drawInfo[infoIndex].Mat:Move(xOffset, 0, 0)
                end
            end

            -- move the cursor to the center of the character
            for infoIndex = 1, #drawInfo do
                drawInfo[infoIndex].Mat:Move(halfWidth, 0, 0)
            end

            -- get the shape of the character
            local characterShape = currentDrawInfo.Tfm:GetCharacterShape(characterCode, false)
            if characterShape then
                local base = characterShape:TransformOfShape(currentDrawInfo.Mat)
                local isHighlight = false
                for j = 1, #highlight do
                    if highlightDrawInfo[j]:IsWithinRange(characterIndex) then
                        shapeHighlight[j].Base:AddShape(base)
                        if 1 <= highlightDrawInfo[j].OutlineNum then
                            local outline1 = base:OutlineOfShape(
                                highlightDrawInfo[j].Thickness * currentDrawInfo.Scale, "OLT_Solid", "OJT_Round",
                                8,
                                "SWM_Normal", 8
                            )
                            shapeHighlight[j].Outline1:AddShape(outline1)
                        end
                        if 2 <= highlightDrawInfo[j].OutlineNum then
                            local outline2 = base:OutlineOfShape(
                                highlightDrawInfo[j].Thickness * 2 * currentDrawInfo.Scale, "OLT_Solid",
                                "OJT_Round", 8,
                                "SWM_Normal", 8
                            )
                            shapeHighlight[j].Outline2:AddShape(outline2)
                        end
                        isHighlight = true
                    end
                end
                if isHighlight == false then
                    shapeNormal:AddShape(base)
                    if 1 <= currentDrawInfo.OutlineNum then
                        local outline1 = base:OutlineOfShape(
                            currentDrawInfo.Thickness * currentDrawInfo.Scale, "OLT_Solid", "OJT_Round", 8, "SWM_Normal",
                            8
                        )
                        shapeOutline1:AddShape(outline1)
                    end
                    if 2 <= currentDrawInfo.OutlineNum then
                        local outline2 = base:OutlineOfShape(
                            currentDrawInfo.Thickness * 2 * currentDrawInfo.Scale, "OLT_Solid", "OJT_Round", 8,
                            "SWM_Normal", 8
                        )
                        shapeOutline2:AddShape(outline2)
                    end
                end

                local ascent = currentDrawInfo.Tfm.TextAscent * currentDrawInfo.Scale * 10
                debugRectangle(img, currentDrawInfo.Mat, -width / 2, 0, width,
                    ascent,
                    Pixel { R = 1, G = 1, B = 0, A = 0.3 }, debug)
                local descent = currentDrawInfo.Tfm.TextDescent * currentDrawInfo.Scale * 10
                debugRectangle(img, currentDrawInfo.Mat, -width / 2, -descent, width,
                    descent,
                    Pixel { R = 1, G = 1, B = 0, A = 0.5 }, debug)
            else
                debugRectangle(img, currentDrawInfo.Mat, -width / 2, -mainDrawInfo.BaseHeight / 2, width,
                    mainDrawInfo.BaseHeight,
                    Pixel { R = 0.8, G = 0.8, B = 0.8, A = 0.3 }, debug)
            end

            for infoIndex = 1, #drawInfo do
                drawInfo[infoIndex].Mat:Move(halfWidth, 0, 0)
            end

            -- Tracking
            if i < #unicodeArray then
                local trackingWidth = 0
                local debugMat = Matrix4() * currentDrawInfo.Mat
                for n = 0, 1 do
                    local tracking = 0
                    local debugColor = {}
                    if isEmoji(unicodeArray[i + n]) then
                        tracking = (((position.EmojiTracking - 1) * origSize) / 2)
                        trackingWidth = trackingWidth + tracking

                        debugColor = Pixel { R = 1, G = 0, B = 0, A = 0.3 }
                    elseif 0 <= isHighlight(characterIndex + n, highlightDrawInfo) then
                        local index = isHighlight(characterIndex + n, highlightDrawInfo)
                        tracking = (((highlightDrawInfo[index].Tracking - 1) * origSize) / 2)
                        trackingWidth = trackingWidth + tracking

                        debugColor = Pixel { R = 0, G = 1, B = 0, A = 0.3 }
                    else
                        tracking = (((position.Tracking - 1) * origSize) / 2)
                        trackingWidth = trackingWidth + tracking

                        debugColor = Pixel { R = 0, G = 0, B = 1, A = 0.3 }
                    end

                    debugRectangle(
                        img,
                        debugMat,
                        0,
                        -mainDrawInfo.BaseHeight / 2,
                        tracking,
                        mainDrawInfo.BaseHeight,
                        debugColor,
                        debug)
                    debugMat:Move(tracking, 0, 0)
                end

                for infoIndex = 1, #drawInfo do
                    drawInfo[infoIndex].Mat:Move(trackingWidth, 0, 0)
                end
            end

            characterIndex = characterIndex + 1
        end

        -- line end, move the cursor back to the start
        for infoIndex = 1, #drawInfo do
            drawInfo[infoIndex].Mat:Move(0, -(mainDrawInfo.BaseHeight + scaledLineSpacing), 0)
        end

        prevLineDrawWidth = lineWidth
    end

    local fs = FillStyle()
    local cs = ChannelStyle()
    if (outlineNum >= 2) or (emojiOutlineNum >= 2) then
        cs.Color = color:GetOutlineColor2()
        -- print("[outline2] R: " .. cs.Color.R .. " G: " .. cs.Color.G .. " B: " .. cs.Color.B .. " A: " .. cs.Color.A)
        local ic = ImageChannel(img, quality)
        ic:SetStyleFill(fs)
        ic:ShapeFill(shapeOutline2)
        ic:PutToImage("CM_Merge", cs)
    end
    if (outlineNum >= 1) or (emojiOutlineNum >= 1) then
        cs.Color = color:GetOutlineColor1()
        -- print("[outline1] R: " .. cs.Color.R .. " G: " .. cs.Color.G .. " B: " .. cs.Color.B .. " A: " .. cs.Color.A)
        local ic = ImageChannel(img, quality)
        ic:SetStyleFill(fs)
        ic:ShapeFill(shapeOutline1)
        ic:PutToImage("CM_Merge", cs)
    end

    -- highlight
    for i = 1, #highlight do
        if highlight[i].Range.Low ~= 0 or highlight[i].Range.High ~= 0 then
            if highlight[i].OutlineNum >= 2 then
                cs.Color = highlight[i].TextColor:GetOutlineColor2()
                local ic = ImageChannel(img, quality)
                ic:SetStyleFill(fs)
                ic:ShapeFill(shapeHighlight[i].Outline2)
                ic:PutToImage("CM_Merge", cs)
            end
            if highlight[i].OutlineNum >= 1 then
                cs.Color = highlight[i].TextColor:GetOutlineColor1()
                local ic = ImageChannel(img, quality)
                ic:SetStyleFill(fs)
                ic:ShapeFill(shapeHighlight[i].Outline1)
                ic:PutToImage("CM_Merge", cs)
            end
            local ic = ImageChannel(img, quality)
            cs.Color = highlight[i].TextColor:GetInnerColor()
            ic:SetStyleFill(fs)
            ic:ShapeFill(shapeHighlight[i].Base)
            ic:PutToImage("CM_Merge", cs)
        end
    end

    -- print("R: "..sInnerColor.R.." G: "..sInnerColor.G.." B: "..sInnerColor.B.." A: "..sInnerColor.A)
    cs.Color = color:GetInnerColor()
    local ic = ImageChannel(img, quality)
    ic:SetStyleFill(fs)
    ic:ShapeFill(shapeNormal)
    ic:PutToImage("CM_Merge", cs)
end

function OnAddToFlow()
    -- print("OnAddToFlow")
end

function Process(req)
    local img              = InImage:GetValue(req)
    local out              = img:CopyOf()

    -- font
    local font             = InFont:GetValue(req).Value
    local style            = InFontStyle:GetValue(req).Value
    local mainFont         = TextFont.New(font, style)

    -- emoji font
    local emojiFontEnabled = InEmojiFontEnabled:GetValue(req).Value
    local emojiFontName    = InEmojiFont:GetValue(req).Value
    local emojiFontStyle   = InEmojiFontStyle:GetValue(req).Value
    local emojiFont
    if emojiFontEnabled == 1 then
        emojiFont = TextFont.New(emojiFontName, emojiFontStyle)
    else
        emojiFont = TextFont.New(font, style)
    end

    local size       = InSize:GetValue(req).Value
    local spaceSize  = InSpaceSize:GetValue(req).Value
    local emojiSize  = InEmojiSize:GetValue(req).Value

    -- Outline
    local thickness  = InOutlineThickness:GetValue(req).Value
    local outlineNum = InOutlineNum:GetValue(req).Value
    local emojiOutlineNum
    if InCustomEmojiOutline:GetValue(req).Value == 1 then
        emojiOutlineNum = outlineNum
    else
        emojiOutlineNum = InEmojiOutlineNum:GetValue(req).Value
    end

    -- Color
    local r                = InR:GetValue(req).Value
    local g                = InG:GetValue(req).Value
    local b                = InB:GetValue(req).Value
    local a                = InA:GetValue(req).Value
    local r2               = InR2:GetValue(req).Value
    local g2               = InG2:GetValue(req).Value
    local b2               = InB2:GetValue(req).Value
    local a2               = InA2:GetValue(req).Value
    local r3               = InR3:GetValue(req).Value
    local g3               = InG3:GetValue(req).Value
    local b3               = InB3:GetValue(req).Value
    local a3               = InA3:GetValue(req).Value
    local colorTarget      = InColorTarget:GetValue(req).Value
    local outlineColorType = InOutlineColorType:GetValue(req).Value
    local textColor        = TextColor.New(
        Pixel { R = r, G = g, B = b, A = a },
        Pixel { R = r2, G = g2, B = b2, A = a2 },
        Pixel { R = r3, G = g3, B = b3, A = a3 },
        colorTarget,
        outlineColorType
    )

    -- Position
    local aspectRatio      = (out.Height * out.YScale) / (out.Width * out.XScale)
    local offset           = InOffset:GetValue(req)
    local x                = offset.X
    local y                = offset.Y * aspectRatio
    local justify          = InJustify:GetValue(req).Value
    local align            = InAlign:GetValue(req).Value
    local tracking         = InTracking:GetValue(req).Value
    local lineSpacing      = InLineSpacing:GetValue(req).Value
    local emojiTracking    = InEmojiTracking:GetValue(req).Value
    local position
    if emojiFontEnabled == 1 then
        position = TextPosition.New(x, y, justify, align, tracking, lineSpacing, emojiTracking)
    else
        position = TextPosition.New(x, y, justify, align, tracking, lineSpacing, tracking)
    end

    local text = InText:GetValue(req).Value
    local sourceText = UnicodeText.New()
    sourceText:SetText(text)

    -- Highlight
    local highlight = {}
    for i = 1, #InHighlight do
        local highLightFont = TextFont.New(InHighlight[i].Font.Name:GetValue(req).Value,
            InHighlight[i].Font.Style:GetValue(req).Value)
        local highlightSize = InHighlight[i].Font.Size:GetValue(req).Value
        local highlightSpaceSize = InHighlight[i].Font.SpaceSize:GetValue(req).Value
        local highlightTracking = InHighlight[i].Font.Tracking:GetValue(req).Value
        local highLightOutlineNum = InHighlight[i].Outline.Num:GetValue(req).Value
        local highLightOutlineThickness = InHighlight[i].Outline.Thickness:GetValue(req).Value
        local highLightTextColor = TextColor.New(
            Pixel {
                R = InHighlight[i].MainColor.R:GetValue(req).Value,
                G = InHighlight[i].MainColor.G:GetValue(req).Value,
                B = InHighlight[i].MainColor.B:GetValue(req).Value,
                A = InHighlight[i].MainColor.A:GetValue(req).Value
            },
            Pixel {
                R = InHighlight[i].Outline.Color1.R:GetValue(req).Value,
                G = InHighlight[i].Outline.Color1.G:GetValue(req).Value,
                B = InHighlight[i].Outline.Color1.B:GetValue(req).Value,
                A = InHighlight[i].Outline.Color1.A:GetValue(req).Value
            },
            Pixel {
                R = InHighlight[i].Outline.Color2.R:GetValue(req).Value,
                G = InHighlight[i].Outline.Color2.G:GetValue(req).Value,
                B = InHighlight[i].Outline.Color2.B:GetValue(req).Value,
                A = InHighlight[i].Outline.Color2.A:GetValue(req).Value
            },
            InHighlight[i].ColorTarget:GetValue(req).Value,
            InHighlight[i].Outline.Type:GetValue(req).Value
        )
        if InHighlight[i].Font.UseMainFont:GetValue(req).Value == 1 then
            highLightFont = mainFont
            highlightSize = size
            highlightSpaceSize = spaceSize
            highlightTracking = tracking
        end
        if InHighlight[i].Outline.UseMainOutline:GetValue(req).Value == 1 then
            highLightOutlineNum = outlineNum
            highLightOutlineThickness = thickness
            highLightTextColor = TextColor.New(
                highLightTextColor.BaseColor,
                textColor.CustomColor1,
                textColor.CustomColor2,
                textColor.Target,
                textColor.Type)
        end

        local rangeArray = {}
        if InHighlight[i].RangeType:GetValue(req).Value == 1 then -- specificStrings
            local specText = UnicodeText.New()
            specText:SetText(InHighlight[i].SpecificStrings:GetValue(req).Value)
            rangeArray = getSpecRangeArray(specText, sourceText)
        else
            table.insert(rangeArray, {
                Low = InHighlight[i].Range.Low:GetValue(req).Value,
                High = InHighlight[i].Range.High:GetValue(req).Value
            })
        end
        for j = 1, #rangeArray do
            table.insert(
                highlight,
                Highlight.New(
                    {
                        Low = rangeArray[j].Low,
                        High = rangeArray[j].High,
                    },
                    {
                        Name = highLightFont.Name,
                        Style = highLightFont.Style,
                        Size = highlightSize,
                        SpaceSize = highlightSpaceSize,
                        Tracking = highlightTracking
                    },
                    highLightTextColor,
                    highLightOutlineNum,
                    highLightOutlineThickness
                )
            )
        end
    end

    -- Debug
    local debug = InDebug:GetValue(req).Value

    local quality = 32
    if req:IsQuick() then
        quality = 1
    end

    -- if the FontManager list is empty, scan the font list
    -- If the UI has never been shown, as would always be the case on a render node,
    -- nothing will scan the font list for available fonts. So we check for that here,
    -- and force a scan if needed.
    if not next(FontManager:GetFontList()) then
        FontManager:ScanDir()
    end

    -- the drawstring function is doing all the heavy lifting
    drawstring(
        out,
        sourceText,
        position,
        mainFont,
        emojiFont,
        size,
        spaceSize,
        emojiSize,
        textColor,
        quality,
        thickness,
        outlineNum,
        emojiOutlineNum,
        highlight,
        debug
    )

    OutImage:Set(req, out)
end

function NotifyChanged(inp, param, time)
    -- when the tools FontFileControl is first created, the FontManager has not yet
    -- provided a FontList, so we can't set a default value. Instead we do it here.
    if (inp == InFont) or (inp == InEmojiFont) then
        local f = param.Value
        if (f == nil) or (string.len(f) == 0) then
            local fontList = FontManager:GetFontList()
            if inp == InEmojiFont and fontList["Segoe UI Emoji"] then
                inp:SetSource(Text("Segoe UI Emoji"), time)
            else
                inp:SetSource(Text("Open Sans"), time)
            end
        end
    elseif (inp == InFontStyle) or (inp == InEmojiFontStyle) then
        local f = param.Value
        if f == nil or string.len(f) == 0 then
            inp:SetSource(Text("Regular"), time)
        end
    elseif inp == InText then
        local f = param.Value
        if f and 0 < string.len(f) then
            local sourceText = UnicodeText.New()
            sourceText:SetText(f)
            local length = 0
            for i = 1, #sourceText.Unicode do
                length = length + #sourceText.Unicode[i]
            end
            for i = 1, #InHighlight do
                InHighlight[i].Range.Low:SetAttrs({
                    --     INP_MaxAllowed = length,
                    INP_MaxScale = length
                })
                InHighlight[i].Range.High:SetAttrs({
                    --     INP_MaxAllowed = length,
                    INP_MaxScale = length
                })
            end
        end
    elseif inp == InColorTarget then
        if param.Value ~= 0 and InOutlineColorType:GetSource(time).Value == 2 then -- Custom
            inp:SetSource(Number(0), time)                                         -- Inner
        end
    elseif inp == InOutlineColorType then
        if param.Value == 2 then -- Custom
            InR2:SetAttrs({ IC_Visible = true })
            InG2:SetAttrs({ IC_Visible = true })
            InB2:SetAttrs({ IC_Visible = true })
            InA2:SetAttrs({ IC_Visible = true })
            InR3:SetAttrs({ IC_Visible = true })
            InG3:SetAttrs({ IC_Visible = true })
            InB3:SetAttrs({ IC_Visible = true })
            InA3:SetAttrs({ IC_Visible = true })
            if InColorTarget:GetSource(time).Value ~= 0 then
                InColorTarget:SetSource(Number(0), time) -- Inner
            end
        else
            InR2:SetAttrs({ IC_Visible = false })
            InG2:SetAttrs({ IC_Visible = false })
            InB2:SetAttrs({ IC_Visible = false })
            InA2:SetAttrs({ IC_Visible = false })
            InR3:SetAttrs({ IC_Visible = false })
            InG3:SetAttrs({ IC_Visible = false })
            InB3:SetAttrs({ IC_Visible = false })
            InA3:SetAttrs({ IC_Visible = false })
        end
    elseif inp == InFittingTop then
        if 0 < param.Value then
            local x = (1 - InFittingPaddingWidth:GetSource(time).Value) / 2
            local y = (1 - InFittingPaddingHeight:GetSource(time).Value) / 2
            if param.Value == 1 then                 -- Top Left
                InAlign:SetSource(Number(0), time)   -- Top
                InJustify:SetSource(Number(0), time) -- Left
                InOffset:SetSource(Point(0 + x, 1 - y), time)
            elseif param.Value == 2 then             -- Top Center
                InAlign:SetSource(Number(0), time)   -- Top
                InJustify:SetSource(Number(1), time) -- Center
                InOffset:SetSource(Point(0.5, 1 - y), time)
            elseif param.Value == 3 then             -- Top Right
                InAlign:SetSource(Number(0), time)   -- Top
                InJustify:SetSource(Number(2), time) -- Right
                InOffset:SetSource(Point(1 - x, 1 - y), time)
            end
        end
    elseif inp == InFittingMiddle then
        if 0 <= param.Value then
            local x = (1 - InFittingPaddingWidth:GetSource(time).Value) / 2
            local y = (1 - InFittingPaddingHeight:GetSource(time).Value) / 2
            if param.Value == 1 then                 -- Middle Left
                InAlign:SetSource(Number(1), time)   -- Middle
                InJustify:SetSource(Number(0), time) -- Left
                InOffset:SetSource(Point(0 + x, 0.5), time)
            elseif param.Value == 2 then             -- Middle Center
                InAlign:SetSource(Number(1), time)   -- Middle
                InJustify:SetSource(Number(1), time) -- Center
                InOffset:SetSource(Point(0.5, 0.5), time)
            elseif param.Value == 3 then             -- Middle Right
                InAlign:SetSource(Number(1), time)   -- Middle
                InJustify:SetSource(Number(2), time) -- Right
                InOffset:SetSource(Point(1 - x, 0.5), time)
            end
        end
    elseif inp == InFittingBottom then
        if 0 <= param.Value then
            local x = (1 - InFittingPaddingWidth:GetSource(time).Value) / 2
            local y = (1 - InFittingPaddingHeight:GetSource(time).Value) / 2
            if param.Value == 1 then                 -- Bottom Left
                InAlign:SetSource(Number(2), time)   -- Bottom
                InJustify:SetSource(Number(0), time) -- Left
                InOffset:SetSource(Point(0 + x, 0 + y), time)
            elseif param.Value == 2 then             -- Bottom Center
                InAlign:SetSource(Number(2), time)   -- Bottom
                InJustify:SetSource(Number(1), time) -- Center
                InOffset:SetSource(Point(0.5, 0 + y), time)
            elseif param.Value == 3 then             -- Bottom Right
                InAlign:SetSource(Number(2), time)   -- Bottom
                InJustify:SetSource(Number(2), time) -- Right
                InOffset:SetSource(Point(1 - x, 0 + y), time)
            end
        end
    elseif inp == InEmojiFontEnabled then
        if param.Value == 1 then
            InEmojiFont:SetAttrs({ IC_Visible = true })
            InEmojiFontStyle:SetAttrs({ IC_Visible = true })
            InEmojiSize:SetAttrs({ IC_Visible = true })
            InEmojiTracking:SetAttrs({ IC_Visible = true })
        else
            InEmojiFont:SetAttrs({ IC_Visible = false })
            InEmojiFontStyle:SetAttrs({ IC_Visible = false })
            InEmojiSize:SetAttrs({ IC_Visible = false })
            InEmojiTracking:SetAttrs({ IC_Visible = false })
        end
    elseif inp == InCustomEmojiOutline then
        if param.Value == 0 then -- unchecked
            InEmojiOutlineNum:SetAttrs({ IC_Visible = true })
        else
            InEmojiOutlineNum:SetAttrs({ IC_Visible = false })
        end
    else
        for i = 1, #InHighlight do
            if inp == InHighlight[i].RangeType then
                if param.Value == 0 then -- Manual
                    InHighlight[i].Range.Low:SetAttrs({ IC_Visible = true })
                    InHighlight[i].Range.High:SetAttrs({ IC_Visible = true })
                    InHighlight[i].SpecificStrings:SetAttrs({ IC_Visible = false })
                else -- SpecificStrings
                    InHighlight[i].Range.Low:SetAttrs({ IC_Visible = false })
                    InHighlight[i].Range.High:SetAttrs({ IC_Visible = false })
                    InHighlight[i].SpecificStrings:SetAttrs({ IC_Visible = true })
                end
            elseif inp == InHighlight[i].Font.UseMainFont then
                if param.Value == 1 then
                    InHighlight[i].Font.Name:SetAttrs({ IC_Visible = false })
                    InHighlight[i].Font.Style:SetAttrs({ IC_Visible = false })
                    InHighlight[i].Font.Size:SetAttrs({ IC_Visible = false })
                    InHighlight[i].Font.SpaceSize:SetAttrs({ IC_Visible = false })
                    InHighlight[i].Font.Tracking:SetAttrs({ IC_Visible = false })
                else
                    InHighlight[i].Font.Name:SetAttrs({ IC_Visible = true })
                    InHighlight[i].Font.Style:SetAttrs({ IC_Visible = true })
                    InHighlight[i].Font.Size:SetAttrs({ IC_Visible = true })
                    InHighlight[i].Font.SpaceSize:SetAttrs({ IC_Visible = true })
                    InHighlight[i].Font.Tracking:SetAttrs({ IC_Visible = true })
                end
            elseif inp == InHighlight[i].Font.Name then
                local f = param.Value
                if (f == nil) or (string.len(f) == 0) then
                    inp:SetSource(Text("Open Sans"), time)
                end
            elseif inp == InHighlight[i].Font.Style then
                local f = param.Value
                if (f == nil) or (string.len(f) == 0) then
                    inp:SetSource(Text("Regular"), time)
                end
            elseif inp == InHighlight[i].Outline.UseMainOutline then
                if param.Value == 0 then
                    InHighlight[i].ColorTarget:SetAttrs({ IC_Visible = true })
                    InHighlight[i].Outline.Type:SetAttrs({ IC_Visible = true })
                    InHighlight[i].Outline.Num:SetAttrs({ IC_Visible = true })
                    InHighlight[i].Outline.Thickness:SetAttrs({ IC_Visible = true })
                    if InHighlight[i].Outline.Type:GetSource(time).Value == 2 then -- Custom
                        InHighlight[i].Outline.Color1.R:SetAttrs({ IC_Visible = true })
                        InHighlight[i].Outline.Color1.G:SetAttrs({ IC_Visible = true })
                        InHighlight[i].Outline.Color1.B:SetAttrs({ IC_Visible = true })
                        InHighlight[i].Outline.Color1.A:SetAttrs({ IC_Visible = true })
                        InHighlight[i].Outline.Color2.R:SetAttrs({ IC_Visible = true })
                        InHighlight[i].Outline.Color2.G:SetAttrs({ IC_Visible = true })
                        InHighlight[i].Outline.Color2.B:SetAttrs({ IC_Visible = true })
                        InHighlight[i].Outline.Color2.A:SetAttrs({ IC_Visible = true })
                    end
                else
                    InHighlight[i].ColorTarget:SetAttrs({ IC_Visible = false })
                    InHighlight[i].Outline.Type:SetAttrs({ IC_Visible = false })
                    InHighlight[i].Outline.Num:SetAttrs({ IC_Visible = false })
                    InHighlight[i].Outline.Thickness:SetAttrs({ IC_Visible = false })
                    InHighlight[i].Outline.Color1.R:SetAttrs({ IC_Visible = false })
                    InHighlight[i].Outline.Color1.G:SetAttrs({ IC_Visible = false })
                    InHighlight[i].Outline.Color1.B:SetAttrs({ IC_Visible = false })
                    InHighlight[i].Outline.Color1.A:SetAttrs({ IC_Visible = false })
                    InHighlight[i].Outline.Color2.R:SetAttrs({ IC_Visible = false })
                    InHighlight[i].Outline.Color2.G:SetAttrs({ IC_Visible = false })
                    InHighlight[i].Outline.Color2.B:SetAttrs({ IC_Visible = false })
                    InHighlight[i].Outline.Color2.A:SetAttrs({ IC_Visible = false })
                end
            elseif inp == InHighlight[i].Outline.Type then
                if param.Value == 2 then -- Custom
                    InHighlight[i].Outline.Color1.R:SetAttrs({ IC_Visible = true })
                    InHighlight[i].Outline.Color1.G:SetAttrs({ IC_Visible = true })
                    InHighlight[i].Outline.Color1.B:SetAttrs({ IC_Visible = true })
                    InHighlight[i].Outline.Color1.A:SetAttrs({ IC_Visible = true })
                    InHighlight[i].Outline.Color2.R:SetAttrs({ IC_Visible = true })
                    InHighlight[i].Outline.Color2.G:SetAttrs({ IC_Visible = true })
                    InHighlight[i].Outline.Color2.B:SetAttrs({ IC_Visible = true })
                    InHighlight[i].Outline.Color2.A:SetAttrs({ IC_Visible = true })
                else
                    InHighlight[i].Outline.Color1.R:SetAttrs({ IC_Visible = false })
                    InHighlight[i].Outline.Color1.G:SetAttrs({ IC_Visible = false })
                    InHighlight[i].Outline.Color1.B:SetAttrs({ IC_Visible = false })
                    InHighlight[i].Outline.Color1.A:SetAttrs({ IC_Visible = false })
                    InHighlight[i].Outline.Color2.R:SetAttrs({ IC_Visible = false })
                    InHighlight[i].Outline.Color2.G:SetAttrs({ IC_Visible = false })
                    InHighlight[i].Outline.Color2.B:SetAttrs({ IC_Visible = false })
                    InHighlight[i].Outline.Color2.A:SetAttrs({ IC_Visible = false })
                end
            end
        end
    end
end
